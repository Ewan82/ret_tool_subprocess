!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6693) -  5 Jan 2018 14:09
!
!  Differentiation of simulate_fapar in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional
!):
!   variations   of useful results: y
!   with respect to varying inputs: x
!   RW status of diff variables: x:in y:out
!***********************************************************
!     simulate_fapar
!
!> @brief Implementation of the combined S1 and S2 observation operator.
!>        Computes backscatter values (VH,VV) and top-of-canopy BRFs in 13 Sentinel2 bands
!>        for the respective states in the control vector.
!
!
!> @param[in]   n  length of control vector for multiple simulations in MW and optical domain
!> @param[in]   x  control vector normalised by prior uncertainty
!                  (expected ordering is: S1 related parameter(s) followed by
!                   by state variables LAI,HC,SM per 'simulation point')
!> @param[in]   m  length of output vector
!> @param[out]  y  simulated backscatter values (VH,VV) and simulated TOC BRFs
!                  (for all 13 S2 wave-bands)
!                  (Ordering is: simulated backscatter values per 'simulation point'
!                                followed by BRF values per 'simulation point')
!
SUBROUTINE SIMULATE_FAPAR_FWV(n, x, x_fwv, m, y, y_fwv, nbdirs)
  USE MO_SENSIMUL, ONLY : nsc, iv_geom
  USE MO_SENSIMUL, ONLY : get_np, get_n, get_npts
  USE MO_SENSIMUL, ONLY : idx_is_s2, sim_fill_value
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: y(m)
  REAL(kind=8), INTENT(OUT) :: y_fwv(nbdirsmax, m)
! externals
  EXTERNAL FAPAR_OPERATOR_1GEOM
  EXTERNAL FAPAR_OPERATOR_1GEOM_FWV
! local decls
  REAL(kind=8) :: xphys(n)
  REAL(kind=8) :: xphys_fwv(nbdirsmax, n)
  INTEGER :: ipt
  INTEGER :: ii0, ii1
  REAL(kind=8) :: statev(nsc)
  REAL(kind=8) :: statev_fwv(nbdirsmax, nsc)
  REAL(kind=8) :: single_ivgeom(4)
!-- debugging
  REAL(kind=8) :: init, finish
  LOGICAL :: ldebug
  INTRINSIC CPU_TIME
  INTEGER :: nd
  INTEGER :: nbdirs
!-- dimension consistency
  IF (n .NE. GET_N()) THEN
    WRITE(*, '(a,2(a,i3,1x))') &
&   ' FATAL::simulate_fapar:inconsistent length of state vector!', &
&   'expected=', GET_N(), 'got=', n
    STOP
  ELSE IF (m .NE. GET_NPTS()) THEN
    WRITE(*, '(a,2(a,i3,1x))') &
&   ' FATAL::simulate_fapar:inconsistent length of simulation vector.', &
&   'expected=', GET_NPTS(), 'got=', m
    STOP
  ELSE
!-- initialise
    ldebug = .false.
    y(1:m) = sim_fill_value
!-- get physical control vector
    CALL X2P_FWV(n, x, x_fwv, xphys, xphys_fwv, nbdirs)
!-- loop over all time-points
!-- state-vector components start *after* parameter
    ii0 = GET_NP() + 1
    DO nd=1,nbdirs
      y_fwv(nd, :) = 0.0_8
      statev_fwv(nd, :) = 0.0_8
    END DO
simloop:DO ipt=1,m
      IF (.NOT.IDX_IS_S2(ipt)) THEN
!-- no S2 simulation at 'ipt', continue to next point
        ii0 = ii0 + nsc
      ELSE
        IF (ldebug) THEN
          WRITE(*, '(a,i2)') ' DEBUG::simulate_fapar_fwv:starting ipt=', ipt
          CALL CPU_TIME(init)
        END IF
!-- extract 'nsc' state vector components
!   for current time-point
        ii1 = ii0 + nsc - 1
        DO nd=1,nbdirs
          statev_fwv(nd, 1:nsc) = xphys_fwv(nd, ii0:ii1)
        END DO
        statev(1:nsc) = xphys(ii0:ii1)
!-- get geometry for this time-point
        single_ivgeom(1:4) = iv_geom(1:4, ipt)
        CALL FAPAR_OPERATOR_1GEOM_FWV(statev, statev_fwv, single_ivgeom&
&                               , y(ipt), y_fwv(:, ipt), nbdirs)
!-- increment start position
        ii0 = ii1 + 1
        IF (ldebug) THEN
          CALL CPU_TIME(finish)
          WRITE(*, '(a,i2,1x,a,f6.2)') &
&         ' DEBUG::simulate_fapar_fwv:finished ipt=', ipt, 'elapsed=', &
&         finish - init
        END IF
      END IF
    END DO simloop
  END IF
END SUBROUTINE SIMULATE_FAPAR_FWV

!  Differentiation of fapar_operator_1geom in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirec
!tional):
!   variations   of useful results: fapar /multi/[0,6720[ /multi/[6720,13440[
!                /multi/[13440,20160[
!   with respect to varying inputs: statev /multi/[0,6720[ /multi/[6720,13440[
!                /multi/[13440,20160[
!***********************************************************
!     fapar_operator_1geom
!
!> @brief Implementation of the FAPAR target operator.
!
!> @details For the given input state (LAI_coeff, LAI, HC, and SM) the observation operator
!>          derives FAPAR, i.e. the Fraction of Absorbed Photosynthetically Active radiation in the canopy in the visible domain 
!(400nm - 700nm)
!
!> @param[in]   statev   state components required to run S1 simulation
!>                       consisting of LAI conversion coefficient, (optical) LAI, HC, and SM
!> @param[in]   iv_geom  illumination-view geomtry in order sza,saa,vza,vaa (in degrees)
!> @param[out]  fapar    FAPAR
!
SUBROUTINE FAPAR_OPERATOR_1GEOM_FWV(statev, statev_fwv, iv_geom, fapar, &
& fapar_fwv, nbdirs)
  USE MO_SENSIMUL, ONLY : nsc
  USE MO_SENSIMUL_S2
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: statev(nsc)
  REAL(kind=8), INTENT(IN) :: statev_fwv(nbdirsmax, nsc)
!sza,saa,vza,vaa
  REAL(kind=8), INTENT(IN) :: iv_geom(4)
  REAL(kind=8), INTENT(OUT) :: fapar
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: fapar_fwv
! local decls
  REAL :: lai, hc, sm
  REAL, DIMENSION(nbdirsmax) :: lai_fwv, hc_fwv, sm_fwv
  REAL :: rsl1
  REAL, DIMENSION(nbdirsmax) :: rsl1_fwv
  REAL :: theta_i, phi_i, theta_v, phi_v
!-- NOTE:'nadime_prospect_price_fast_1geom' uses plain 'real' as type declarator
  REAL :: brf_(nwvis1nm), fpar_(nwvis1nm), albedo_(nwvis1nm), trans_(&
& nwvis1nm)
  REAL :: fpar__fwv(nbdirsmax, nwvis1nm)
  REAL(kind=8) :: fpar_r8(nwvis1nm)
  REAL(kind=8) :: fpar_r8_fwv(nbdirsmax, nwvis1nm)
! externals
  REAL, EXTERNAL :: SM_TO_RSL1
  EXTERNAL NADIME_PROSPECT_PRICE_FULL_1GEOM
  EXTERNAL NADIME_PROSPECT_PRICE_FULL_1GEOM_FWV
  REAL(kind=8), EXTERNAL :: CONVOLVE
  INTRINSIC REAL
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
!-- map state variables
!   (might potentially cast from r8 to r4)
    lai_fwv(nd) = statev_fwv(nd, 1)
    hc_fwv(nd) = statev_fwv(nd, 2)
    sm_fwv(nd) = statev_fwv(nd, 3)
  END DO
  lai = statev(1)
  hc = statev(2)
  sm = statev(3)
!-- 1st spectral vector of soil reflectance (of Price's EOF)
!   is modulated by the soil moisture state
  CALL SM_TO_RSL1_FWV0(sm, sm_fwv, rsl1_default, sm_coeff, rsl1, &
&                rsl1_fwv, nbdirs)
!-- geometry
  theta_i = iv_geom(1)
  phi_i = iv_geom(2)
  theta_v = iv_geom(3)
  phi_v = iv_geom(4)
!-- call coupled optical model for nwvis1nm wavelenghts starting at 400nm
  CALL NADIME_PROSPECT_PRICE_FULL_1GEOM_FWV(nw1nm, nwvis1nm, theta_i, &
&                                     phi_i, theta_v, phi_v, lad, rpl, &
&                                     lai, lai_fwv, hc, hc_fwv, vai, cab&
&                                     , cw, cp, cc, rsl1, rsl1_fwv, rsl2&
&                                     , rsl3, rsl4, brf_, fpar_, &
&                                     fpar__fwv, albedo_, trans_, nbdirs&
&                                    )
  DO nd=1,nbdirs
!-- ensure correct precision
    fpar_r8_fwv(nd, :) = fpar__fwv(nd, :)
  END DO
  fpar_r8 = REAL(fpar_, kind=8)
!-- integration over wave-lenghts (convolve)
  CALL CONVOLVE_FWV0(nwvis1nm, fpar_r8, fpar_r8_fwv, solspect_response, &
&              fapar, fapar_fwv, nbdirs)
END SUBROUTINE FAPAR_OPERATOR_1GEOM_FWV

!  Differentiation of nadime_prospect_price_full_1geom in forward (tangent) mode (with options messagesInFile noinclude noISIZE r
!8 multiDirectional):
!   variations   of useful results: fpar /multi/[0,6720[ /multi/[6720,13440[
!                /multi/[13440,20160[
!   with respect to varying inputs: lai hc rsl1 /multi/[0,6720[
!                /multi/[6720,13440[ /multi/[13440,20160[
!***********************************************************
!     nadime_prospect_price_full_1geom
!
!> @brief runs the extended coupled NADIM-PROSPECT-PRICE model for every wavelength at 1nm resolution and derives the bihemisphic
! reflectance factor (BRF), the fraction absorbed in the canopy (FPAR), the albedo, and the transmission.
!
!> @details TBD
!
!> @param[in]  nw1nm        number of 1nm wavelengths in range [400nm,2500nm]
!> @param[in]  nw           number of wave-bands actuall used (starting from 400nm)
!> @param[in]  resp_mat     responses for every wavelength in [400nm,2500nm] and all 'nb' bands
!> @param[in]  theta_i      illumination zenith angle [deg]
!> @param[in]  phi_i        illumination azimuth angle [deg]
!> @param[in]  theta_v      viewing zenith angle [deg]
!> @param[in]  phi_v        viewing azimuth angle [deg]
!> @param[in]  lad          Leaf angle distribution (1:Planophile, 2:Erectophile, 3:Plagiophile, 4:Extremophile, 5:Uniforme
!> @param[in]  rpl          radius of single leaf
!> @param[in]  lai          leaf area index [m^2/m^2]
!> @param[in]  hc           canopy height [m]
!> @param[in]  vai          leaf structure (PROSPECT)
!> @param[in]  cab          leaf chlorophyll (PROSPECT)
!> @param[in]  cw           leaf water equivelent thickness (PROSPECT)
!> @param[in]  cp           protein concentration (PROSPECT)
!> @param[in]  cc           cellulose and lignin (PROSPECT)
!> @param[in]  rsl1         weight of first spectral vector of the soil reflectance (PRICE)
!> @param[in]  rsl2         weight of second spectral vector of the soil reflectance (PRICE)
!> @param[in]  rsl3         weight of third spectral vector of the soil reflectance (PRICE)
!> @param[in]  rsl4         weight of fourth spectral vector of the soil reflectance (PRICE)
!> @param[out] brf          Bidirectional reflectance factor
!
SUBROUTINE NADIME_PROSPECT_PRICE_FULL_1GEOM_FWV(nw1nm, nw, theta_i, &
& phi_i, theta_v, phi_v, lad, rpl, lai, lai_fwv, hc, hc_fwv, vai, cab, &
& cw, cp, cc, rsl1, rsl1_fwv, rsl2, rsl3, rsl4, brf, fpar, fpar_fwv, &
& albedo, trans, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! constants
!number of view--illumination geometries
  INTEGER, PARAMETER :: niv=1
! arguments
!-- actual  number of 1nm wave-lengths [400nm,400nm+nw-1]
  INTEGER, INTENT(IN) :: nw
!-- maximal number of 1nm wave-lenghts [400nm,2500nm]
  INTEGER, INTENT(IN) :: nw1nm
  REAL, INTENT(IN) :: theta_i, phi_i, theta_v, phi_v
  INTEGER, INTENT(IN) :: lad
  REAL, INTENT(IN) :: rpl, lai, hc
  REAL, DIMENSION(nbdirsmax), INTENT(IN) :: lai_fwv, hc_fwv
  REAL(kind=8), INTENT(IN) :: vai, cab, cw, cp, cc
  REAL, INTENT(IN) :: rsl1, rsl2, rsl3, rsl4
  REAL, DIMENSION(nbdirsmax), INTENT(IN) :: rsl1_fwv
  REAL, INTENT(OUT) :: brf(nw), fpar(nw), albedo(nw), trans(nw)
  REAL, INTENT(OUT) :: fpar_fwv(nbdirsmax, nw)
! externals
  EXTERNAL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN
  EXTERNAL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_FWV
  EXTERNAL PROSPECT_FULLSPECTRUM_INTERP1NM_FTN
! local variables
  INTEGER :: iw
! leaf reflectance/transmittance
  REAL(kind=8) :: p_rl(nw1nm), p_tl(nw1nm)
! soil reflectance
  REAL(kind=8) :: p_rs(nw1nm)
  REAL(kind=8) :: p_rs_fwv(nbdirsmax, nw1nm)
! ...as normal 'real'
  REAL :: rl, tl, rs
  REAL, DIMENSION(nbdirsmax) :: rs_fwv
!-- Note: single NADIM call is for single illumination/view geometry
  REAL :: theta_v_asarr(niv), phi_v_asarr(niv)
  REAL :: brf_nadim(niv), fpar_nadim(niv), albedo_nadim(niv), &
& trans_nadim(niv)
  REAL :: fpar_nadim_fwv(nbdirsmax, niv)
  INTEGER :: nd
  INTEGER :: nbdirs
!-- scalar to 1D array
  theta_v_asarr(1) = theta_v
  phi_v_asarr(1) = phi_v
!-- get leaf optical properties: [400nm,2500nm] at 1nm resolution
  CALL PROSPECT_FULLSPECTRUM_INTERP1NM_FTN(vai, cab, cw, cp, cc, p_rl, &
&                                    p_tl)
! get soil reflectance: [400nm,2500nm] at 1nm resolution
  CALL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_FWV(rsl1, rsl1_fwv, rsl2, &
&                                          rsl3, rsl4, p_rs, p_rs_fwv, &
&                                          nbdirs)
  DO nd=1,nbdirs
    fpar_fwv(nd, :) = 0.0_8
    fpar_nadim_fwv(nd, :) = 0.0_8
  END DO
!-- loop over all wavelengthts
bndloop:DO iw=1,nw
    DO nd=1,nbdirs
!-- set soil-reflectance, leaf reflectance/transmittance
      rs_fwv(nd) = p_rs_fwv(nd, iw)
    END DO
    rs = p_rs(iw)
    rl = p_rl(iw)
    tl = p_tl(iw)
!-- BRF computation by NADIM
    CALL NADIMBRFE_FWV(theta_i, phi_i, niv, theta_v_asarr, phi_v_asarr, &
&                lad, rs, rs_fwv, hc, hc_fwv, lai, lai_fwv, rpl, rl, tl&
&                , brf_nadim, fpar_nadim, fpar_nadim_fwv, albedo_nadim, &
&                trans_nadim, nbdirs)
! TAPENADE: (TC30) Type mismatch in argument 14 of procedure nadimbrfe, expected REAL, is here REAL(1)
! TAPENADE: (TC30) Type mismatch in argument 15 of procedure nadimbrfe, expected REAL, is here REAL(1)
! TAPENADE: (TC30) Type mismatch in argument 16 of procedure nadimbrfe, expected REAL, is here REAL(1)
!-- save NADIM output
    brf(iw) = brf_nadim(1)
    DO nd=1,nbdirs
      fpar_fwv(nd, iw) = fpar_nadim_fwv(nd, 1)
    END DO
    fpar(iw) = fpar_nadim(1)
    albedo(iw) = albedo_nadim(1)
    trans(iw) = trans_nadim(1)
  END DO bndloop
END SUBROUTINE NADIME_PROSPECT_PRICE_FULL_1GEOM_FWV

!  Differentiation of nadimbrfe in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: i0 xif xi1u fpar
!   with respect to varying inputs: i0 xif xi1u xlai fpar xhc xrs
!**************************************************************
!  Name : nadimbrf_energie.f
!  additional routine by tristan quaife for calling the energie
!  subroutine at the end of the brf routine to avoid horrible
!  global variable when calling from C
!***************************************************************
SUBROUTINE NADIMBRFE_FWV(theta_i, phi_i, nv, theta_v, phi_v, lad, xrs, &
& xrs_fwv, xhc, xhc_fwv, xlai, xlai_fwv, rpl, xrl, xtl, brf, fpar, &
& fpar_fwv, albedo_sys, trans_total, nbdirs)
  IMPLICIT NONE
  INCLUDE 'DIFFSIZES.inc'
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  INTEGER :: lad, nv
!     MVO::switched 1000->NV in array declarator
  REAL :: brf(nv)
  REAL :: theta_v(nv), phi_v(nv), theta_i, phi_i
!$$$      REAL BRF(1000)
!$$$      REAL THETA_V(1000),PHI_V(1000),THETA_I,PHI_I
  REAL :: xlai, xhc, rpl, xrl, xtl, xrs
  REAL, DIMENSION(nbdirsmax) :: xlai_fwv, xhc_fwv, xrs_fwv
!     MVO::added type declarations
  REAL :: fpar, albedo_sys, trans_total
  REAL, DIMENSION(nbdirsmax) :: fpar_fwv
!***********************************************
!
!     Subroutine NADIMBRDF.f
!
!**********************************************
!
!  Output variable : BRF   = Bidirectional Reflectance Factor 
!
! 
!  Input variables :
!                       NV      = NUMBER OF VIEWING ANGLES
!                       THETA_I = SOLAR ZENITH ANGLE (IN DEGREES)
!                       PHI_I   = SOLAR AZIMUTH ANGLE (IN DEGREES)
!                       THETA_V = VIEWING ZENITH ANGLE (IN RADIANS)
!                       PHI_V   = VIEWING AZIMUTH ANGLE (IN RADIANS)
!
!                       LAD     = Leaf Angle Distribution
!                       = 1   <---> Planophile
!                       = 2   <---> Erectophile
!                       = 3   <---> Plagiophile
!                       = 4   <---> Extremophile
!                       = 5   <---> Uniforme
!
!                       XRS     = SOIL ALBEDO
!                       XHC     = HEIGHT OF THE CANOPY
!                       XLAI    = Leaf Area Index
!                       RPL     = radius of a single leaf
!                       XRL     = leaf reflectance
!                       XTL     = leaf transmittance
!
!************************************************************ 
!
!     MVO::added type declaration
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x_lambda_i, r1, r2, r3, xmeas
!     MVO::n_c type changed
!$$$      real df,x_nf,a_f,n_c,h_c,x_ly,r 
  REAL :: df, x_nf, a_f, h_c, x_ly, r
  REAL, DIMENSION(nbdirsmax) :: h_c_fwv
  INTEGER :: n_c
  REAL :: c1
  REAL, DIMENSION(nbdirsmax) :: c1_fwv
  REAL :: weights, points
  REAL :: rs
  REAL, DIMENSION(nbdirsmax) :: rs_fwv
  REAL :: tl, rl, lai
  REAL, DIMENSION(nbdirsmax) :: lai_fwv
  REAL :: ag, bg, cg, dg
  INTEGER :: number, ild
!     MVO::switched 1000->NV in array declarator
  REAL :: teta(nv), phi(nv)
!$$$      real teta(1000),phi(1000)
  REAL :: teta_0, phi_0
!
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, RHO_0_NAD, RHO_1_NAD, RHO_MULT_NAD
  INTEGER :: i, na
  REAL :: i0, xif, xi1u, xi1, ximt
  REAL, DIMENSION(nbdirsmax) :: i0_fwv(nbdirsmax, 21, 40), xif_fwv(&
& nbdirsmax, 21, 40), xi1u_fwv(nbdirsmax, 21, 40), xi1_fwv, ximt_fwv
!
!
!       COMMON DATAS
!
!     MVO::revised order (alignment-issue after n_c has type integer)
!$$$      common/canopee/df,x_nf,a_f,n_c,h_c,x_ly,r 
  COMMON /canopee/ df, x_nf, a_f, h_c, x_ly, r, n_c
  COMMON /hp/ c1
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /coef/ ag, bg, cg, dg
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  COMMON /angle_sol/ teta_0, phi_0
  INTRINSIC COS
  INTRINSIC ABS
  REAL :: abs0
  REAL :: abs1
  REAL :: result1
  REAL :: result2
  INTEGER :: nd
  INTEGER :: nbdirs
  REAL :: x2
  REAL :: x1
  COMMON /limite_fwv/ xi1_fwv, ximt_fwv
  COMMON /multi_fwv/ i0_fwv, xif_fwv, xi1u_fwv
  COMMON /feuille_fwv/ lai_fwv
  COMMON /sol_fwv/ rs_fwv
  COMMON /hp_fwv/ c1_fwv
  COMMON /canopee_fwv/ h_c_fwv
  DO nd=1,nbdirs
!--------------------------------------------------
!
!       INPUT PARAMETERS
!
!       teta_0,phi_0            solar angles
!       ild                     leaf distribution
!       R_s                     soil albedo
!       h_c                     height of canopee (m)
!       df                      diameter of a single leaf (m)
!       lai                     leaf area index
!       rl                      leaf reflectance
!       tl                      leaf transmittance
!       na                      number of viewing angle
!       teta(i),phi(i)          viewing angles
!---------------------------------------------------------
!
!       INPUT PARAMETERS <------ ROUTINE
!
    lai_fwv(nd) = xlai_fwv(nd)
    h_c_fwv(nd) = xhc_fwv(nd)
    rs_fwv(nd) = xrs_fwv(nd)
  END DO
  lai = xlai
  h_c = xhc
  df = rpl*2.
  ild = lad
  rl = xrl
  tl = xtl
  rs = xrs
  na = nv
!**************************************************
!
!       DEGREES ---> RADIANS
!
  teta_0 = (180.-theta_i)*pi/180.
  phi_0 = phi_i*pi/180.
  DO i=1,na
    teta(i) = theta_v(i)*pi/180.
    phi(i) = phi_v(i)*pi/180.
  END DO
!
!****************************************************
!
!       CALL SUBROUTINES WRITTING IN NADIMTOOLS.f
!
!***************************************************
!
!       16 GAUSS POINTS and WEIGHTS
!       to compute numerical integrals
!       and discrete ordinates methods
!
!
  number = 16
  CALL GAULEG(-1., 1., points, weights, number)
!---------------------------------------------  
!
!      COEFFICIENTS FUNCTIONS OF DISTRIBUTION BUNNIK
!
!       (leaf angle distribution functions)
!
  CALL BUNNIK(ild)
!
!---------------------------------------------
!
!       GEOMETRIE CANOPY
!
  CALL ARCHI_FWV(lai, lai_fwv, teta_0, nbdirs)
!---------------------------------------------  
!
!       MULTIPLE INTENSITIES FOR ANGULAR POINTS GAUSS
!
!
  CALL MULTIPLE_DOM_FWV(teta_0, nbdirs)
!
!-----------------------------------------------
  DO i=1,na
    x1 = COS(teta_0)
    IF (x1 .GE. 0.) THEN
      abs0 = x1
    ELSE
      abs0 = -x1
    END IF
    x2 = COS(teta(i))
    IF (x2 .GE. 0.) THEN
      abs1 = x2
    ELSE
      abs1 = -x2
    END IF
    result1 = G_ROSS(teta_0)
    result2 = G_ROSS(teta(i))
    x_lambda_i = 0.01*abs0/result1*abs1/result2
!
!   the three orders brdf   
!
    r1 = RHO_0_NAD(teta(i), phi(i), x_lambda_i)
    r2 = RHO_1_NAD(teta(i), phi(i), x_lambda_i)
    r3 = RHO_MULT_NAD(teta(i))
!
! so the sum ..to have the brdf total.
!
    xmeas = r3 + r1 + r2
    brf(i) = xmeas
    CALL ENERGIE_FWV(theta_i, phi_i, fpar, fpar_fwv, albedo_sys, &
&              trans_total, nbdirs)
  END DO
  RETURN
END SUBROUTINE NADIMBRFE_FWV
!
!
!

!  Differentiation of energie in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: fpar
!   with respect to varying inputs: rs lai i0 xif xi1u xi1 ximt
!                /hp/[0,8[
!
!******************************************************
!
!       ENERGY BALANCE
!
!
SUBROUTINE ENERGIE_FWV(teta_i, phi_i, fpar, fpar_fwv, albedo_sys, &
& trans_totale, nbdirs)
  IMPLICIT NONE
  INCLUDE 'DIFFSIZES.inc'
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
!
  REAL :: weights, points
  REAL :: rs
  REAL, DIMENSION(nbdirsmax) :: rs_fwv
  REAL :: tl, rl, lai
  REAL, DIMENSION(nbdirsmax) :: lai_fwv
  REAL :: ag, bg, cg, dg
  INTEGER :: number, ild
  REAL :: i0, xif, xi1u
  REAL, DIMENSION(nbdirsmax, 21, 40) :: i0_fwv, xif_fwv, xi1u_fwv
  REAL :: xi1, ximt
  REAL, DIMENSION(nbdirsmax) :: xi1_fwv, ximt_fwv
  REAL :: teta_0, phi_0, teta_i, phi_i
  REAL :: fpar_tur, alb_tur, tran
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, RHO_0_NAD, RHO_1_NAD, RHO_MULT_NAD
  REAL, EXTERNAL :: GAMMA_LEAF
  INTEGER :: i, j, k
  REAL :: trans_1, trans_1_in, trans_in_m, trans_m
  REAL, DIMENSION(nbdirsmax) :: trans_m_fwv
  REAL :: x_lambda_0, xt_directe
  INTEGER :: m0, mmm
!
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /coef/ ag, bg, cg, dg
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  COMMON /angle_sol/ teta_0, phi_0
  COMMON /energie_tur/ fpar_tur, alb_tur, tran
!
  REAL :: teta_s, phi_s, fpar, albedo_sys, trans_totale
  REAL, DIMENSION(nbdirsmax) :: fpar_fwv, albedo_sys_fwv, &
& trans_totale_fwv
  REAL :: gs, xmus, xm, xr, ym, yr
!     MVO::MM switched type real->integer
!$$$      real phi_w,teta_w,x,y,x_lambda(32,32),MM(32,32)
  REAL :: phi_w, teta_w, x, y, x_lambda(32, 32)
  INTEGER :: mm(32, 32)
  REAL :: x_rho_0(32, 32), x_rho_1(32, 32), x_rho_m(32, 32)
  REAL :: x_rho_0_fwv(nbdirsmax, 32, 32), x_rho_1_fwv(nbdirsmax, 32, 32)&
& , x_rho_m_fwv(nbdirsmax, 32, 32)
  REAL :: sum_y, sum_x, sum_k, gamma_0(32, 32)
  REAL, DIMENSION(nbdirsmax) :: sum_y_fwv, sum_x_fwv
  REAL :: g_w(32), t_i1d(32, 32)
  REAL :: tr_tur, tr_dir_tur
  INTRINSIC COS
  INTRINSIC ACOS
  INTRINSIC ABS
  INTRINSIC INT
  REAL :: abs0
  REAL :: abs1
  REAL :: abs2
  REAL :: abs3
  REAL :: abs4
  REAL :: abs5
  REAL :: abs6
  REAL :: abs7
  REAL :: abs8
  REAL :: abs9
  REAL :: abs10
  REAL :: abs11
  REAL :: abs12
  REAL :: abs13
  REAL :: abs14
  REAL :: abs15
  REAL :: abs16
  REAL :: arg1
  REAL :: pwx1
  INTEGER :: pwy1
  REAL :: pwr1
  REAL :: pwx2
  REAL :: pwr2
  INTEGER :: nd
  INTEGER :: ii2
  INTEGER :: ii1
  INTEGER :: nbdirs
  REAL :: x2
  REAL :: x1
  COMMON /limite_fwv/ xi1_fwv, ximt_fwv
  COMMON /multi_fwv/ i0_fwv, xif_fwv, xi1u_fwv
  COMMON /feuille_fwv/ lai_fwv
  COMMON /sol_fwv/ rs_fwv
!
  teta_s = (180.-teta_i)*pi/180.
  phi_s = (180.-phi_i)*pi/180.
!
! BRF FOR THE GAUSS POINTS   
!
  gs = G_ROSS(teta_s)
  xmus = COS(teta_s)
!    
  xm = 0.5*(1.-1.)
  xr = 0.5*(1.+1.)
  ym = 0.5*(2.*pi-0.)
  yr = 0.5*(2.*pi+0.)
!
! TABLE OF THE G_ross function
! Number of levels MM
! and BRF for all points of the Gauss quadrature
!
  DO j=1,number
    x = xm + xr*points(j)
    teta_w = ACOS(x)
    g_w(j) = G_ROSS(teta_w)
  END DO
  DO nd=1,nbdirs
    DO ii1=1,32
      DO ii2=1,32
        x_rho_m_fwv(nd, ii2, ii1) = 0.D0
      END DO
    END DO
    DO ii1=1,32
      DO ii2=1,32
        x_rho_0_fwv(nd, ii2, ii1) = 0.D0
      END DO
    END DO
    DO ii1=1,32
      DO ii2=1,32
        x_rho_1_fwv(nd, ii2, ii1) = 0.D0
      END DO
    END DO
  END DO
!
  DO i=1,number
    y = ym + yr*points(i)
    phi_w = y
    DO j=1,number
      x = xm + xr*points(j)
      teta_w = ACOS(x)
      x1 = COS(teta_s)
      IF (x1 .GE. 0.) THEN
        abs0 = x1
      ELSE
        abs0 = -x1
      END IF
      x2 = COS(teta_w)
      IF (x2 .GE. 0.) THEN
        abs14 = x2
      ELSE
        abs14 = -x2
      END IF
      x_lambda(i, j) = 0.01*abs0/gs*abs14/g_w(j)
      arg1 = lai/x_lambda(i, j)
      mm(i, j) = INT(arg1)
      CALL RHO_0_NAD_FWV0(teta_w, phi_w, x_lambda(i, j), x_rho_0(i, j), &
&                   x_rho_0_fwv(1, i, j), nbdirs)
      CALL RHO_1_NAD_FWV0(teta_w, phi_w, x_lambda(i, j), x_rho_1(i, j), &
&                   x_rho_1_fwv(1, i, j), nbdirs)
      CALL RHO_MULT_NAD_FWV0(teta_w, x_rho_m(i, j), x_rho_m_fwv(1, i, j)&
&                      , nbdirs)
    END DO
  END DO
!
! COMPUTATION OF THE ALBEDO
!
  sum_y = 0.
  DO nd=1,nbdirs
    sum_y_fwv(nd) = 0.D0
  END DO
  DO i=1,number
    y = ym + yr*points(i)
    sum_x = 0.
    DO nd=1,nbdirs
      sum_x_fwv(nd) = 0.D0
    END DO
    DO j=number/2+1,number
      x = xm + xr*points(j)
      IF (x .GE. 0.) THEN
        abs1 = x
      ELSE
        abs1 = -x
      END IF
      DO nd=1,nbdirs
        sum_x_fwv(nd) = sum_x_fwv(nd) + weights(j)*abs1*xr*(x_rho_0_fwv(&
&         nd, i, j)+x_rho_1_fwv(nd, i, j)+x_rho_m_fwv(nd, i, j))
      END DO
      sum_x = sum_x + (x_rho_0(i, j)+x_rho_1(i, j)+x_rho_m(i, j))*&
&       weights(j)*abs1*xr
    END DO
    DO nd=1,nbdirs
      sum_y_fwv(nd) = sum_y_fwv(nd) + weights(i)*yr*sum_x_fwv(nd)
    END DO
    sum_y = sum_y + sum_x*weights(i)*yr
  END DO
  DO nd=1,nbdirs
    albedo_sys_fwv(nd) = sum_y_fwv(nd)/pi
  END DO
  albedo_sys = sum_y/pi
!
! DOWNWARD FIRST COLLIDED INTENSITIES WITH DISCRETE APPROACH   
!
  DO i=1,number
    y = ym + yr*points(i)
    phi_w = y
    DO j=1,number/2
      x = xm + xr*points(j)
      teta_w = ACOS(x)
      gamma_0(i, j) = GAMMA_LEAF(teta_s, phi_s, teta_w, phi_w)
    END DO
  END DO
!        
  DO i=1,number
    y = ym + yr*points(i)
    phi_w = y
    DO j=1,number/2
      x = xm + xr*points(j)
      teta_w = ACOS(x)
      sum_k = 0
      mmm = mm(i, j)
      DO k=1,mmm
        IF (x .GE. 0.) THEN
          abs2 = x
        ELSE
          abs2 = -x
        END IF
        IF (xmus .GE. 0.) THEN
          abs15 = xmus
        ELSE
          abs15 = -xmus
        END IF
        pwx1 = 1. - x_lambda(i, j)*g_w(j)/abs2
        pwy1 = mmm - k
        pwr1 = pwx1**pwy1
        pwx2 = 1. - x_lambda(i, j)*gs/abs15
        pwr2 = pwx2**k
        sum_k = sum_k + pwr1*x_lambda(i, j)*pwr2
      END DO
      IF (x .GE. 0.) THEN
        abs3 = x
      ELSE
        abs3 = -x
      END IF
      t_i1d(i, j) = sum_k*gamma_0(i, j)*(1./(pi*abs3))
    END DO
  END DO
! 
! TRANSMISSION OF THE FIRST COLLIDED INTENSITIES        
!
  sum_y = 0.
  DO i=1,number
    y = ym + yr*points(i)
    sum_x = 0.
    DO j=1,number/2
      x = xm + xr*points(j)
      IF (x .GE. 0.) THEN
        abs4 = x
      ELSE
        abs4 = -x
      END IF
      sum_x = sum_x + t_i1d(i, j)*weights(j)*abs4*xr
    END DO
    sum_y = sum_y + sum_x*weights(i)*yr
  END DO
  IF (xmus .GE. 0.) THEN
    abs5 = xmus
  ELSE
    abs5 = -xmus
  END IF
  trans_1 = sum_y/abs5
!
  sum_y = 0.
  DO i=1,number
    y = ym + yr*points(i)
    sum_x = 0.
    DO j=1,number/2
      x = xm + xr*points(j)
      IF (x .GE. 0.) THEN
        abs6 = x
      ELSE
        abs6 = -x
      END IF
      sum_x = sum_x + t_i1d(i, j)*rs*weights(j)*abs6*xr
    END DO
    sum_y = sum_y + sum_x*weights(i)*yr
  END DO
  IF (xmus .GE. 0.) THEN
    abs7 = xmus
  ELSE
    abs7 = -xmus
  END IF
  trans_1_in = sum_y/abs7
!
! TRANSMISSION OF MULTIPLY SCATTERED INTENSITIES
!
  sum_x = 0.
  DO nd=1,nbdirs
    sum_x_fwv(nd) = 0.D0
  END DO
  DO j=1,number/2
    x = xm + xr*points(j)
    IF (x .GE. 0.) THEN
      abs8 = x
    ELSE
      abs8 = -x
    END IF
    DO nd=1,nbdirs
      sum_x_fwv(nd) = sum_x_fwv(nd) + weights(j)*abs8*xr*xif_fwv(nd, 21&
&       , j)
    END DO
    sum_x = sum_x + xif(21, j)*weights(j)*abs8*xr
  END DO
  IF (xmus .GE. 0.) THEN
    abs9 = xmus
  ELSE
    abs9 = -xmus
  END IF
  DO nd=1,nbdirs
    trans_m_fwv(nd) = sum_x_fwv(nd)/abs9
  END DO
  trans_m = sum_x/abs9
!
  sum_x = 0.
  DO j=number/2+1,number
    x = xm + xr*points(j)
    IF (x .GE. 0.) THEN
      abs10 = x
    ELSE
      abs10 = -x
    END IF
    sum_x = sum_x + ximt*weights(j)*abs10*xr
  END DO
  IF (xmus .GE. 0.) THEN
    abs11 = xmus
  ELSE
    abs11 = -xmus
  END IF
  trans_in_m = sum_x/abs11
  IF (xmus .GE. 0.) THEN
    abs12 = xmus
  ELSE
    abs12 = -xmus
  END IF
  IF (xmus .GE. 0.) THEN
    abs16 = xmus
  ELSE
    abs16 = -xmus
  END IF
  pwr1 = 0.01**abs12
  x_lambda_0 = pwr1/gs*abs16/gs
  arg1 = lai/x_lambda_0
  m0 = INT(arg1)
  IF (xmus .GE. 0.) THEN
    abs13 = xmus
  ELSE
    abs13 = -xmus
  END IF
  pwx1 = 1. - x_lambda_0*gs/abs13
  xt_directe = pwx1**m0
  trans_totale = xt_directe + trans_m + trans_1
  DO nd=1,nbdirs
    trans_totale_fwv(nd) = trans_m_fwv(nd)
    fpar_fwv(nd) = rs_fwv(nd)*trans_totale - (1.-rs)*trans_totale_fwv(nd&
&     ) - albedo_sys_fwv(nd)
  END DO
  fpar = 1. - albedo_sys - (1.-rs)*trans_totale
  RETURN
END SUBROUTINE ENERGIE_FWV

!  Differentiation of cost in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: f
!   with respect to varying inputs: x
!   RW status of diff variables: f:out x:in
!***********************************************************
!> \file  cost.f90
!> \brief evaluates total cost function
!> \authors MV/TK, The Inversion Lab
!> \date  January/September 2018
!***********************************************************
!***********************************************************
! SUBROUTINE COST()
!> \brief evaluates total cost function that combines 
!>        terms for observations, model, and prior
!> \authors The Inversion Lab
!> \date  January 2018
SUBROUTINE COST_FWV(n, x, x_fwv, m, f, f_fwv, nbdirs)
  USE MO_RETRIEVAL, ONLY : retr_use_prior_term, retr_use_model_term
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
!< length of control
  INTEGER, INTENT(IN) :: n
!< length of output vector
  INTEGER, INTENT(IN) :: m
!< control vector
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
!< function value
  REAL(kind=8), INTENT(OUT) :: f
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: f_fwv
! local
  REAL(kind=8) :: obsdiff(m), costobs
  REAL(kind=8) :: obsdiff_fwv(nbdirsmax, m), costobs_fwv(nbdirsmax)
  REAL(kind=8) :: priordiff(n), costprior
  REAL(kind=8) :: priordiff_fwv(nbdirsmax, n), costprior_fwv(nbdirsmax)
  REAL(kind=8) :: modeldiff(n), costmodel
  REAL(kind=8) :: modeldiff_fwv(nbdirsmax, n), costmodel_fwv(nbdirsmax)
  LOGICAL :: ldebug
! externals
  EXTERNAL STATE_MODEL, RESIDUAL_PRIOR
  EXTERNAL RESIDUAL_PRIOR_FWV
  INTRINSIC SUM
  REAL(kind=8), DIMENSION(m) :: arg1
  REAL(kind=8), DIMENSION(nbdirsmax, m) :: arg1_fwv
  REAL(kind=8), DIMENSION(n) :: arg10
  REAL(kind=8), DIMENSION(nbdirsmax, n) :: arg10_fwv
  INTEGER :: nd
  INTEGER :: nbdirs
!-- set flags
  ldebug = .false.
!-- compute misfit
  CALL MISFIT_FWV(n, x, x_fwv, m, obsdiff, obsdiff_fwv, nbdirs)
  DO nd=1,nbdirs
    arg1_fwv(nd, :) = 2*obsdiff*obsdiff_fwv(nd, :)
    costobs_fwv(nd) = 0.5_8*SUM(arg1_fwv(nd, :))
  END DO
  arg1(:) = obsdiff**2
  costobs = 0.5_8*SUM(arg1(:))
  IF (ldebug) WRITE(*, '(a,e25.16)') ' DIAG::cost_fwv:cost_obs=  ', costobs
!-- compute state model differences
  IF (retr_use_model_term) THEN
    CALL H_M_FWV(n, x, x_fwv, modeldiff, modeldiff_fwv, nbdirs)
    DO nd=1,nbdirs
      arg10_fwv(nd, :) = 2*modeldiff*modeldiff_fwv(nd, :)
      costmodel_fwv(nd) = 0.5_8*SUM(arg10_fwv(nd, :))
    END DO
    arg10(:) = modeldiff**2
    costmodel = 0.5_8*SUM(arg10(:))
  ELSE
    costmodel = 0._8
    DO nd=1,nbdirs
      costmodel_fwv(nd) = 0.0_8
    END DO
  END IF
  IF (ldebug) WRITE(*, '(a,e25.16)') ' DIAG::cost_fwv:cost_model=', &
&             costmodel
!-- compute prior diff
  IF (retr_use_prior_term) THEN
    CALL RESIDUAL_PRIOR_FWV(n, x, x_fwv, priordiff, priordiff_fwv, &
&                     nbdirs)
    DO nd=1,nbdirs
      arg10_fwv(nd, :) = 2*priordiff*priordiff_fwv(nd, :)
      costprior_fwv(nd) = 0.5_8*SUM(arg10_fwv(nd, :))
    END DO
    arg10(:) = priordiff**2
    costprior = 0.5_8*SUM(arg10(:))
  ELSE
    costprior = 0._8
    DO nd=1,nbdirs
      costprior_fwv(nd) = 0.0_8
    END DO
  END IF
  IF (ldebug) WRITE(*, '(a,e25.16)') ' DIAG::cost_fwv:cost_prior=', &
&             costprior
  DO nd=1,nbdirs
!-- sum-up total cost value
    f_fwv(nd) = costobs_fwv(nd) + costmodel_fwv(nd) + costprior_fwv(nd)
  END DO
  f = costobs + costmodel + costprior
END SUBROUTINE COST_FWV

!  Differentiation of h_m in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: statediff
!   with respect to varying inputs: x
!***********************************************************
!     H_m
!
!> @brief implements Eq. (1.2) in the prototype tool description, the model 'M'determines overall size of control vector (n) and 
!overall size of
!         simulation vector (m)
!         In addition necessary initialisations to actually run the observational operator(s)
!         are performed.
!
!> @param[in]  n  overall (1D-)length of control vector
!> @param[in]  x  overall (1D) control vector (normlalised)
!> @param[out] statediff differences between control vector and the mapped control vector
!
SUBROUTINE H_M_FWV(n, x, x_fwv, statediff, statediff_fwv, nbdirs)
  USE MO_SENSIMUL, ONLY : get_n, get_ns, get_np
  USE MO_MODEL
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
!iLab::AD-Problem
! statediff(np+1:np+ns) = (xm(np+1:np+ns)-x(np+1:np+ns))/unc_model(1:ns)
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: statediff(n)
  REAL(kind=8), INTENT(OUT) :: statediff_fwv(nbdirsmax, n)
! local decls
  INTEGER :: nc, ns, np
  REAL(kind=8) :: xm(n), xphys(n)
  REAL(kind=8) :: xm_fwv(nbdirsmax, n), xphys_fwv(nbdirsmax, n)
  INTEGER :: i, j
  INTEGER :: nd
  INTEGER :: nbdirs
!-- #control vector
  nc = GET_N()
!-- number of states
  ns = GET_NS()
!-- number of parameter, first element of state-vector starts at np+1
  np = GET_NP()
!-- dimensional consistency
  IF (n .NE. nc) THEN
    WRITE(*, '(a(2a,i3,1x))') ' FATAL::H_m:'//&
&   'inconsistent dimension of state vector:', 'expected=', nc, 'got=', &
&   n
    STOP
  ELSE
!-- parameter do not contribute here
    statediff(1:np) = 0._8
!these are *not* used below
    xm(1:np) = 0._8
!-- control vector in physical units
    CALL X2P_FWV(n, x, x_fwv, xphys, xphys_fwv, nbdirs)
    DO nd=1,nbdirs
      xm_fwv(nd, :) = 0.0_8
    END DO
!-- xm = A*xs + b
    DO i=1,ns
      DO nd=1,nbdirs
        xm_fwv(nd, np+i) = 0.0_8
      END DO
      xm(np+i) = offset_model(i)
      DO j=1,ns
        DO nd=1,nbdirs
          xm_fwv(nd, np+i) = xm_fwv(nd, np+i) + mat_model(i, j)*&
&           xphys_fwv(nd, np+j)
        END DO
        xm(np+i) = xm(np+i) + mat_model(i, j)*xphys(np+j)
      END DO
    END DO
    DO nd=1,nbdirs
      statediff_fwv(nd, :) = 0.0_8
    END DO
!--
    DO i=1,ns
      DO nd=1,nbdirs
        statediff_fwv(nd, np+i) = (xm_fwv(nd, np+i)-xphys_fwv(nd, np+i))&
&         /unc_model(i)
      END DO
      statediff(np+i) = (xm(np+i)-xphys(np+i))/unc_model(i)
    END DO
  END IF
END SUBROUTINE H_M_FWV

!  Differentiation of misfit in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: obsdiff
!   with respect to varying inputs: x
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file misfit.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: computation of misfit between observations and simulated equivalents
!
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!
!> \date  April 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     misfit
!
!> @brief determines the misfit vector between observations and simulated
!         observation equivalents
!
!> @details TBD
!
!> @param[in]  n       overall (1D) length of control vector
!> @param[in]  x       complete (normalised) control vector
!> @param[in]  m       overall (1D) dimension of misfit vector
!                      (must equal dimension of simulation vector)
!> @param[out] obsdiff misfit vector
!
SUBROUTINE MISFIT_FWV(n, x, x_fwv, m, obsdiff, obsdiff_fwv, nbdirs)
  USE MO_SENSIMUL, ONLY : get_m_s1, get_m_s2, sim_fill_value
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: obsdiff(m)
  REAL(kind=8), INTENT(OUT) :: obsdiff_fwv(nbdirsmax, m)
! local
  REAL(kind=8) :: y(m), yobs(m), syobs(m)
  REAL(kind=8) :: y_fwv(nbdirsmax, m)
  LOGICAL :: succeed
  INTEGER :: nobs_s1, nobs_s2
  INTEGER :: m_s1, m_s2
  INTEGER :: i
! externals
  EXTERNAL SIMULATE_S1S2, GETOBS
  EXTERNAL SIMULATE_S1S2_FWV
  INTEGER :: nd
  INTEGER :: nbdirs
  obsdiff(1:m) = 0._8
!-- read obs
  CALL GETOBS(m, yobs, syobs, nobs_s1, nobs_s2, succeed)
  IF (.NOT.succeed) THEN
    WRITE(*, '(a)') ' FATAL::misfit:getobs failed, cannot continue.'
    STOP
  ELSE
!-- run S1+S2 simulation
    CALL SIMULATE_S1S2_FWV(n, x, x_fwv, m, y, y_fwv, nbdirs)
    m_s1 = GET_M_S1()
    m_s2 = GET_M_S2()
    IF (nobs_s1 .GT. 0) THEN
      DO nd=1,nbdirs
        obsdiff_fwv(nd, :) = 0.0_8
      END DO
      DO i=1,m_s1
        IF (yobs(i) .NE. sim_fill_value .AND. y(i) .NE. sim_fill_value) &
&       THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
! TAPENADE: (TC19) Equality test on reals is not reliable
          DO nd=1,nbdirs
            obsdiff_fwv(nd, i) = y_fwv(nd, i)/syobs(i)
          END DO
          obsdiff(i) = (y(i)-yobs(i))/syobs(i)
        END IF
      END DO
    ELSE
      DO nd=1,nbdirs
        obsdiff_fwv(nd, :) = 0.0_8
      END DO
    END IF
    IF (nobs_s2 .GT. 0) THEN
      DO i=m_s1+1,m_s1+m_s2
        IF (yobs(i) .NE. sim_fill_value .AND. y(i) .NE. sim_fill_value) &
&       THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
! TAPENADE: (TC19) Equality test on reals is not reliable
          DO nd=1,nbdirs
            obsdiff_fwv(nd, i) = y_fwv(nd, i)/syobs(i)
          END DO
          obsdiff(i) = (y(i)-yobs(i))/syobs(i)
        END IF
      END DO
    END IF
  END IF
END SUBROUTINE MISFIT_FWV

!  Differentiation of simulate_s1s2 in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional)
!:
!   variations   of useful results: y
!   with respect to varying inputs: x
!***********************************************************
!     simulate_s1s2
!
!> @brief Implementation of the combined S1 and S2 observation operator.
!>        Computes backscatter values (VH,VV) and top-of-canopy BRFs in 13 Sentinel2 bands
!>        for the respective states in the control vector.
!
!
!> @param[in]   n  length of control vector for multiple simulations in MW and optical domain
!> @param[in]   x  control vector normalised by prior uncertainty
!                  (expected ordering is: S1 related parameter(s) followed by
!                   by state variables LAI,HC,SM per 'simulation point')
!> @param[in]   m  length of output vector
!> @param[out]  y  simulated backscatter values (VH,VV) and simulated TOC BRFs
!                  (for all 13 S2 wave-bands)
!                  (Ordering is: simulated backscatter values per 'simulation point'
!                                followed by BRF values per 'simulation point')
!
SUBROUTINE SIMULATE_S1S2_FWV(n, x, x_fwv, m, y, y_fwv, nbdirs)
  USE MO_SENSIMUL, ONLY : get_nc_s1, get_nc_s2, get_m_s1, get_m_s2, &
& get_n, get_m
  USE MO_SENSIMUL, ONLY : sim_fill_value
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: y(m)
  REAL(kind=8), INTENT(OUT) :: y_fwv(nbdirsmax, m)
! local decls
  REAL(kind=8) :: xp_s1(GET_NC_S1()), xp_s2(GET_NC_S2())
  REAL(kind=8) :: xp_s1_fwv(nbdirsmax, GET_NC_S1()), xp_s2_fwv(nbdirsmax&
& , GET_NC_S2())
  INTEGER :: n_s1, n_s2, m_s1, m_s2
  REAL(kind=8) :: xphys(n)
  REAL(kind=8) :: xphys_fwv(nbdirsmax, n)
  INTEGER :: nd
  INTEGER :: nbdirs
!-- dimension consistency
  IF (n .NE. GET_N()) THEN
    WRITE(*, '(a,2(a,i3,1x))') &
&   ' FATAL::simulate_s1s2:inconsistent length of state vector!', &
&   'expected=', GET_N(), 'got=', n
    STOP
  ELSE IF (m .NE. GET_M()) THEN
    WRITE(*, '(a,2(a,i3,1x))') &
&   ' FATAL::simulate_s1s2:inconsistent length of simulation vector.', &
&   'expected=', GET_M(), 'got=', m
    STOP
  ELSE
!-- initialise output
    y = sim_fill_value
!-- convert normalised to physical control vector
    CALL X2P_FWV(n, x, x_fwv, xphys, xphys_fwv, nbdirs)
!-- extract specific control vectors
    n_s1 = GET_NC_S1()
    n_s2 = GET_NC_S2()
    m_s1 = GET_M_S1()
    m_s2 = GET_M_S2()
    CALL CONTROL_VECTOR_SPLIT_FWV(n, xphys, xphys_fwv, n_s1, xp_s1, &
&                           xp_s1_fwv, n_s2, xp_s2, xp_s2_fwv, nbdirs)
!-- S1 simulation
    IF (n_s1 .GT. 0) THEN
      CALL SIMULATE_S1_FWV(n_s1, xp_s1, xp_s1_fwv, m_s1, y(1:m_s1), &
&                    y_fwv(:, 1:m_s1), nbdirs)
    ELSE
      DO nd=1,nbdirs
        y_fwv(nd, :) = 0.0_8
      END DO
    END IF
!-- S2 simulation
    IF (n_s2 .GT. 0) CALL SIMULATE_S2_FWV(n_s2, xp_s2, xp_s2_fwv, m_s2, &
&                                   y(m_s1+1:m_s1+m_s2), y_fwv(:, m_s1+1&
&                                   :m_s1+m_s2), nbdirs)
  END IF
END SUBROUTINE SIMULATE_S1S2_FWV

!  Differentiation of simulate_s1 in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: y
!   with respect to varying inputs: x
!***********************************************************
!     simulate_s1
!
!> @brief Implementation of S1 simulation.
!>        Backscatter values in VH and VV polarisation will be computed for the
!>        given control vector.
!
!> @details This routine provides the implementation of the observation operator H_1
!>          as denoted in Figure 1.2 in document D5v1.
!
!> @param[in]   n  length of control-vector for multiple simulations in the MW domain
!> @param[in]   x  S1 relevant part of full control vector in physical units
!                  (expected ordering is: S1 related parameter(s) followed by
!                   by state-variables LAI,HC,SM per state)
!> @param[in]   m  length of output vector
!> @param[out]  y  simulated backscatter values (VH,VV) per state
!
SUBROUTINE SIMULATE_S1_FWV(n, x, x_fwv, m, y, y_fwv, nbdirs)
  USE MO_SENSIMUL, ONLY : nparam_s1, nsc, npts_s1, nparam_s1, get_nc_s1,&
& get_m_s1
  USE MO_SENSIMUL, ONLY : iv_geom, timept_idxs_s1
!VH,VV
  USE MO_SENSIMUL_S1, ONLY : npol
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: y(m)
  REAL(kind=8), INTENT(OUT) :: y_fwv(nbdirsmax, m)
! externals
  EXTERNAL SIMULATE_S1_1GEOM
  EXTERNAL SIMULATE_S1_1GEOM_FWV
! local decls
  INTEGER :: ipt, ipt_s1
  INTEGER :: i0, i1, j0, j1
  REAL(kind=8) :: statev(nparam_s1+nsc)
  REAL(kind=8) :: statev_fwv(nbdirsmax, nparam_s1+nsc)
  REAL(kind=8) :: single_ivgeom(4)
  INTEGER :: nd
  INTEGER :: nbdirs
!-- dimension consistency
  IF (n .NE. GET_NC_S1()) THEN
    WRITE(*, '(a,2(a,i3,1x))') &
&   ' FATAL::simulate_s1:inconsistent length of state vector.', &
&   'expected=', GET_NC_S1(), 'got=', n
    STOP
  ELSE
    IF (m .NE. GET_M_S1()) WRITE(*, '(a,2(a,i3,1x))') &
&            ' FATAL::simulate_s1:inconsistent length of result vector.'&
&                          , 'expected=', GET_M_S1(), 'got=', m
    DO nd=1,nbdirs
!-- map S1 *parameter part* into model input vector
!   NOTE: S1 parameter is part of control vector
      statev_fwv(nd, :) = 0.0_8
      statev_fwv(nd, 1:nparam_s1) = x_fwv(nd, 1:nparam_s1)
    END DO
    statev(1:nparam_s1) = x(1:nparam_s1)
!-- loop over time-points
!-- initial position in 'x' vector
    i0 = nparam_s1 + 1
!-- initial position in 'y' vector
    j0 = 1
    DO nd=1,nbdirs
      y_fwv(nd, :) = 0.0_8
    END DO
simloop:DO ipt=1,npts_s1
      i1 = i0 + nsc - 1
      j1 = j0 + npol - 1
      DO nd=1,nbdirs
        statev_fwv(nd, nparam_s1+1:nparam_s1+nsc) = x_fwv(nd, i0:i1)
      END DO
      statev(nparam_s1+1:nparam_s1+nsc) = x(i0:i1)
      ipt_s1 = timept_idxs_s1(ipt)
      single_ivgeom(1:4) = iv_geom(1:4, ipt_s1)
      CALL SIMULATE_S1_1GEOM_FWV(statev, statev_fwv, single_ivgeom, y(j0&
&                          :j1), y_fwv(:, j0:j1), nbdirs)
!-- increment start position
      i0 = i1 + 1
      j0 = j1 + 1
    END DO simloop
  END IF
END SUBROUTINE SIMULATE_S1_FWV

!  Differentiation of simulate_s1_1geom in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectio
!nal):
!   variations   of useful results: bscat
!   with respect to varying inputs: statev bscat
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file simulate.f90
!> \brief provides implementation of the observation operators in the
!>              optical and microwave domain.mapping of 1D control vector to physical variables
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  April 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     simulate_s1_1geom
!
!> @brief Implementation of the Sentinel Synergy Study observation operator
!>        in the microwave domain (denoted H_1 in document D5) for a single state.
!
!> @details For the given input state (LAI_coeff, LAI,HC, and SM) the observation operator
!>          derives backscatter values in VH and VV polarisation.
!>          The implementation is based on the Fortran port of the SENSE model.
!
!> @param[in]   statev   state components (physical units) required to run S1 simulation
!>                       consisting of LAI conversion coefficient, (optical) LAI, HC, and SM
!> @param[out]  bscat    back-scatter values in VH/VV polarisation
!
SUBROUTINE SIMULATE_S1_1GEOM_FWV(statev, statev_fwv, iv_geom, bscat, &
& bscat_fwv, nbdirs)
  USE MO_SENSIMUL, ONLY : nsc, nparam_s1
!-- viewing zenith-angle for microwave simulation
  USE MO_SENSIMUL_S1, ONLY : theta, pi
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: statev(nparam_s1+nsc)
  REAL(kind=8), INTENT(IN) :: statev_fwv(nbdirsmax, nparam_s1+nsc)
!sza,saa,vza,vaa
  REAL(kind=8), INTENT(IN) :: iv_geom(4)
!VH,VV
  REAL(kind=8), INTENT(OUT) :: bscat(2)
  REAL(kind=8), INTENT(OUT) :: bscat_fwv(nbdirsmax, 2)
! externals
!core SENSE routine
  EXTERNAL SIGMA0_VHVV
  EXTERNAL SIGMA0_VHVV_FWV
! local declarations
  REAL(kind=8) :: lai_coeff, lai, hc, sm
  REAL(kind=8), DIMENSION(nbdirsmax) :: lai_coeff_fwv, lai_fwv, hc_fwv, &
& sm_fwv
  REAL(kind=8) :: s0vh, s0vv
  REAL(kind=8), DIMENSION(nbdirsmax) :: s0vh_fwv, s0vv_fwv
!-- S1 viewing zenith angle
  REAL(kind=8) :: vza_deg
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
!-- map state variables
    lai_coeff_fwv(nd) = statev_fwv(nd, 1)
    lai_fwv(nd) = statev_fwv(nd, 2)
    hc_fwv(nd) = statev_fwv(nd, 3)
    sm_fwv(nd) = statev_fwv(nd, 4)
  END DO
  lai_coeff = statev(1)
  lai = statev(2)
  hc = statev(3)
  sm = statev(4)
!--
  vza_deg = iv_geom(3)
!-- convert to RAD
  theta = vza_deg*(pi/180._8)
!-- call SENSE core routine
  CALL SIGMA0_VHVV_FWV(lai, lai_fwv, lai_coeff, lai_coeff_fwv, hc, &
&                hc_fwv, sm, sm_fwv, s0vh, s0vh_fwv, s0vv, s0vv_fwv, &
&                nbdirs)
  DO nd=1,nbdirs
!-- map backscatter values
    bscat_fwv(nd, 1) = s0vh_fwv(nd)
    bscat_fwv(nd, 2) = s0vv_fwv(nd)
  END DO
  bscat(1) = s0vh
  bscat(2) = s0vv
END SUBROUTINE SIMULATE_S1_1GEOM_FWV

!  Differentiation of sigma0_vhvv in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: s0vh s0vv
!   with respect to varying inputs: lai lai_coeff canht mv
!***********************************************************
!     sigma0_vhvv
!
!> @brief compute total single-scattering backscattering coefficents for VH and VV polarisations
!
!> @details 
!
!> @param[in]  lai        leaf-area index [m2/m2] as used in optical domain
!> @param[in]  lai_coeff  conversion coefficient for lai optical to microwave
!> @param[in]  canht      canopy height [m]
!> @param[in]  mv         volumetric soilmoisture [m3/m3]
!> @param[out] s0vh       backscattering coefficient, VH polarisation
!> @param[out] s0vv       backscattering coefficient, VV polarisation
!
SUBROUTINE SIGMA0_VHVV_FWV(lai, lai_fwv, lai_coeff, lai_coeff_fwv, canht&
& , canht_fwv, mv, mv_fwv, s0vh, s0vh_fwv, s0vv, s0vv_fwv, nbdirs)
  USE MO_SENSIMUL_S1
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: lai, lai_coeff, canht, mv
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: lai_fwv, &
& lai_coeff_fwv, canht_fwv, mv_fwv
  REAL(kind=8), INTENT(OUT) :: s0vh, s0vv
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: s0vh_fwv, s0vv_fwv
! externals
  EXTERNAL DOBSON85_EPS
  EXTERNAL DOBSON85_EPS_FWV
  EXTERNAL REFLECTIVITY, CALC_RHO
  EXTERNAL REFLECTIVITY_FWV, CALC_RHO_FWV
  EXTERNAL CANOPY_EXTINCTION_COEFFS, CANOPY_TRANSMISSIVITY
  EXTERNAL CANOPY_EXTINCTION_COEFFS_FWV, CANOPY_TRANSMISSIVITY_FWV
  EXTERNAL SCATRAYLEIGH_SIGMA_V_BACK, SCATRAYLEIGH_SIGMA_V_BISTATIC
  EXTERNAL SCATRAYLEIGH_SIGMA_V_BACK_FWV, &
&     SCATRAYLEIGH_SIGMA_V_BISTATIC_FWV
  EXTERNAL OH92_BACKSCATTER
  EXTERNAL OH92_BACKSCATTER_FWV
  EXTERNAL CANOPY_SIGMA_C, GROUND_SIGMA, SIGMA_CG, SIGMA_GCG
  EXTERNAL CANOPY_SIGMA_C_FWV, GROUND_SIGMA_FWV, SIGMA_CG_FWV, &
&     SIGMA_GCG_FWV
! local declarations
  COMPLEX(kind=8) :: eps
  COMPLEX(kind=8), DIMENSION(nbdirsmax) :: eps_fwv
  REAL(kind=8) :: v, h, rho_v, rho_h, t_v, t_h, ke_v, ke_h, ks_h, ks_v
  REAL(kind=8), DIMENSION(nbdirsmax) :: v_fwv, h_fwv, rho_v_fwv, &
& rho_h_fwv, t_v_fwv, t_h_fwv, ke_v_fwv, ke_h_fwv, ks_h_fwv, ks_v_fwv
  REAL(kind=8) :: lai_mw
  REAL(kind=8), DIMENSION(nbdirsmax) :: lai_mw_fwv
!hh,vv,hv
  REAL(kind=8) :: soil_backscatter(3)
  REAL(kind=8) :: soil_backscatter_fwv(nbdirsmax, 3)
!hh,vv,hv
  REAL(kind=8) :: sigma_vol_bistatic(3), sigma_vol_back(3)
  REAL(kind=8) :: sigma_vol_bistatic_fwv(nbdirsmax, 3), &
& sigma_vol_back_fwv(nbdirsmax, 3)
!hh,vv,hv
  REAL(kind=8) :: s0c(3), s0g(3), s0cgt(3), s0gcg(3)
  REAL(kind=8) :: s0c_fwv(nbdirsmax, 3), s0g_fwv(nbdirsmax, 3), &
& s0cgt_fwv(nbdirsmax, 3), s0gcg_fwv(nbdirsmax, 3)
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
!-- microwave LAI
    lai_mw_fwv(nd) = lai_fwv(nd)*lai_coeff + lai*lai_coeff_fwv(nd)
  END DO
  lai_mw = lai*lai_coeff
!-- soil-moisture ==> eps (dielectric permittivity)
  CALL DOBSON85_EPS_FWV(mv, mv_fwv, bulk, alpha, beta1, beta2, ew, eps, &
&                 eps_fwv, nbdirs)
!-- reflectivity
  CALL REFLECTIVITY_FWV(theta, eps, eps_fwv, v, v_fwv, h, h_fwv, nbdirs)
!-- coherent p-polarized reflectivity
  CALL CALC_RHO_FWV(theta, ks, v, v_fwv, h, h_fwv, rho_v, rho_v_fwv, &
&             rho_h, rho_h_fwv, nbdirs)
!-- extinction coefficients
  CALL CANOPY_EXTINCTION_COEFFS_FWV(omega, lai_mw, lai_mw_fwv, ke_v, &
&                             ke_v_fwv, ke_h, ke_h_fwv, ks_v, ks_v_fwv, &
&                             ks_h, ks_h_fwv, nbdirs)
!-- canopy transmissivity
  CALL CANOPY_TRANSMISSIVITY_FWV(ke_v, ke_v_fwv, ke_h, ke_h_fwv, canht, &
&                          canht_fwv, theta, t_v, t_v_fwv, t_h, t_h_fwv&
&                          , nbdirs)
!-- canopy contribution
!-- (Ulaby, eq. 11.22)
  CALL SCATRAYLEIGH_SIGMA_V_BACK_FWV(ks_v, ks_v_fwv, ks_h, ks_h_fwv, &
&                              sigma_vol_back, sigma_vol_back_fwv, &
&                              nbdirs)
  CALL CANOPY_SIGMA_C_FWV(sigma_vol_back, sigma_vol_back_fwv, theta, &
&                   ke_v, ke_v_fwv, ke_h, ke_h_fwv, t_v, t_v_fwv, t_h, &
&                   t_h_fwv, s0c, s0c_fwv, nbdirs)
!-- ground contribution
  CALL OH92_BACKSCATTER_FWV(eps, eps_fwv, ks, theta, soil_backscatter, &
&                     soil_backscatter_fwv, nbdirs)
  CALL GROUND_SIGMA_FWV(soil_backscatter, soil_backscatter_fwv, t_v, &
&                 t_v_fwv, t_h, t_h_fwv, s0g, s0g_fwv, nbdirs)
!-- total canopy-ground
  CALL SCATRAYLEIGH_SIGMA_V_BISTATIC_FWV(ks_v, ks_v_fwv, ks_h, ks_h_fwv&
&                                  , sigma_vol_bistatic, &
&                                  sigma_vol_bistatic_fwv, nbdirs)
  CALL SIGMA_CG_FWV(sigma_vol_bistatic, sigma_vol_bistatic_fwv, canht, &
&             canht_fwv, coherent, rho_v, rho_v_fwv, rho_h, rho_h_fwv, &
&             t_v, t_v_fwv, t_h, t_h_fwv, s0cgt, s0cgt_fwv, nbdirs)
!-- ground-canopy-ground
  CALL SIGMA_GCG_FWV(sigma_vol_back, sigma_vol_back_fwv, theta, rho_v, &
&              rho_v_fwv, rho_h, rho_h_fwv, t_v, t_v_fwv, t_h, t_h_fwv, &
&              ke_v, ke_v_fwv, ke_h, ke_h_fwv, s0gcg, s0gcg_fwv, nbdirs)
  DO nd=1,nbdirs
!-- sum-up contributions
!-- for S1 we have sender=receiver, thus VH equals HV (reciprocal theorem)
    s0vv_fwv(nd) = s0c_fwv(nd, 2) + s0g_fwv(nd, 2) + s0cgt_fwv(nd, 2) + &
&     s0gcg_fwv(nd, 2)
  END DO
  s0vv = s0c(2) + s0g(2) + s0cgt(2) + s0gcg(2)
  s0vh = 0._8
  IF (s0c(3) .NE. sense_fv) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
    DO nd=1,nbdirs
      s0vh_fwv(nd) = s0c_fwv(nd, 3)
    END DO
    s0vh = s0vh + s0c(3)
  ELSE
    DO nd=1,nbdirs
      s0vh_fwv(nd) = 0.0_8
    END DO
  END IF
  IF (s0g(3) .NE. sense_fv) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
    DO nd=1,nbdirs
      s0vh_fwv(nd) = s0vh_fwv(nd) + s0g_fwv(nd, 3)
    END DO
    s0vh = s0vh + s0g(3)
  END IF
  IF (s0cgt(3) .NE. sense_fv) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
    DO nd=1,nbdirs
      s0vh_fwv(nd) = s0vh_fwv(nd) + s0cgt_fwv(nd, 3)
    END DO
    s0vh = s0vh + s0cgt(3)
  END IF
  IF (s0gcg(3) .NE. sense_fv) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
    DO nd=1,nbdirs
      s0vh_fwv(nd) = s0vh_fwv(nd) + s0gcg_fwv(nd, 3)
    END DO
    s0vh = s0vh + s0gcg(3)
  END IF
END SUBROUTINE SIGMA0_VHVV_FWV

!  Differentiation of canopy_extinction_coeffs in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiD
!irectional):
!   variations   of useful results: ks_h ks_v ke_h ke_v
!   with respect to varying inputs: lai_mw
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file canopy.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of canopy class ported from Sentinel Simulator (sense/canopy.py)
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     canopy_extinction_coeffs
!
!> @brief compute extinction coefficients from LAI (microwave) and single-scattering albedo
!
!> @param[in]  omega   single scattering albedo
!> @param[in]  lai_mw  Leaf-Area Index (MW-compliant)
!> @param[out] ke_h
!> @param[out] ke_v
!> @param[out] ks_h
!> @param[out] ks_v
!
! Ref: sense/canopy.py, l21 ff.
!      simulator.py, l100 ff.
!
SUBROUTINE CANOPY_EXTINCTION_COEFFS_FWV(omega, lai_mw, lai_mw_fwv, ke_v&
& , ke_v_fwv, ke_h, ke_h_fwv, ks_v, ks_v_fwv, ks_h, ks_h_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: omega, lai_mw
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: lai_mw_fwv
  REAL(kind=8), INTENT(OUT) :: ke_h, ke_v, ks_h, ks_v
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: ke_h_fwv, ke_v_fwv&
& , ks_h_fwv, ks_v_fwv
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
    ke_h_fwv(nd) = lai_mw_fwv(nd)
    ke_v_fwv(nd) = lai_mw_fwv(nd)
    ks_h_fwv(nd) = omega*lai_mw_fwv(nd)
    ks_v_fwv(nd) = omega*lai_mw_fwv(nd)
  END DO
  ke_h = lai_mw
  ke_v = lai_mw
  ks_h = omega*lai_mw
  ks_v = omega*lai_mw
END SUBROUTINE CANOPY_EXTINCTION_COEFFS_FWV

!  Differentiation of canopy_transmissivity in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDire
!ctional):
!   variations   of useful results: t_h t_v
!   with respect to varying inputs: d ke_h ke_v
!***********************************************************
!     canopy_transmissivity
!
!> @brief compute canopy transmissivity
!
!> @param[in] ke_h  volume extinction coefficient (hor. pol) [Np/m]
!> @param[in] ke_v  volume extinction coefficient (ver. pol) [Np/m]
!> @param[in] d     height of canopy layer
!> @param[in] theta incidence angle
!> @param[out] t_h  transmissivity, h-polarised
!> @param[out] t_v  transmissivity, v-polarised
!
! Ref: sense/canopy.py, l299 ff.
!      sense/canopy.py, l356 ff
!
SUBROUTINE CANOPY_TRANSMISSIVITY_FWV(ke_v, ke_v_fwv, ke_h, ke_h_fwv, d, &
& d_fwv, theta, t_v, t_v_fwv, t_h, t_h_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: ke_h, ke_v, d, theta
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: ke_h_fwv, ke_v_fwv, &
& d_fwv
  REAL(kind=8), INTENT(OUT) :: t_h, t_v
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: t_h_fwv, t_v_fwv
! local decls
  REAL(kind=8) :: tau_h, tau_v
  REAL(kind=8), DIMENSION(nbdirsmax) :: tau_h_fwv, tau_v_fwv
  INTRINSIC EXP
  INTEGER :: nd
  INTEGER :: nbdirs
  CALL TAU_FCT_FWV0(ke_h, ke_h_fwv, tau_h, tau_h_fwv, nbdirs)
  CALL TAU_FCT_FWV0(ke_v, ke_v_fwv, tau_v, tau_v_fwv, nbdirs)
  DO nd=1,nbdirs
    t_h_fwv(nd) = -(tau_h_fwv(nd)*EXP(-tau_h))
    t_v_fwv(nd) = -(tau_v_fwv(nd)*EXP(-tau_v))
  END DO
  t_h = EXP(-tau_h)
  t_v = EXP(-tau_v)

CONTAINS
!  Differentiation of tau_fct in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: tau_fct
!   with respect to varying inputs: d k
!assumption: extinction is isotropic
  SUBROUTINE TAU_FCT_FWV0(k, k_fwv, tau_fct, tau_fct_fwv, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: k
    REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: k_fwv
    INTRINSIC COS
    INTEGER :: nd
    REAL(kind=8) :: tau_fct
    REAL(kind=8) :: tau_fct_fwv(nbdirsmax)
    INTEGER :: nbdirs
    DO nd=1,nbdirs
      tau_fct_fwv(nd) = (k_fwv(nd)*d+k*d_fwv(nd))/COS(theta)
    END DO
    tau_fct = k*d/COS(theta)
  END SUBROUTINE TAU_FCT_FWV0
!assumption: extinction is isotropic
  REAL(kind=8) FUNCTION TAU_FCT(k)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: k
    INTRINSIC COS
    tau_fct = k*d/COS(theta)
  END FUNCTION TAU_FCT
END SUBROUTINE CANOPY_TRANSMISSIVITY_FWV

!  Differentiation of canopy_sigma_c in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional
!):
!   variations   of useful results: s0c
!   with respect to varying inputs: t_h sigma_vol_back t_v ke_h
!                ke_v
!***********************************************************
!     canopy_transmissivity
!
!> @brief calculate canopy volume contribution only (Eq. 11.10 + 11.16 as seen in 11.17, Ulaby (2014))
!
! Ref: sense/model.py, l372 ff.
!
SUBROUTINE CANOPY_SIGMA_C_FWV(sigma_vol_back, sigma_vol_back_fwv, theta&
& , ke_v, ke_v_fwv, ke_h, ke_h_fwv, t_v, t_v_fwv, t_h, t_h_fwv, s0c, &
& s0c_fwv, nbdirs)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
!hh,vv,hv
  REAL(kind=8), INTENT(IN) :: sigma_vol_back(3)
  REAL(kind=8), INTENT(IN) :: sigma_vol_back_fwv(nbdirsmax, 3)
  REAL(kind=8), INTENT(IN) :: theta, ke_v, ke_h, t_v, t_h
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: ke_v_fwv, ke_h_fwv, &
& t_v_fwv, t_h_fwv
  REAL(kind=8), INTENT(OUT) :: s0c(3)
  REAL(kind=8), INTENT(OUT) :: s0c_fwv(nbdirsmax, 3)
  INTRINSIC COS
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
!-- HH
    s0c_fwv(nd, :) = 0.0_8
    s0c_fwv(nd, 1) = (COS(theta)*((-(t_h_fwv(nd)*t_h)-t_h*t_h_fwv(nd))*&
&     sigma_vol_back(1)+(1._8-t_h*t_h)*sigma_vol_back_fwv(nd, 1))*(ke_h+&
&     ke_h)-(1._8-t_h*t_h)*sigma_vol_back(1)*COS(theta)*2*ke_h_fwv(nd))/&
&     (ke_h+ke_h)**2
!-- VV
    s0c_fwv(nd, 2) = (COS(theta)*((-(t_v_fwv(nd)*t_v)-t_v*t_v_fwv(nd))*&
&     sigma_vol_back(2)+(1._8-t_v*t_v)*sigma_vol_back_fwv(nd, 2))*(ke_v+&
&     ke_v)-(1._8-t_v*t_v)*sigma_vol_back(2)*COS(theta)*2*ke_v_fwv(nd))/&
&     (ke_v+ke_v)**2
  END DO
  s0c(1) = (1._8-t_h*t_h)*(sigma_vol_back(1)*COS(theta))/(ke_h+ke_h)
  s0c(2) = (1._8-t_v*t_v)*(sigma_vol_back(2)*COS(theta))/(ke_v+ke_v)
  IF (sigma_vol_back(3) .EQ. sense_fv) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
    DO nd=1,nbdirs
      s0c_fwv(nd, 3) = 0.0_8
    END DO
    s0c(3) = sense_fv
  ELSE
    DO nd=1,nbdirs
      s0c_fwv(nd, 3) = (COS(theta)*((-(t_h_fwv(nd)*t_v)-t_h*t_v_fwv(nd))&
&       *sigma_vol_back(3)+(1._8-t_h*t_v)*sigma_vol_back_fwv(nd, 3))*(&
&       ke_h+ke_v)-(1._8-t_h*t_v)*sigma_vol_back(3)*COS(theta)*(ke_h_fwv&
&       (nd)+ke_v_fwv(nd)))/(ke_h+ke_v)**2
    END DO
    s0c(3) = (1._8-t_h*t_v)*(sigma_vol_back(3)*COS(theta))/(ke_h+ke_v)
  END IF
END SUBROUTINE CANOPY_SIGMA_C_FWV

!  Differentiation of dobson85_eps in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: eps
!   with respect to varying inputs: mv
!***********************************************************
!     dobson85_eps
!
!> @brief calculate dielectric permittivity (Eq. 4.66 (Ulaby et al., 2014))
!
!> @param[in]  mv     volumetric soil moisture [m**3/m**3]
!> @param[in]  bulk   bulk density [g/cm**3]
!> @param[in]  alpha  as computed by dobson85_init
!> @param[in]  beta1  as computed by dobson85_init
!> @param[in]  beta2  as computed by dobson85_init
!> @param[in]  ew     dielectric permittivity of free water
!> @param[out] eps    relative dielectric permittivity
!
SUBROUTINE DOBSON85_EPS_FWV(mv, mv_fwv, bulk, alpha, beta1, beta2, ew, &
& eps, eps_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: mv, bulk, alpha, beta1, beta2
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: mv_fwv
  COMPLEX(kind=8), INTENT(IN) :: ew
  COMPLEX(kind=8), INTENT(OUT) :: eps
  COMPLEX(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: eps_fwv
! local variables
  REAL(kind=8) :: e1, e2
  REAL(kind=8), DIMENSION(nbdirsmax) :: e1_fwv, e2_fwv
  INTRINSIC REAL
  INTRINSIC AIMAG
  INTRINSIC CMPLX
  REAL(kind=8) :: pwr1
  REAL(kind=8), DIMENSION(nbdirsmax) :: pwr1_fwv
  REAL :: pwx2
  REAL*8 :: pwr2
  REAL*8 :: pwx3
  REAL*8, DIMENSION(nbdirsmax) :: pwx3_fwv
  REAL*8 :: pwy3
  REAL :: result1
  INTEGER :: nd
  INTEGER :: nbdirs
  pwr1 = mv**beta1
  pwx2 = REAL(ew)
  pwr2 = pwx2**alpha
  pwx3 = 1._8 + 0.66_8*bulk + pwr1*pwr2 - mv
  pwy3 = 1._8/alpha
  result1 = AIMAG(ew)
  DO nd=1,nbdirs
    IF (mv .GT. 0.0_8 .OR. (mv .LT. 0.0_8 .AND. beta1 .EQ. INT(beta1))) &
&   THEN
      pwr1_fwv(nd) = beta1*mv**(beta1-1)*mv_fwv(nd)
    ELSE IF (mv .EQ. 0.0_8 .AND. beta1 .EQ. 1.0) THEN
      pwr1_fwv(nd) = mv_fwv(nd)
    ELSE
      pwr1_fwv(nd) = 0.0_8
    END IF
    pwx3_fwv(nd) = pwr2*pwr1_fwv(nd) - mv_fwv(nd)
    IF (pwx3 .GT. 0.0_8 .OR. (pwx3 .LT. 0.0_8 .AND. pwy3 .EQ. INT(pwy3))&
&   ) THEN
      e1_fwv(nd) = pwy3*pwx3**(pwy3-1)*pwx3_fwv(nd)
    ELSE IF (pwx3 .EQ. 0.0_8 .AND. pwy3 .EQ. 1.0) THEN
      e1_fwv(nd) = pwx3_fwv(nd)
    ELSE
      e1_fwv(nd) = 0.0_8
    END IF
    IF (mv .GT. 0.0_8 .OR. (mv .LT. 0.0_8 .AND. beta2 .EQ. INT(beta2))) &
&   THEN
      pwr1_fwv(nd) = beta2*mv**(beta2-1)*mv_fwv(nd)
    ELSE IF (mv .EQ. 0.0_8 .AND. beta2 .EQ. 1.0) THEN
      pwr1_fwv(nd) = mv_fwv(nd)
    ELSE
      pwr1_fwv(nd) = 0.0_8
    END IF
    e2_fwv(nd) = result1*pwr1_fwv(nd)
    eps_fwv(nd) = CMPLX(e1_fwv(nd), e2_fwv(nd), kind=8)
  END DO
  e1 = pwx3**pwy3
  pwr1 = mv**beta2
  e2 = result1*pwr1
  eps = CMPLX(e1, e2, kind=8)
END SUBROUTINE DOBSON85_EPS_FWV

!  Differentiation of calc_rho in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: rho_h rho_v
!   with respect to varying inputs: h v
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file ground.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of Ground class ported from Sentinel Simulator (sense/model.py)
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     calc_rho
!
!> @brief calculate coherent p-polarized reflectivity  (Ref: Eq. 11.11 (Ulaby, 2014))
!
!---------
! Note that the specular reflectivity is corrected by a roughness term
!         if ks>0.2
!
!         however, a sensitivity analysis showed that even for ks==0.2
!         deviations can be up to 15% for typical incidence angles
!         Only in case that ks << 0.1, the correction can be neglected.
!         We therefore always use the roughness correction factor!
!         TODO: unclear so far how this relates to surface (soil) scattering models
!---------
!
!> @param[in]   theta  incidence angle [rad]
!> @param[in]   ks     (surface) roughness parameter
!> @param[in]   v      reflectivity ver. pol.
!> @param[in]   h      reflectivity hor. pol.
!> @param[out]  rho_v  coherent p-polarized reflectivity ver. pol.
!> @param[out   rho_h  coherent p-polarized reflectivity hor. pol.
!
! Ref: sense/model.py, l177 ff.
!
SUBROUTINE CALC_RHO_FWV(theta, ks, v, v_fwv, h, h_fwv, rho_v, rho_v_fwv&
& , rho_h, rho_h_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: theta
  REAL(kind=8), INTENT(IN) :: ks
  REAL(kind=8), INTENT(IN) :: v, h
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: v_fwv, h_fwv
  REAL(kind=8), INTENT(OUT) :: rho_v, rho_h
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: rho_v_fwv, &
& rho_h_fwv
  INTRINSIC COS
  INTRINSIC EXP
  REAL*8 :: arg1
  INTEGER :: nd
  INTEGER :: nbdirs
!--
  arg1 = -(4._8*COS(theta)**2*ks**2)
  DO nd=1,nbdirs
    rho_v_fwv(nd) = EXP(arg1)*v_fwv(nd)
  END DO
  rho_v = v*EXP(arg1)
  arg1 = -(4._8*COS(theta)**2*ks**2)
  DO nd=1,nbdirs
    rho_h_fwv(nd) = EXP(arg1)*h_fwv(nd)
  END DO
  rho_h = h*EXP(arg1)
END SUBROUTINE CALC_RHO_FWV

!  Differentiation of sigma_gcg in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: s0gcg
!   with respect to varying inputs: t_h sigma_vol_back t_v ke_h
!                ke_v rho_h rho_v
!***********************************************************
!     sigma_gcg
!
!> @brief compute ground-canopy-ground interaction
!
!> @param[in]  sigma_vol_back
!> @param[in]  theta
!> @param[in]  rho_v
!> @param[in]  rho_h
!> @param[in]  t_h
!> @param[in]  t_v
!> @param[in]  ke_v
!> @param[in]  ke_h
!> @param[out] s0gcg
!
! Ref: sense/model.py, l205 ff.
!
SUBROUTINE SIGMA_GCG_FWV(sigma_vol_back, sigma_vol_back_fwv, theta, &
& rho_v, rho_v_fwv, rho_h, rho_h_fwv, t_v, t_v_fwv, t_h, t_h_fwv, ke_v, &
& ke_v_fwv, ke_h, ke_h_fwv, s0gcg, s0gcg_fwv, nbdirs)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
!hh,vv,hv
  REAL(kind=8), INTENT(IN) :: sigma_vol_back(3)
  REAL(kind=8), INTENT(IN) :: sigma_vol_back_fwv(nbdirsmax, 3)
  REAL(kind=8), INTENT(IN) :: theta, rho_v, rho_h, t_v, t_h, ke_v, ke_h
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: rho_v_fwv, rho_h_fwv&
& , t_v_fwv, t_h_fwv, ke_v_fwv, ke_h_fwv
!hh,vv,hv
  REAL(kind=8), INTENT(OUT) :: s0gcg(3)
  REAL(kind=8), INTENT(OUT) :: s0gcg_fwv(nbdirsmax, 3)
  INTRINSIC COS
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
!-- HH
    s0gcg_fwv(nd, :) = 0.0_8
    s0gcg_fwv(nd, 1) = (COS(theta)*((sigma_vol_back_fwv(nd, 2)*rho_h**2+&
&     sigma_vol_back(2)*(rho_h_fwv(nd)*rho_h+rho_h*rho_h_fwv(nd)))*(t_h&
&     **2-t_h**4)+sigma_vol_back(2)*rho_h**2*(2*t_h*t_h_fwv(nd)-4*t_h**3&
&     *t_h_fwv(nd)))*(ke_h+ke_h)-sigma_vol_back(2)*COS(theta)*rho_h**2*(&
&     t_h**2-t_h**4)*2*ke_h_fwv(nd))/(ke_h+ke_h)**2
!-- VV
    s0gcg_fwv(nd, 2) = (COS(theta)*((sigma_vol_back_fwv(nd, 1)*rho_v**2+&
&     sigma_vol_back(1)*(rho_v_fwv(nd)*rho_v+rho_v*rho_v_fwv(nd)))*(t_v&
&     **2-t_v**4)+sigma_vol_back(1)*rho_v**2*(2*t_v*t_v_fwv(nd)-4*t_v**3&
&     *t_v_fwv(nd)))*(ke_v+ke_v)-sigma_vol_back(1)*COS(theta)*rho_v**2*(&
&     t_v**2-t_v**4)*2*ke_v_fwv(nd))/(ke_v+ke_v)**2
  END DO
  s0gcg(1) = sigma_vol_back(2)*COS(theta)*rho_h*rho_h*(t_h**2-t_h**4)/(&
&   ke_h+ke_h)
  s0gcg(2) = sigma_vol_back(1)*COS(theta)*rho_v*rho_v*(t_v**2-t_v**4)/(&
&   ke_v+ke_v)
!-- HV
  IF (sigma_vol_back(3) .EQ. sense_fv) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
    DO nd=1,nbdirs
      s0gcg_fwv(nd, 3) = 0.0_8
    END DO
    s0gcg(3) = sense_fv
  ELSE
    DO nd=1,nbdirs
      s0gcg_fwv(nd, 3) = (COS(theta)*((sigma_vol_back_fwv(nd, 3)*rho_h*&
&       rho_v+sigma_vol_back(3)*(rho_h_fwv(nd)*rho_v+rho_h*rho_v_fwv(nd)&
&       ))*(t_h*t_v-t_h**2*t_v**2)+sigma_vol_back(3)*rho_h*rho_v*(&
&       t_h_fwv(nd)*t_v+t_h*t_v_fwv(nd)-2*t_h*t_h_fwv(nd)*t_v**2-t_h**2*&
&       2*t_v*t_v_fwv(nd)))*(ke_h+ke_v)-sigma_vol_back(3)*COS(theta)*&
&       rho_h*rho_v*(t_h*t_v-t_h**2*t_v**2)*(ke_h_fwv(nd)+ke_v_fwv(nd)))&
&       /(ke_h+ke_v)**2
    END DO
    s0gcg(3) = sigma_vol_back(3)*COS(theta)*rho_h*rho_v*(t_h*t_v-t_h**2*&
&     t_v**2)/(ke_h+ke_v)
  END IF
END SUBROUTINE SIGMA_GCG_FWV

!  Differentiation of sigma_cg in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: s0cg
!   with respect to varying inputs: d t_h t_v sigma_vol_bistatic
!                rho_h rho_v
!***********************************************************
!     sigma_cg
!
!> @brief calculate canopy ground scattering coefficient This is based on Eq. 11.17 (last term) in Ulaby (2014) and 11.14 in Ulab
!y (2014)
!  (for co-pol, coherent addition can be made as an option)
!
!> @param[in]  sigma_vol_bistatic
!> @param[in]  d
!> @param[in]  coherent
!> @param[in]  rho_v
!> @param[in]  rho_h
!> @param[in]  t_h
!> @param[in]  t_v
!> @param[out] s0cg
!
! Ref: sense/model.py, l215 ff.
!
SUBROUTINE SIGMA_CG_FWV(sigma_vol_bistatic, sigma_vol_bistatic_fwv, d, &
& d_fwv, coherent, rho_v, rho_v_fwv, rho_h, rho_h_fwv, t_v, t_v_fwv, t_h&
& , t_h_fwv, s0cg, s0cg_fwv, nbdirs)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
!hh,vv,hv
  REAL(kind=8), INTENT(IN) :: sigma_vol_bistatic(3)
  REAL(kind=8), INTENT(IN) :: sigma_vol_bistatic_fwv(nbdirsmax, 3)
  REAL(kind=8), INTENT(IN) :: d, rho_v, rho_h, t_v, t_h
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: d_fwv, rho_v_fwv, &
& rho_h_fwv, t_v_fwv, t_h_fwv
  LOGICAL, INTENT(IN) :: coherent
!hh,vv,hv
  REAL(kind=8), INTENT(OUT) :: s0cg(3)
  REAL(kind=8), INTENT(OUT) :: s0cg_fwv(nbdirsmax, 3)
! local decls
  REAL(kind=8) :: n
  INTEGER :: nd
  INTEGER :: nbdirs
  IF (coherent) THEN
    n = 2._8
  ELSE
    n = 1._8
  END IF
  DO nd=1,nbdirs
!-- HH
    s0cg_fwv(nd, :) = 0.0_8
    s0cg_fwv(nd, 1) = n*((sigma_vol_bistatic_fwv(nd, 1)*t_h+&
&     sigma_vol_bistatic(1)*t_h_fwv(nd))*d*t_h*(rho_h+rho_h)+&
&     sigma_vol_bistatic(1)*t_h*((d_fwv(nd)*t_h+d*t_h_fwv(nd))*(rho_h+&
&     rho_h)+d*t_h*2*rho_h_fwv(nd)))
!-- VV
    s0cg_fwv(nd, 2) = n*((sigma_vol_bistatic_fwv(nd, 2)*t_v+&
&     sigma_vol_bistatic(2)*t_v_fwv(nd))*d*t_v*(rho_v+rho_v)+&
&     sigma_vol_bistatic(2)*t_v*((d_fwv(nd)*t_v+d*t_v_fwv(nd))*(rho_v+&
&     rho_v)+d*t_v*2*rho_v_fwv(nd)))
  END DO
  s0cg(1) = n*sigma_vol_bistatic(1)*d*(rho_h+rho_h)*t_h*t_h
  s0cg(2) = n*sigma_vol_bistatic(2)*d*(rho_v+rho_v)*t_v*t_v
!-- HV
  IF (sigma_vol_bistatic(3) .EQ. sense_fv) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
    DO nd=1,nbdirs
      s0cg_fwv(nd, 3) = 0.0_8
    END DO
    s0cg(3) = sense_fv
  ELSE
    DO nd=1,nbdirs
      s0cg_fwv(nd, 3) = n*((sigma_vol_bistatic_fwv(nd, 3)*t_v+&
&       sigma_vol_bistatic(3)*t_v_fwv(nd))*d*t_h*(rho_v+rho_h)+&
&       sigma_vol_bistatic(3)*t_v*((d_fwv(nd)*t_h+d*t_h_fwv(nd))*(rho_v+&
&       rho_h)+d*t_h*(rho_v_fwv(nd)+rho_h_fwv(nd))))
    END DO
    s0cg(3) = n*sigma_vol_bistatic(3)*d*(rho_v+rho_h)*t_h*t_v
  END IF
END SUBROUTINE SIGMA_CG_FWV

!  Differentiation of ground_sigma in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: gnd_sigma
!   with respect to varying inputs: t_h t_v soil_backscatter
!***********************************************************
!     ground_sigma
!
!> @brief calculate backscattering coefficient (Eq. 11.4, p.463 Ulaby (2014))
!
!> @param[in]  soil_backscatter
!> @param[in]  t_v
!> @param[in]  t_h
!> @param[out] gnd_sigma
!
! Ref: sense/model.py, l243 ff.
!
SUBROUTINE GROUND_SIGMA_FWV(soil_backscatter, soil_backscatter_fwv, t_v&
& , t_v_fwv, t_h, t_h_fwv, gnd_sigma, gnd_sigma_fwv, nbdirs)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
!hh,vv,hv
  REAL(kind=8), INTENT(IN) :: soil_backscatter(3)
  REAL(kind=8), INTENT(IN) :: soil_backscatter_fwv(nbdirsmax, 3)
  REAL(kind=8), INTENT(IN) :: t_v, t_h
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: t_v_fwv, t_h_fwv
  REAL(kind=8), INTENT(OUT) :: gnd_sigma(3)
  REAL(kind=8), INTENT(OUT) :: gnd_sigma_fwv(nbdirsmax, 3)
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
!-- HH
    gnd_sigma_fwv(nd, :) = 0.0_8
    gnd_sigma_fwv(nd, 1) = soil_backscatter_fwv(nd, 1)*t_h**2 + &
&     soil_backscatter(1)*(t_h_fwv(nd)*t_h+t_h*t_h_fwv(nd))
!-- VV
    gnd_sigma_fwv(nd, 2) = soil_backscatter_fwv(nd, 2)*t_v**2 + &
&     soil_backscatter(2)*(t_v_fwv(nd)*t_v+t_v*t_v_fwv(nd))
  END DO
  gnd_sigma(1) = soil_backscatter(1)*t_h*t_h
  gnd_sigma(2) = soil_backscatter(2)*t_v*t_v
!-- HV
  IF (soil_backscatter(3) .EQ. sense_fv) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
    DO nd=1,nbdirs
      gnd_sigma_fwv(nd, 3) = 0.0_8
    END DO
    gnd_sigma(3) = sense_fv
  ELSE
    DO nd=1,nbdirs
      gnd_sigma_fwv(nd, 3) = soil_backscatter_fwv(nd, 3)*t_v*t_h + &
&       soil_backscatter(3)*(t_v_fwv(nd)*t_h+t_v*t_h_fwv(nd))
    END DO
    gnd_sigma(3) = soil_backscatter(3)*t_v*t_h
  END IF
END SUBROUTINE GROUND_SIGMA_FWV

!  Differentiation of oh92_backscatter in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirection
!al):
!   variations   of useful results: backscatter
!   with respect to varying inputs: eps
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file Oh92.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of ...
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE OH92_BACKSCATTER_FWV(eps, eps_fwv, ks, theta, backscatter, &
& backscatter_fwv, nbdirs)
  USE MO_SENSIMUL_S1, ONLY : pi
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  COMPLEX(kind=8), INTENT(IN) :: eps
  COMPLEX(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: eps_fwv
  REAL(kind=8), INTENT(IN) :: ks, theta
!hh,vv,hv
  REAL(kind=8), INTENT(OUT) :: backscatter(3)
  REAL(kind=8), INTENT(OUT) :: backscatter_fwv(nbdirsmax, 3)
! local declarations
  REAL(kind=8) :: v, h
  REAL(kind=8), DIMENSION(nbdirsmax) :: v_fwv, h_fwv
  REAL(kind=8) :: frsn0
  REAL(kind=8), DIMENSION(nbdirsmax) :: frsn0_fwv
  REAL(kind=8) :: p, q, vv0
  REAL(kind=8), DIMENSION(nbdirsmax) :: p_fwv, q_fwv, vv0_fwv
  REAL(kind=8), EXTERNAL :: FRESNEL0
  EXTERNAL REFLECTIVITY
  EXTERNAL REFLECTIVITY_FWV
  INTEGER :: nd
  INTEGER :: nbdirs
!-- Nadir Fresnel reflectivity
  CALL FRESNEL0_FWV0(eps, eps_fwv, frsn0, frsn0_fwv, nbdirs)
!--
  CALL REFLECTIVITY_FWV(theta, eps, eps_fwv, v, v_fwv, h, h_fwv, nbdirs)
!
  CALL CALC_P_FWV0(p, p_fwv, nbdirs)
  CALL CALC_Q_FWV0(q, q_fwv, nbdirs)
  CALL CALC_VV_FWV0(vv0, vv0_fwv, nbdirs)
  DO nd=1,nbdirs
    backscatter_fwv(nd, :) = 0.0_8
    backscatter_fwv(nd, 1) = p_fwv(nd)*vv0 + p*vv0_fwv(nd)
    backscatter_fwv(nd, 2) = vv0_fwv(nd)
    backscatter_fwv(nd, 3) = q_fwv(nd)*vv0 + q*vv0_fwv(nd)
  END DO
  backscatter(1) = p*vv0
  backscatter(2) = vv0
  backscatter(3) = q*vv0

CONTAINS
!  Differentiation of calc_p in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: calc_p
!   with respect to varying inputs: frsn0
  SUBROUTINE CALC_P_FWV0(calc_p, calc_p_fwv, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(kind=8) :: a
    REAL(kind=8), DIMENSION(nbdirsmax) :: a_fwv
    INTRINSIC EXP
    REAL*8 :: pwx1
    REAL*8 :: pwr1
    REAL*8, DIMENSION(nbdirsmax) :: pwr1_fwv
    INTEGER :: nd
    REAL(kind=8) :: calc_p
    REAL(kind=8) :: calc_p_fwv(nbdirsmax)
    INTEGER :: nbdirs
    a = 1._8/(3._8*frsn0)
    pwx1 = 2._8*theta/pi
    pwr1 = pwx1**a
    DO nd=1,nbdirs
      a_fwv(nd) = -(3._8*frsn0_fwv(nd)/(3._8*frsn0)**2)
      IF (pwx1 .GT. 0.0_8) THEN
        pwr1_fwv(nd) = LOG(pwx1)*pwx1**a*a_fwv(nd)
      ELSE
        pwr1_fwv(nd) = 0.0_8
      END IF
      calc_p_fwv(nd) = -(2*(1._8-pwr1*EXP(-ks))*EXP(-ks)*pwr1_fwv(nd))
    END DO
    calc_p = (1._8-pwr1*EXP(-ks))**2
  END SUBROUTINE CALC_P_FWV0
  REAL(kind=8) FUNCTION CALC_P()
    IMPLICIT NONE
    REAL(kind=8) :: a
    INTRINSIC EXP
    REAL*8 :: pwx1
    REAL*8 :: pwr1
    a = 1._8/(3._8*frsn0)
    pwx1 = 2._8*theta/pi
    pwr1 = pwx1**a
    calc_p = (1._8-pwr1*EXP(-ks))**2
  END FUNCTION CALC_P
!  Differentiation of calc_q in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: calc_q
!   with respect to varying inputs: frsn0
  SUBROUTINE CALC_Q_FWV0(calc_q, calc_q_fwv, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    INTRINSIC EXP
    INTEGER :: nd
    REAL(kind=8) :: calc_q
    REAL(kind=8) :: calc_q_fwv(nbdirsmax)
    INTEGER :: nbdirs
    DO nd=1,nbdirs
      calc_q_fwv(nd) = 0.23_8*(1._8-EXP(-ks))*0.5_8*frsn0**(-0.5)*&
&       frsn0_fwv(nd)
    END DO
    calc_q = 0.23_8*frsn0**0.5_8*(1._8-EXP(-ks))
  END SUBROUTINE CALC_Q_FWV0
  REAL(kind=8) FUNCTION CALC_Q()
    IMPLICIT NONE
    INTRINSIC EXP
    calc_q = 0.23_8*frsn0**0.5_8*(1._8-EXP(-ks))
  END FUNCTION CALC_Q
!  Differentiation of calc_vv in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: calc_vv
!   with respect to varying inputs: h p v
  SUBROUTINE CALC_VV_FWV0(calc_vv, calc_vv_fwv, nbdirs)
    USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
    IMPLICIT NONE
    REAL(kind=8) :: a, b
    REAL(kind=8), DIMENSION(nbdirsmax) :: b_fwv
    INTRINSIC EXP
    INTRINSIC COS
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL(kind=8) :: result1
    REAL(kind=8), DIMENSION(nbdirsmax) :: result1_fwv
    INTEGER :: nd
    REAL(kind=8) :: calc_vv_fwv(nbdirsmax)
    REAL(kind=8) :: calc_vv
    INTEGER :: nbdirs
    arg1 = -(0.65_8*ks**1.8)
    a = 0.7_8*(1._8-EXP(arg1))
    result1 = SQRT(p)
    DO nd=1,nbdirs
      IF (p .EQ. 0.0_8) THEN
        result1_fwv(nd) = 0.0_8
      ELSE
        result1_fwv(nd) = p_fwv(nd)/(2.0*SQRT(p))
      END IF
      b_fwv(nd) = (COS(theta)**3._8*(v_fwv(nd)+h_fwv(nd))*result1-COS(&
&       theta)**3._8*(v+h)*result1_fwv(nd))/result1**2
      calc_vv_fwv(nd) = a*b_fwv(nd)
    END DO
    b = COS(theta)**3._8*(v+h)/result1
    calc_vv = a*b
  END SUBROUTINE CALC_VV_FWV0
  REAL(kind=8) FUNCTION CALC_VV()
    IMPLICIT NONE
    REAL(kind=8) :: a, b
    INTRINSIC EXP
    INTRINSIC COS
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL(kind=8) :: result1
    arg1 = -(0.65_8*ks**1.8)
    a = 0.7_8*(1._8-EXP(arg1))
    result1 = SQRT(p)
    b = COS(theta)**3._8*(v+h)/result1
    calc_vv = a*b
  END FUNCTION CALC_VV
END SUBROUTINE OH92_BACKSCATTER_FWV

!  Differentiation of fresnel0 in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: fresnel0
!   with respect to varying inputs: e
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file core.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of core routines ported from Sentinel Simulator (sense/core.py)
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     fresnel0
!
!> @brief calculate the Nadir Fresnel reflectivity (e.g. Ulaby (2014), eq. 10.36)
!
!> @param[in]  e  complex relative dielectric permitivity
!
!> \return reflectivity
!
! Ref: sense/core.py, l4 ff.
!
SUBROUTINE FRESNEL0_FWV0(e, e_fwv, fresnel0, fresnel0_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  COMPLEX(kind=8), INTENT(IN) :: e
  COMPLEX(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: e_fwv
  COMPLEX(kind=8) :: hlp
  COMPLEX(kind=8), DIMENSION(nbdirsmax) :: hlp_fwv
! interfaces
  REAL(kind=8), EXTERNAL :: CSQ2
  INTRINSIC SQRT
  COMPLEX(kind=8) :: result1
  COMPLEX(kind=8), DIMENSION(nbdirsmax) :: result1_fwv
  COMPLEX(kind=8) :: result2
  COMPLEX(kind=8), DIMENSION(nbdirsmax) :: result2_fwv
  INTEGER :: nd
  REAL(kind=8) :: fresnel0
  REAL(kind=8) :: fresnel0_fwv(nbdirsmax)
  INTEGER :: nbdirs
  result1 = SQRT(e)
  result2 = SQRT(e)
  DO nd=1,nbdirs
! fresnel0 = abs( (1._8 - sqrt(e))/(1._8+sqrt(e)) )**2
    IF (e .EQ. 0.0_8) THEN
      result1_fwv(nd) = 0.0_8
    ELSE
      result1_fwv(nd) = e_fwv(nd)/(2.0*SQRT(e))
    END IF
    IF (e .EQ. 0.0_8) THEN
      result2_fwv(nd) = 0.0_8
    ELSE
      result2_fwv(nd) = e_fwv(nd)/(2.0*SQRT(e))
    END IF
    hlp_fwv(nd) = (-(result1_fwv(nd)*(1._8+result2))-(1._8-result1)*&
&     result2_fwv(nd))/(1._8+result2)**2
  END DO
  hlp = (1._8-result1)/(1._8+result2)
  CALL CSQ2_FWV0(hlp, hlp_fwv, fresnel0, fresnel0_fwv, nbdirs)
END SUBROUTINE FRESNEL0_FWV0

!  Differentiation of reflectivity in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: h v
!   with respect to varying inputs: eps
!***********************************************************
!     reflectivity
!
!> @brief calculate reflectivity for H and V polarisation (table 2.5 Ulaby (2014), assumes specular surface)
!
!> @param[in]   theta  incidence angle [rad]
!> @param[in]   eps    relative dielectric permitivity (complex)
!> @param[out]  v      reflectivity ver. pol.
!> @param[out   h      reflectivity hor. pol.
!
! Ref: sense/core.py, l26 ff.
!
SUBROUTINE REFLECTIVITY_FWV(theta, eps, eps_fwv, v, v_fwv, h, h_fwv, &
& nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: theta
  COMPLEX(kind=8), INTENT(IN) :: eps
  COMPLEX(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: eps_fwv
  REAL(kind=8), INTENT(OUT) :: v, h
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: v_fwv, h_fwv
! interfaces
  REAL(kind=8), EXTERNAL :: CSQ2
! local vars
  COMPLEX(kind=8) :: rho_v, rho_h
  COMPLEX(kind=8), DIMENSION(nbdirsmax) :: rho_v_fwv, rho_h_fwv
  INTEGER :: nbdirs
  CALL CALC_REFLECTION_COEFFICIENTS_FWV(theta, eps, eps_fwv, rho_v, &
&                                 rho_v_fwv, rho_h, rho_h_fwv, nbdirs)
! v = abs(rho_v)**2
! h = abs(rho_h)**2
! v = real(rho_v)**2 + aimag(rho_v)**2
! h = real(rho_h)**2 + aimag(rho_h)**2
  CALL CSQ2_FWV0(rho_v, rho_v_fwv, v, v_fwv, nbdirs)
  CALL CSQ2_FWV0(rho_h, rho_h_fwv, h, h_fwv, nbdirs)
END SUBROUTINE REFLECTIVITY_FWV

!  Differentiation of calc_reflection_coefficients in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 mu
!ltiDirectional):
!   variations   of useful results: rho_h rho_v
!   with respect to varying inputs: eps
!***********************************************************
!     calc_reflection_coefficients
!
!> @brief calculate reflection coefficients (Woodhouse, 2006; Eq. 5.54, 5.55)
!
!> @param[in]   theta  incidence angle [rad]
!> @param[in]   eps    relative dielectric permitivity (complex)
!> @param[out]  rho_v  reflection coefficent, vertical pol. (complex)
!> @param[out   rho_h  reflection coefficient, horizontal pol. (complex)
!
! Ref: sense/core.py, l47 ff.
!
SUBROUTINE CALC_REFLECTION_COEFFICIENTS_FWV(theta, eps, eps_fwv, rho_v, &
& rho_v_fwv, rho_h, rho_h_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: theta
  COMPLEX(kind=8), INTENT(IN) :: eps
  COMPLEX(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: eps_fwv
  COMPLEX(kind=8), INTENT(OUT) :: rho_v, rho_h
  COMPLEX(kind=8), DIMENSION(nbdirsmax), INTENT(OUT) :: rho_v_fwv, &
& rho_h_fwv
! local variables
  REAL(kind=8) :: co, si2
  COMPLEX(kind=8) :: hlp
  COMPLEX(kind=8), DIMENSION(nbdirsmax) :: hlp_fwv
  INTRINSIC COS
  INTRINSIC SIN
  INTRINSIC SQRT
  INTEGER :: nd
  INTEGER :: nbdirs
  co = COS(theta)
  si2 = SIN(theta)**2
  hlp = SQRT(eps - si2)
  DO nd=1,nbdirs
    IF (eps - si2 .EQ. 0.0_8) THEN
      hlp_fwv(nd) = 0.0_8
    ELSE
      hlp_fwv(nd) = eps_fwv(nd)/(2.0*SQRT(eps-si2))
    END IF
    rho_v_fwv(nd) = ((co*eps_fwv(nd)-hlp_fwv(nd))*(eps*co+hlp)-(eps*co-&
&     hlp)*(co*eps_fwv(nd)+hlp_fwv(nd)))/(eps*co+hlp)**2
    rho_h_fwv(nd) = (-(hlp_fwv(nd)*(co+hlp))-(co-hlp)*hlp_fwv(nd))/(co+&
&     hlp)**2
  END DO
  rho_v = (eps*co-hlp)/(eps*co+hlp)
  rho_h = (co-hlp)/(co+hlp)
END SUBROUTINE CALC_REFLECTION_COEFFICIENTS_FWV

!  Differentiation of csq2 in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: csq2
!   with respect to varying inputs: z
!***********************************************************
!     csq2
!
!> @brief computes square of absolute value of complex number 
!
!> @param[in]  z  complex number
!> \return     |z|^2
!
SUBROUTINE CSQ2_FWV0(z, z_fwv, csq2, csq2_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  COMPLEX(kind=8), INTENT(IN) :: z
  COMPLEX(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: z_fwv
  INTRINSIC REAL
  INTRINSIC AIMAG
  EXTERNAL AIMAG_FWV
  REAL :: result1
  REAL, DIMENSION(nbdirsmax) :: result1_fwv
  INTEGER :: nd
  REAL(kind=8) :: csq2_fwv(nbdirsmax)
  REAL(kind=8) :: csq2
  INTEGER :: nbdirs
!  csq2 = abs(z)**2
  CALL AIMAG_FWV(z, z_fwv, result1, result1_fwv, nbdirs)
  DO nd=1,nbdirs
    csq2_fwv(nd) = 2*REAL(z)*z_fwv(nd) + 2*result1*result1_fwv(nd)
  END DO
  csq2 = REAL(z)**2 + result1**2
END SUBROUTINE CSQ2_FWV0

!  Differentiation of scatrayleigh_sigma_v_bistatic in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 m
!ultiDirectional):
!   variations   of useful results: backscatter
!   with respect to varying inputs: sigma_s_hh sigma_s_vv
!***********************************************************
!     ScatRayleigh_sigma_v_bistatic
!
!>  @brief compute backscattering coefficient from volume extinction coefficient(s) for Rayleigh scatterer (Ulceby (Eq. 11.22))
!
!> @param[in]  sigma_s_hh   volume extinction coefficient
!> @param[in]  sigma_s_vv   volume extinction coefficient
!> @param[out] backscatter  volume backscattering coefficient
!
! Ref: sense/scatterer.py, l60 ff.
!
SUBROUTINE SCATRAYLEIGH_SIGMA_V_BISTATIC_FWV(sigma_s_vv, sigma_s_vv_fwv&
& , sigma_s_hh, sigma_s_hh_fwv, backscatter, backscatter_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  REAL(kind=8), INTENT(IN) :: sigma_s_vv, sigma_s_hh
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: sigma_s_vv_fwv, &
& sigma_s_hh_fwv
!'hh','vv','hv'
  REAL(kind=8), INTENT(OUT) :: backscatter(3)
  REAL(kind=8), INTENT(OUT) :: backscatter_fwv(nbdirsmax, 3)
  INTEGER :: nbdirs
  CALL SCATRAYLEIGH_SIGMA_V_BACK_FWV(sigma_s_vv, sigma_s_vv_fwv, &
&                              sigma_s_hh, sigma_s_hh_fwv, backscatter, &
&                              backscatter_fwv, nbdirs)
END SUBROUTINE SCATRAYLEIGH_SIGMA_V_BISTATIC_FWV

!  Differentiation of scatrayleigh_sigma_v_back in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multi
!Directional):
!   variations   of useful results: backscatter
!   with respect to varying inputs: sigma_s_hh sigma_s_vv
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file scatterer.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of scatterer class ported from Sentinel Simulator (sense/scatterer.py)
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     ScatRayleigh_sigma_v_back
!
!> @brief compute backscattering coefficient from volume extinction coefficient(s) for Rayleigh scatterer
!
!> @param[in]  sigma_s_hh   volume extinction coefficient
!> @param[in]  sigma_s_vv   volume extinction coefficient
!> @param[out] backscatter  volume backscattering coefficient
!
! Ref: sense/scatterer.py, l56 ff.
!
SUBROUTINE SCATRAYLEIGH_SIGMA_V_BACK_FWV(sigma_s_vv, sigma_s_vv_fwv, &
& sigma_s_hh, sigma_s_hh_fwv, backscatter, backscatter_fwv, nbdirs)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  REAL(kind=8), INTENT(IN) :: sigma_s_vv, sigma_s_hh
  REAL(kind=8), DIMENSION(nbdirsmax), INTENT(IN) :: sigma_s_vv_fwv, &
& sigma_s_hh_fwv
!'hh','vv','hv'
  REAL(kind=8), INTENT(OUT) :: backscatter(3)
  REAL(kind=8), INTENT(OUT) :: backscatter_fwv(nbdirsmax, 3)
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
    backscatter_fwv(nd, :) = 0.0_8
    backscatter_fwv(nd, 1) = 1.5_8*sigma_s_hh_fwv(nd)
    backscatter_fwv(nd, 2) = 1.5_8*sigma_s_vv_fwv(nd)
    backscatter_fwv(nd, 3) = 0.0_8
  END DO
  backscatter(1) = 1.5_8*sigma_s_hh
  backscatter(2) = 1.5_8*sigma_s_vv
  backscatter(3) = sense_fv
END SUBROUTINE SCATRAYLEIGH_SIGMA_V_BACK_FWV

!  Differentiation of simulate_s2 in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: y
!   with respect to varying inputs: x y
!***********************************************************
!     simulate_s2
!
!> @brief Implementation of the S2 observation operator.
!>        Computes top-of-canopy BRFs in all 13 Sentinel2 bands for every
!>        state in the control vector.
!
!
!> @param[in]   n  length of control vector for multiple simulations in the optical domain
!> @param[in]   x  S2 relevant part of full control vector in physical units.
!                  (expected ordering is: state variables LAI,HC,SM per state)
!> @param[in]   m  length of output vector
!> @param[out]  y  simulated TOC BRFs (for all 13 S2 wave-bands) and multiple observations
!                  (ordering will be BRF1-BRF12 per state)
!
SUBROUTINE SIMULATE_S2_FWV(n, x, x_fwv, m, y, y_fwv, nbdirs)
  USE MO_SENSIMUL, ONLY : nsc, npts_s2, iv_geom, get_nc_s2, get_m_s2, &
& timept_idxs_s2
  USE MO_SENSIMUL_S2, ONLY : nb_s2
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: y(m)
  REAL(kind=8), INTENT(OUT) :: y_fwv(nbdirsmax, m)
! external
  EXTERNAL SIMULATE_S2_1GEOM
  EXTERNAL SIMULATE_S2_1GEOM_FWV
! local decls
  INTEGER :: ipt, ipt_s2
  INTEGER :: ii0, ii1, j0, j1
  REAL(kind=8) :: statev(nsc)
  REAL(kind=8) :: statev_fwv(nbdirsmax, nsc)
  REAL(kind=8) :: single_ivgeom(4)
  INTEGER :: nd
  INTEGER :: nbdirs
!-- dimension consistency
  IF (n .NE. GET_NC_S2()) THEN
    WRITE(*, '(a,2(a,i3,1x))') &
&   ' FATAL::simulate_s2:inconsistent length of state vector!', &
&   'expected=', GET_NC_S2(), 'got=', n
    STOP
  ELSE
    IF (m .NE. GET_M_S2()) WRITE(*, '(a,2(a,i3,1x))') &
&            ' FATAL::simulate_s2:inconsistent length of result vector.'&
&                          , 'expected=', GET_M_S2(), 'got=', m
!-- loop over all time-points
    ii0 = 1
    j0 = 1
    DO nd=1,nbdirs
      statev_fwv(nd, :) = 0.0_8
    END DO
!!! !$AD II-LOOP
simloop:DO ipt=1,npts_s2
      ii1 = ii0 + nsc - 1
      j1 = j0 + nb_s2 - 1
      DO nd=1,nbdirs
        statev_fwv(nd, 1:nsc) = x_fwv(nd, ii0:ii1)
      END DO
      statev(1:nsc) = x(ii0:ii1)
      ipt_s2 = timept_idxs_s2(ipt)
      single_ivgeom(1:4) = iv_geom(1:4, ipt_s2)
      CALL SIMULATE_S2_1GEOM_FWV(statev, statev_fwv, single_ivgeom, y(j0&
&                          :j1), y_fwv(:, j0:j1), nbdirs)
!-- increment start position
      ii0 = ii1 + 1
      j0 = j1 + 1
    END DO simloop
  END IF
END SUBROUTINE SIMULATE_S2_FWV

!  Differentiation of simulate_s2_1geom in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectio
!nal):
!   variations   of useful results: brf /multi/[0,6720[ /multi/[6720,13440[
!                /multi/[13440,20160[
!   with respect to varying inputs: brf statev /multi/[0,6720[
!                /multi/[6720,13440[ /multi/[13440,20160[
!***********************************************************
!     simulate_s2_1geom
!
!> @brief Implementation of the Sentinel Synergy Study observation operator
!>        in the optical domain (denoted H_2 in document D5) for a single state.
!         
!
!> @details For the given input state (LAI,HC, and SM) the observation operator
!>          derives TOC BRFs for all 13 S2 wave-bands. The implementation is based
!>          on the coupled SemiDiscrete-PROSPECT-PRICE model.
!>          Running the SemiDiscrete model requires to specify the illumination- and
!>          view geometry.
!
!> @param[in]   statev   state-vector consisting of LAI, HC, and SM
!> @param[in]   iv_geom  illumination-view geomtry in order sza,saa,vza,vaa (in degrees)
!> @param[out]  brf      TOC BRFs for 13 S2 wave-bands
!
SUBROUTINE SIMULATE_S2_1GEOM_FWV(statev, statev_fwv, iv_geom, brf, &
& brf_fwv, nbdirs)
  USE MO_SENSIMUL, ONLY : nsc
  USE MO_SENSIMUL_S2
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: statev(nsc)
  REAL(kind=8), INTENT(IN) :: statev_fwv(nbdirsmax, nsc)
!sza,saa,vza,vaa
  REAL(kind=8), INTENT(IN) :: iv_geom(4)
  REAL(kind=8), INTENT(OUT) :: brf(nb_s2)
  REAL(kind=8), INTENT(OUT) :: brf_fwv(nbdirsmax, nb_s2)
! local decls
  REAL :: lai, hc, sm
  REAL, DIMENSION(nbdirsmax) :: lai_fwv, hc_fwv, sm_fwv
  REAL :: rsl1
  REAL, DIMENSION(nbdirsmax) :: rsl1_fwv
  REAL :: theta_i, phi_i, theta_v, phi_v
!'nadim_prospect_price_fast_1geom' does not expect kind=8 !
  REAL :: brf_(nb_s2)
  REAL :: brf__fwv(nbdirsmax, nb_s2)
! externals
  REAL, EXTERNAL :: SM_TO_RSL1
  EXTERNAL NADIM_PROSPECT_PRICE_FAST_1GEOM
  EXTERNAL NADIM_PROSPECT_PRICE_FAST_1GEOM_FWV
  INTRINSIC REAL
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
!-- map state variables
!   (potential cast from r8 to r4)
    lai_fwv(nd) = statev_fwv(nd, 1)
    hc_fwv(nd) = statev_fwv(nd, 2)
    sm_fwv(nd) = statev_fwv(nd, 3)
  END DO
  lai = statev(1)
  hc = statev(2)
  sm = statev(3)
!-- 1st spectral vector of soil reflectance (of Price's EOF)
!   is modulated by the soil moisture state
  CALL SM_TO_RSL1_FWV0(sm, sm_fwv, rsl1_default, sm_coeff, rsl1, &
&                rsl1_fwv, nbdirs)
!-- geometry
  theta_i = iv_geom(1)
  phi_i = iv_geom(2)
  theta_v = iv_geom(3)
  phi_v = iv_geom(4)
!-- call coupled optical model
  CALL NADIM_PROSPECT_PRICE_FAST_1GEOM_FWV(nb_s2, nw1nm, s2_response_mat&
&                                    , theta_i, phi_i, theta_v, phi_v, &
&                                    lad, rpl, lai, lai_fwv, hc, hc_fwv&
&                                    , vai, cab, cw, cp, cc, rsl1, &
&                                    rsl1_fwv, rsl2, rsl3, rsl4, brf_, &
&                                    brf__fwv, nbdirs)
  DO nd=1,nbdirs
!-- re-cast buffer
    brf_fwv(nd, 1:nb_s2) = brf__fwv(nd, 1:nb_s2)
  END DO
  brf(1:nb_s2) = REAL(brf_(1:nb_s2), kind=8)
END SUBROUTINE SIMULATE_S2_1GEOM_FWV

!  Differentiation of nadim_prospect_price_fast_1geom in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8
! multiDirectional):
!   variations   of useful results: brf /multi/[0,6720[ /multi/[6720,13440[
!                /multi/[13440,20160[
!   with respect to varying inputs: lai hc rsl1 /multi/[0,6720[
!                /multi/[6720,13440[ /multi/[13440,20160[
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file semiD_ftn.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: main routine of the coupled Semidiscrite-Prospect-Price model provided by
!               Tristan Quaife and implemented as mixed Fortran/C code being ported
!               to pure Fortran implementation.
!               This aims for smooth application of an AD tool and may also yield small performance
!               gain.
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February/April/August 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     nadim_prospect_price_fast_1geom
!
!> @brief runs coupled NADIM-PROSPECT-PRICE model and computes  BRFs for 'nb' (broad) bands and a single illumination/view geomet
!ry
!
!> @details TBD
!
!> @param[in]  nb           number of wave-bands
!> @param[in]  nw1nm        number of 1nm wavelengths in range [400nm,2500nm]
!> @param[in]  resp_mat     responses for every wavelength in [400nm,2500nm] and all 'nb' bands
!> @param[in]  theta_i      illumination zenith angle [deg]
!> @param[in]  phi_i        illumination azimuth angle [deg]
!> @param[in]  theta_v      viewing zenith angle [deg]
!> @param[in]  phi_v        viewing azimuth angle [deg]
!> @param[in]  lad          Leaf angle distribution (1:Planophile, 2:Erectophile, 3:Plagiophile, 4:Extremophile, 5:Uniforme
!> @param[in]  rpl          radius of single leaf
!> @param[in]  lai          leaf area index [m^2/m^2]
!> @param[in]  hc           canopy height [m]
!> @param[in]  vai          leaf structure (PROSPECT)
!> @param[in]  cab          leaf chlorophyll (PROSPECT)
!> @param[in]  cw           leaf water equivelent thickness (PROSPECT)
!> @param[in]  cp           protein concentration (PROSPECT)
!> @param[in]  cc           cellulose and lignin (PROSPECT)
!> @param[in]  rsl1         weight of first spectral vector of the soil reflectance (PRICE)
!> @param[in]  rsl2         weight of second spectral vector of the soil reflectance (PRICE)
!> @param[in]  rsl3         weight of third spectral vector of the soil reflectance (PRICE)
!> @param[in]  rsl4         weight of fourth spectral vector of the soil reflectance (PRICE)
!> @param[out] brf          Bidirectional reflectance factor
!
SUBROUTINE NADIM_PROSPECT_PRICE_FAST_1GEOM_FWV(nb, nw1nm, resp_mat, &
& theta_i, phi_i, theta_v, phi_v, lad, rpl, lai, lai_fwv, hc, hc_fwv, &
& vai, cab, cw, cp, cc, rsl1, rsl1_fwv, rsl2, rsl3, rsl4, brf, brf_fwv, &
& nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! constants
!number of view--illumination geometries
  INTEGER, PARAMETER :: niv=1
! arguments
  INTEGER, INTENT(IN) :: nb, nw1nm
  REAL, INTENT(IN) :: theta_i, phi_i, theta_v, phi_v
  INTEGER, INTENT(IN) :: lad
  REAL, INTENT(IN) :: rpl, lai, hc
  REAL, DIMENSION(nbdirsmax), INTENT(IN) :: lai_fwv, hc_fwv
  REAL(kind=8), INTENT(IN) :: vai, cab, cw, cp, cc
  REAL, INTENT(IN) :: rsl1, rsl2, rsl3, rsl4
  REAL, DIMENSION(nbdirsmax), INTENT(IN) :: rsl1_fwv
  REAL(kind=8), INTENT(IN) :: resp_mat(nw1nm, nb)
  REAL, INTENT(OUT) :: brf(nb)
  REAL, INTENT(OUT) :: brf_fwv(nbdirsmax, nb)
! externals
  EXTERNAL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN
  EXTERNAL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_FWV
  EXTERNAL PROSPECT_FULLSPECTRUM_INTERP1NM_FTN
  REAL(kind=8), EXTERNAL :: CONVOLVE
! local variables
  INTEGER :: ib
! leaf reflectance/transmittance
  REAL(kind=8) :: p_rl(nw1nm), p_tl(nw1nm)
! soil reflectance
  REAL(kind=8) :: p_rs(nw1nm)
  REAL(kind=8) :: p_rs_fwv(nbdirsmax, nw1nm)
! values for individual S2 bands
  REAL(kind=8) :: rl_8(nb), tl_8(nb), rs_8(nb)
  REAL(kind=8) :: rs_8_fwv(nbdirsmax, nb)
! ...as normal 'real'
  REAL :: rl(nb), tl(nb), rs(nb)
  REAL :: rs_fwv(nbdirsmax, nb)
  REAL :: theta_v_asarr(niv), phi_v_asarr(niv)
  REAL :: brf_nadim(1)
  REAL :: brf_nadim_fwv(nbdirsmax, 1)
  INTEGER :: nd
  INTEGER :: nbdirs
! ! D E B U G
! integer, save :: cnt = 0
! character(len=1) :: cbuf
! character(len=2) :: ccbuf
! cnt = cnt + 1
! write(cbuf, '(i1)') cnt
!-- scalar to 1D array
  theta_v_asarr(1) = theta_v
  phi_v_asarr(1) = phi_v
!-- get leaf optical properties: [400nm,2500nm] at 1nm resolution
  CALL PROSPECT_FULLSPECTRUM_INTERP1NM_FTN(vai, cab, cw, cp, cc, p_rl, &
&                                    p_tl)
! get soil reflectance: [400nm,2500nm] at 1nm resolution
  CALL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_FWV(rsl1, rsl1_fwv, rsl2, &
&                                          rsl3, rsl4, p_rs, p_rs_fwv, &
&                                          nbdirs)
  DO nd=1,nbdirs
    brf_fwv(nd, :) = 0.0_8
    brf_nadim_fwv(nd, :) = 0.0_8
    rs_fwv(nd, :) = 0.0_8
    rs_8_fwv(nd, :) = 0.0_8
  END DO
!-- loop over S2 bands
!!! !$AD II-LOOP
bndloop:DO ib=1,nb
    CALL CONVOLVE_FWV0(nw1nm, p_rs, p_rs_fwv, resp_mat(1:nw1nm, ib), &
&                rs_8(ib), rs_8_fwv(:, ib), nbdirs)
    rl_8(ib) = CONVOLVE(nw1nm, p_rl, resp_mat(1:nw1nm, ib))
    tl_8(ib) = CONVOLVE(nw1nm, p_tl, resp_mat(1:nw1nm, ib))
    DO nd=1,nbdirs
      rs_fwv(nd, ib) = rs_8_fwv(nd, ib)
    END DO
    rs(ib) = rs_8(ib)
    rl(ib) = rl_8(ib)
    tl(ib) = tl_8(ib)
!-- BRF computation by NADIM
    CALL NADIMBRF_FWV(theta_i, phi_i, niv, theta_v_asarr, phi_v_asarr, &
&               lad, rs(ib), rs_fwv(:, ib), hc, hc_fwv, lai, lai_fwv, &
&               rpl, rl(ib), tl(ib), brf_nadim, brf_nadim_fwv, nbdirs)
    DO nd=1,nbdirs
!-- save NADIM BRF
      brf_fwv(nd, ib) = brf_nadim_fwv(nd, 1)
    END DO
    brf(ib) = brf_nadim(1)
  END DO bndloop
END SUBROUTINE NADIM_PROSPECT_PRICE_FAST_1GEOM_FWV

!  Differentiation of price_soil_fullspectrum_interp1nm_ftn in forward (tangent) mode (with options messagesInFile noinclude noIS
!IZE r8 multiDirectional):
!   variations   of useful results: refl
!   with respect to varying inputs: w1
SUBROUTINE PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_FWV(w1, w1_fwv, w2, w3&
& , w4, refl, refl_fwv, nbdirs)
  USE MO_SOIL
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  REAL, INTENT(IN) :: w1, w2, w3, w4
  REAL, DIMENSION(nbdirsmax), INTENT(IN) :: w1_fwv
  REAL(kind=8), INTENT(OUT) :: refl(nw)
  REAL(kind=8), INTENT(OUT) :: refl_fwv(nbdirsmax, nw)
! local variables
  INTEGER :: upper, lower
  REAL :: fraction, rs_lower, rs_upper
  REAL, DIMENSION(nbdirsmax) :: rs_lower_fwv, rs_upper_fwv
  INTEGER :: w
  INTRINSIC INT
  INTRINSIC REAL
  REAL :: arg1
  INTEGER :: nd
  INTEGER :: nbdirs
  DO nd=1,nbdirs
    refl_fwv(nd, :) = 0.0_8
  END DO
  DO w=1,nw
!-- NOTE: 'w-1' since v1,...,v4 use 0-indexing
    arg1 = (w-1)/5.0
    lower = INT(arg1)
    DO nd=1,nbdirs
      rs_lower_fwv(nd) = v1(lower)*w1_fwv(nd)
    END DO
    rs_lower = w1*v1(lower) + w2*v2(lower) + w3*v3(lower) + w4*v4(lower)
    IF (lower .EQ. nws - 1) THEN
      DO nd=1,nbdirs
        refl_fwv(nd, w) = rs_lower_fwv(nd)
      END DO
      refl(w) = rs_lower
    ELSE
      upper = lower + 1
      fraction = REAL(w-1)/5.0 - REAL(lower)
      DO nd=1,nbdirs
        rs_upper_fwv(nd) = v1(upper)*w1_fwv(nd)
        refl_fwv(nd, w) = (1.-fraction)*rs_lower_fwv(nd) + fraction*&
&         rs_upper_fwv(nd)
      END DO
      rs_upper = w1*v1(upper) + w2*v2(upper) + w3*v3(upper) + w4*v4(&
&       upper)
      refl(w) = rs_lower*(1.-fraction) + rs_upper*fraction
    END IF
  END DO
END SUBROUTINE PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_FWV

!  Differentiation of nadimbrf in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: i0 xif xi1u brf
!   with respect to varying inputs: i0 xif xi1u brf xlai xhc xrs
!**************************************************************
!  Name : nadimbrf.f
!***************************************************************
SUBROUTINE NADIMBRF_FWV(theta_i, phi_i, nv, theta_v, phi_v, lad, xrs, &
& xrs_fwv, xhc, xhc_fwv, xlai, xlai_fwv, rpl, xrl, xtl, brf, brf_fwv, &
& nbdirs)
  IMPLICIT NONE
  INCLUDE 'DIFFSIZES.inc'
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  INTEGER :: lad, nv
  REAL :: brf(nv)
  REAL :: brf_fwv(nbdirsmax, nv)
  REAL :: theta_v(nv), phi_v(nv), theta_i, phi_i
  REAL :: xlai, xhc, rpl, xrl, xtl, xrs
  REAL, DIMENSION(nbdirsmax) :: xlai_fwv, xhc_fwv, xrs_fwv
!***********************************************
!
!     Subroutine NADIMBRDF.f
!
!**********************************************
!
!  Output variable : BRF   = Bidirectional Reflectance Factor 
!
! 
!  Input variables :
!                       NV      = NUMBER OF VIEWING ANGLES
!                       THETA_I = SOLAR ZENITH ANGLE (IN DEGREES)
!                       PHI_I   = SOLAR AZIMUTH ANGLE (IN DEGREES)
!                       THETA_V = VIEWING ZENITH ANGLE (IN RADIANS)
!                       PHI_V   = VIEWING AZIMUTH ANGLE (IN RADIANS)
!
!                       LAD     = Leaf Angle Distribution
!                       = 1   <---> Planophile
!                       = 2   <---> Erectophile
!                       = 3   <---> Plagiophile
!                       = 4   <---> Extremophile
!                       = 5   <---> Uniforme
!
!                       XRS     = SOIL ALBEDO
!                       XHC     = HEIGHT OF THE CANOPY
!                       XLAI    = Leaf Area Index
!                       RPL     = radius of a single leaf
!                       XRL     = leaf reflectance
!                       XTL     = leaf transmittance
!
!************************************************************ 
!
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x_lambda_i, r1, r2, r3, xmeas
  REAL, DIMENSION(nbdirsmax) :: r1_fwv, r2_fwv, r3_fwv, xmeas_fwv
!     MVO::n_c type changed
!$$$      real df,x_nf,a_f,n_c,h_c,x_ly,r 
  REAL :: df, x_nf, a_f, h_c, x_ly, r
  REAL, DIMENSION(nbdirsmax) :: h_c_fwv
  INTEGER :: n_c
  REAL :: c1
  REAL, DIMENSION(nbdirsmax) :: c1_fwv
  REAL :: weights, points
  REAL :: rs
  REAL, DIMENSION(nbdirsmax) :: rs_fwv
  REAL :: tl, rl, lai
  REAL, DIMENSION(nbdirsmax) :: lai_fwv
  REAL :: ag, bg, cg, dg
  INTEGER :: number, ild
  REAL :: teta(nv), phi(nv)
  REAL :: teta_0, phi_0
!
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, RHO_0_NAD, RHO_1_NAD, RHO_MULT_NAD
  INTEGER :: i, na
  REAL :: i0, xif, xi1u, xi1, ximt
  REAL, DIMENSION(nbdirsmax) :: i0_fwv(nbdirsmax, 21, 40), xif_fwv(&
& nbdirsmax, 21, 40), xi1u_fwv(nbdirsmax, 21, 40), xi1_fwv, ximt_fwv
!
!       COMMON DATAS
!
!     MVO::revised order (alignment-issue after n_c has type integer)
!$$$      common/canopee/df,x_nf,a_f,n_c,h_c,x_ly,r 
  COMMON /canopee/ df, x_nf, a_f, h_c, x_ly, r, n_c
  COMMON /hp/ c1
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /coef/ ag, bg, cg, dg
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  COMMON /angle_sol/ teta_0, phi_0
  INTRINSIC COS
  INTRINSIC ABS
  REAL :: abs0
  REAL :: abs1
  REAL :: result1
  REAL :: result2
  INTEGER :: nd
  INTEGER :: nbdirs
  REAL :: x2
  REAL :: x1
  COMMON /limite_fwv/ xi1_fwv, ximt_fwv
  COMMON /multi_fwv/ i0_fwv, xif_fwv, xi1u_fwv
  COMMON /feuille_fwv/ lai_fwv
  COMMON /sol_fwv/ rs_fwv
  COMMON /hp_fwv/ c1_fwv
  COMMON /canopee_fwv/ h_c_fwv
  DO nd=1,nbdirs
!
!
!--------------------------------------------------
!
!       INPUT PARAMETERS
!
!       teta_0,phi_0            solar angles
!       ild                     leaf distribution
!       R_s                     soil albedo
!       h_c                     height of canopee (m)
!       df                      diameter of a single leaf (m)
!       lai                     leaf area index
!       rl                      leaf reflectance
!       tl                      leaf transmittance
!       na                      number of viewing angle
!       teta(i),phi(i)          viewing angles
!---------------------------------------------------------
!
!       INPUT PARAMETERS <------ ROUTINE
!
    lai_fwv(nd) = xlai_fwv(nd)
    h_c_fwv(nd) = xhc_fwv(nd)
    rs_fwv(nd) = xrs_fwv(nd)
  END DO
  lai = xlai
  h_c = xhc
  df = rpl*2.
  ild = lad
  rl = xrl
  tl = xtl
  rs = xrs
  na = nv
!**************************************************
!
!       DEGREES ---> RADIANS
!
  teta_0 = (180.-theta_i)*pi/180.
  phi_0 = phi_i*pi/180.
  DO i=1,na
    teta(i) = theta_v(i)*pi/180.
    phi(i) = phi_v(i)*pi/180.
  END DO
!
!****************************************************
!
!       CALL SUBROUTINES WRITTING IN NADIMTOOLS.f
!
!***************************************************
!
!       16 GAUSS POINTS and WEIGHTS
!       to compute numerical integrals
!       and discrete ordinates methods
!
!
  number = 16
  CALL GAULEG(-1., 1., points, weights, number)
!---------------------------------------------  
!
!      COEFFICIENTS FUNCTIONS OF DISTRIBUTION BUNNIK
!
!       (leaf angle distribution functions)
!
  CALL BUNNIK(ild)
!
!---------------------------------------------
!
!       GEOMETRIE CANOPY
!
  CALL ARCHI_FWV(lai, lai_fwv, teta_0, nbdirs)
!---------------------------------------------  
!
!       MULTIPLE INTENSITIES FOR ANGULAR POINTS GAUSS
!
!
  CALL MULTIPLE_DOM_FWV(teta_0, nbdirs)
!
!-----------------------------------------------
  DO i=1,na
    x1 = COS(teta_0)
    IF (x1 .GE. 0.) THEN
      abs0 = x1
    ELSE
      abs0 = -x1
    END IF
    x2 = COS(teta(i))
    IF (x2 .GE. 0.) THEN
      abs1 = x2
    ELSE
      abs1 = -x2
    END IF
    result1 = G_ROSS(teta_0)
    result2 = G_ROSS(teta(i))
    x_lambda_i = 0.01*abs0/result1*abs1/result2
!
!   the three orders brdf   
!
    CALL RHO_0_NAD_FWV0(teta(i), phi(i), x_lambda_i, r1, r1_fwv, nbdirs)
    CALL RHO_1_NAD_FWV0(teta(i), phi(i), x_lambda_i, r2, r2_fwv, nbdirs)
    CALL RHO_MULT_NAD_FWV0(teta(i), r3, r3_fwv, nbdirs)
    DO nd=1,nbdirs
!
! so the sum ..to have the brdf total.
!
      xmeas_fwv(nd) = r3_fwv(nd) + r1_fwv(nd) + r2_fwv(nd)
      brf_fwv(nd, i) = xmeas_fwv(nd)
    END DO
    xmeas = r3 + r1 + r2
    brf(i) = xmeas
  END DO
  RETURN
END SUBROUTINE NADIMBRF_FWV
!
!
!

!  Differentiation of rho_0_nad in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: rho_0_nad
!   with respect to varying inputs: c1 rs lai
!**********************************************************
! nadimtools.f
!***********************************************************
!                                                          *
! This file (nadimtools.f) contains all routines and       * 
! functions used in the nadimbrf.f                         *    
!                                                          *    
!***********************************************************
!
! This function computes the "zero order" of scattering by the soil: 
! The downward radiation scattered once by the soil only.
!
SUBROUTINE RHO_0_NAD_FWV0(teta_e, phi_e, x_lambda_i, rho_0_nad, &
& rho_0_nad_fwv, nbdirs)
  IMPLICIT NONE
  INCLUDE 'DIFFSIZES.inc'
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x_lambda_i
  REAL :: teta_e, phi_e
  REAL :: ki, ke, xs1, xs2, rs_d
  REAL, DIMENSION(nbdirsmax) :: xs2_fwv
  REAL :: xh_p, xli
  REAL, DIMENSION(nbdirsmax) :: xh_p_fwv, xli_fwv
  REAL :: c1
  REAL, DIMENSION(nbdirsmax) :: c1_fwv
  REAL :: rs
  REAL, DIMENSION(nbdirsmax) :: rs_fwv
  REAL :: tl, rl, lai
  REAL, DIMENSION(nbdirsmax) :: lai_fwv
  INTEGER :: number, ild
  REAL :: teta_0, phi_0
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, GEO, HOT_SPOT
  INTEGER :: i, n_c
  REAL :: xg1, xg2
!
  COMMON /hp/ c1
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /i/ number, ild
  COMMON /angle_sol/ teta_0, phi_0
  INTRINSIC INT
  INTRINSIC COS
  INTRINSIC ABS
  REAL :: abs0
  REAL :: arg1
  REAL :: pwx1
  REAL :: result1
  INTEGER :: nd
  REAL :: rho_0_nad_fwv(nbdirsmax)
  REAL :: rho_0_nad
  INTEGER :: nbdirs
  REAL :: x1
  COMMON /feuille_fwv/ lai_fwv
  COMMON /sol_fwv/ rs_fwv
  COMMON /hp_fwv/ c1_fwv
!
  arg1 = lai/x_lambda_i
  n_c = INT(arg1)
  xg1 = G_ROSS(teta_0)
  xg2 = G_ROSS(teta_e)
  x1 = COS(teta_0)
  IF (x1 .GE. 0.) THEN
    abs0 = x1
  ELSE
    abs0 = -x1
  END IF
  ki = xg1/abs0
  ke = xg2/COS(teta_e)
  pwx1 = 1. - x_lambda_i*ki
  xs1 = pwx1**n_c
  xs2 = 1.
  result1 = GEO(teta_e, teta_0, phi_e, phi_0)
  DO nd=1,nbdirs
    xli_fwv(nd) = c1_fwv(nd)/result1
  END DO
  xli = c1/result1
!
!  actual optical path to account for the hot-spot effect
!
  CALL HOT_SPOT_FWV0(lai, lai_fwv, xli, xli_fwv, xh_p, xh_p_fwv, nbdirs)
  DO nd=1,nbdirs
    xs2_fwv(nd) = 0.D0
  END DO
!
  DO i=1,n_c
    DO nd=1,nbdirs
      xs2_fwv(nd) = xs2_fwv(nd)*(1.-x_lambda_i*ke*xh_p) - xs2*x_lambda_i&
&       *ke*xh_p_fwv(nd)
    END DO
    xs2 = xs2*(1.-x_lambda_i*ke*xh_p)
  END DO
  DO nd=1,nbdirs
    rho_0_nad_fwv(nd) = xs1*(rs_fwv(nd)*xs2+rs*xs2_fwv(nd))
  END DO
  rho_0_nad = rs*xs2*xs1
  RETURN
END SUBROUTINE RHO_0_NAD_FWV0

!  Differentiation of rho_1_nad in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: rho_1_nad
!   with respect to varying inputs: c1
!*****************************************************
!
! This function computes the "one order" of scattering by the leaves only
!
! 
! 
SUBROUTINE RHO_1_NAD_FWV0(teta_e, phi_e, x_lambda_i, rho_1_nad, &
& rho_1_nad_fwv, nbdirs)
  IMPLICIT NONE
  INCLUDE 'DIFFSIZES.inc'
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x_lambda_i
  REAL :: teta_e, phi_e
  REAL :: xli
  REAL, DIMENSION(nbdirsmax) :: xli_fwv
  REAL :: ki, ke, xga, xc1, rc_d
  REAL :: xg1, xg2, sum, x_hp, xl
  REAL, DIMENSION(nbdirsmax) :: sum_fwv, x_hp_fwv, xl_fwv
  REAL :: c1
  REAL, DIMENSION(nbdirsmax) :: c1_fwv
  REAL :: tl, rl, lai
  REAL, DIMENSION(nbdirsmax) :: lai_fwv
  INTEGER :: number, ild
  REAL :: teta_0, phi_0
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, GEO, HOT_SPOT, GAMMA_LEAF
  INTEGER :: k, n_c
!
  COMMON /hp/ c1
  COMMON /feuille/ tl, rl, lai
  COMMON /i/ number, ild
  COMMON /angle_sol/ teta_0, phi_0
  INTRINSIC INT
  INTRINSIC COS
  INTRINSIC ABS
  REAL :: abs0
  REAL :: abs1
  REAL :: arg1
  REAL :: result1
  REAL :: pwr1
  REAL :: pwx2
  REAL, DIMENSION(nbdirsmax) :: pwx2_fwv
  REAL :: pwr2
  REAL, DIMENSION(nbdirsmax) :: pwr2_fwv
  INTEGER :: nd
  REAL :: rho_1_nad
  REAL :: rho_1_nad_fwv(nbdirsmax)
  INTEGER :: nbdirs
  REAL :: x2
  REAL :: x1
  COMMON /feuille_fwv/ lai_fwv
  COMMON /hp_fwv/ c1_fwv
!
  arg1 = lai/x_lambda_i
  n_c = INT(arg1)
  xg1 = G_ROSS(teta_0)
  xg2 = G_ROSS(teta_e)
  x1 = COS(teta_0)
  IF (x1 .GE. 0.) THEN
    abs0 = x1
  ELSE
    abs0 = -x1
  END IF
  ki = xg1/abs0
  ke = xg2/COS(teta_e)
!
!  3D phase function
!
  xga = GAMMA_LEAF(teta_0, phi_0, teta_e, phi_e)
  xc1 = 1. - x_lambda_i*ki
  result1 = GEO(teta_e, teta_0, phi_e, phi_0)
  DO nd=1,nbdirs
    xli_fwv(nd) = c1_fwv(nd)/result1
  END DO
  xli = c1/result1
  sum = 0.
  DO nd=1,nbdirs
    sum_fwv(nd) = 0.D0
  END DO
  DO k=1,n_c
    xl = x_lambda_i*k
    DO nd=1,nbdirs
      xl_fwv(nd) = 0.D0
    END DO
    CALL HOT_SPOT_FWV0(xl, xl_fwv, xli, xli_fwv, x_hp, x_hp_fwv, nbdirs)
    pwr1 = xc1**k
    pwx2 = 1. - x_lambda_i*ke*x_hp
    DO nd=1,nbdirs
      pwx2_fwv(nd) = -(x_lambda_i*ke*x_hp_fwv(nd))
      IF (pwx2 .GT. 0.D0 .OR. (pwx2 .LT. 0.D0 .AND. k .EQ. INT(k))) THEN
        pwr2_fwv(nd) = k*pwx2**(k-1)*pwx2_fwv(nd)
      ELSE IF (pwx2 .EQ. 0.D0 .AND. k .EQ. 1.0) THEN
        pwr2_fwv(nd) = pwx2_fwv(nd)
      ELSE
        pwr2_fwv(nd) = 0.D0
      END IF
      sum_fwv(nd) = sum_fwv(nd) + pwr1*x_lambda_i*pwr2_fwv(nd)
    END DO
    pwr2 = pwx2**k
    sum = sum + pwr1*x_lambda_i*pwr2
  END DO
  x2 = COS(teta_0)
  IF (x2 .GE. 0.) THEN
    abs1 = x2
  ELSE
    abs1 = -x2
  END IF
  DO nd=1,nbdirs
    rho_1_nad_fwv(nd) = xga*sum_fwv(nd)/(COS(teta_e)*abs1)
  END DO
  rho_1_nad = sum/(COS(teta_e)*abs1)*xga
  RETURN
END SUBROUTINE RHO_1_NAD_FWV0

!  Differentiation of hot_spot in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: hot_spot
!   with respect to varying inputs: x xli
!
!********************************************************
!
! HOT_SPOT FUNCTION (after Verstraete et al)
!
SUBROUTINE HOT_SPOT_FWV0(x, x_fwv, xli, xli_fwv, hot_spot, hot_spot_fwv&
& , nbdirs)
  IMPLICIT NONE
  INCLUDE 'DIFFSIZES.inc'
!  Hint: nbdirsmax should be the maximum number of differentiation directions
!     MVO-ADDED-TYPE-DECLARATION
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x, xli
  REAL, DIMENSION(nbdirsmax) :: x_fwv, xli_fwv
  INTEGER :: nd
  REAL :: hot_spot_fwv(nbdirsmax)
  REAL :: hot_spot
  INTEGER :: nbdirs
  IF (x .LT. xli) THEN
    DO nd=1,nbdirs
      hot_spot_fwv(nd) = ((1.-4./(3.*pi))*x_fwv(nd)*xli-(1.-4./(3.*pi))*&
&       x*xli_fwv(nd))/xli**2
    END DO
    hot_spot = (1.-4./(3.*pi))*x/xli
  ELSE
    DO nd=1,nbdirs
      hot_spot_fwv(nd) = -((4.*xli_fwv(nd)*x/(3.*pi)-4.*xli*x_fwv(nd)/(&
&       3.*pi))/x**2)
    END DO
    hot_spot = 1. - 4./(3.*pi)*xli/x
  END IF
  RETURN
END SUBROUTINE HOT_SPOT_FWV0

!  Differentiation of rho_mult_nad in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: rho_mult_nad
!   with respect to varying inputs: lai i0 xif xi1u xi1 ximt
!***************************************************
!
! This function computes the multiple scattering term 
! averaged in azimuth. 
!       
SUBROUTINE RHO_MULT_NAD_FWV0(teta_u, rho_mult_nad, rho_mult_nad_fwv, &
& nbdirs)
  IMPLICIT NONE
  INCLUDE 'DIFFSIZES.inc'
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
!     MVO::turn m into integer
!$$$      real xmu0,xm,xr,mu,Gu,xIm(21),m,dL
  REAL :: xmu0, xm, xr, mu, gu, xim(21), dl
  REAL :: xim_fwv(nbdirsmax, 21), dl_fwv(nbdirsmax)
  INTEGER :: m
  REAL :: g0, teta_u, sum, sum1, sum2, x
  REAL, DIMENSION(nbdirsmax) :: sum_fwv, sum1_fwv, sum2_fwv
  REAL :: xsu(21), xq0u(21), xq1(21), xgama_u(40)
  REAL :: xsu_fwv(nbdirsmax, 21), xq0u_fwv(nbdirsmax, 21), xq1_fwv(&
& nbdirsmax, 21)
  REAL :: fpar_tur, alb_tur, tr_tur, tr_dir, tran
  REAL :: weights, points
  REAL :: rs
  REAL, DIMENSION(nbdirsmax) :: rs_fwv
  REAL :: tl, rl, lai
  REAL, DIMENSION(nbdirsmax) :: lai_fwv
  INTEGER :: number, ild
  REAL :: i0, xif, xi1u
  REAL, DIMENSION(nbdirsmax, 21, 40) :: i0_fwv, xif_fwv, xi1u_fwv
  REAL :: xi1, ximt
  REAL, DIMENSION(nbdirsmax) :: xi1_fwv, ximt_fwv
  REAL :: teta_0, phi_0
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, FASE_LEAF
  INTEGER :: i, j, k
  REAL :: aa, bb, s1
  REAL, DIMENSION(nbdirsmax) :: aa_fwv, bb_fwv, s1_fwv
!
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  COMMON /angle_sol/ teta_0, phi_0
  INTRINSIC COS
  INTRINSIC ABS
  INTRINSIC ACOS
  REAL :: abs0
  REAL :: result1
  INTEGER :: nd
  INTEGER :: ii1
  REAL :: rho_mult_nad
  REAL :: rho_mult_nad_fwv(nbdirsmax)
  INTEGER :: nbdirs
  REAL :: x2
  REAL :: x1
  COMMON /limite_fwv/ xi1_fwv, ximt_fwv
  COMMON /multi_fwv/ i0_fwv, xif_fwv, xi1u_fwv
  COMMON /feuille_fwv/ lai_fwv
  COMMON /sol_fwv/ rs_fwv
!
!
  DO i=1,21
    j = 21
  END DO
  x1 = COS(teta_0)
  IF (x1 .GE. 0.) THEN
    xmu0 = x1
  ELSE
    xmu0 = -x1
  END IF
  m = 20
  DO nd=1,nbdirs
    dl_fwv(nd) = lai_fwv(nd)/m
  END DO
  dl = lai/m
  g0 = G_ROSS(teta_0)
  xm = 0.5*(1.-1.)
  xr = 0.5*(1.+1.)
!
!       GAMMA (TETA(J) --> TETA_U)
!
  DO j=1,number
    x = xm + xr*points(j)
    result1 = ACOS(x)
    xgama_u(j) = FASE_LEAF(result1, teta_u)
  END DO
  DO nd=1,nbdirs
    DO ii1=1,21
      xsu_fwv(nd, ii1) = 0.D0
    END DO
  END DO
!
!
!       MULTIPLE SOURCE S(K) FOR VIEWING ANGLE = TETA_U
!           
!
  DO k=1,m
    sum = 0.
    DO nd=1,nbdirs
      sum_fwv(nd) = 0.D0
    END DO
    DO j=1,number
      x = xm + xr*points(j)
      DO nd=1,nbdirs
        sum_fwv(nd) = sum_fwv(nd) + 2.*xgama_u(j)*xr*weights(j)*(xif_fwv&
&         (nd, k+1, j)+xif_fwv(nd, k, j))/2.
      END DO
      sum = sum + 2.*xgama_u(j)*xr*weights(j)*(xif(k+1, j)+xif(k, j))/2.
    END DO
    DO nd=1,nbdirs
      xsu_fwv(nd, k) = sum_fwv(nd)
    END DO
    xsu(k) = sum
  END DO
  DO nd=1,nbdirs
    DO ii1=1,21
      xq0u_fwv(nd, ii1) = 0.D0
    END DO
  END DO
!
!
!       ZERO ORDER SOURCE
!
!
  DO k=m,1,-1
    sum1 = 0.
    DO nd=1,nbdirs
      sum1_fwv(nd) = 0.D0
    END DO
    DO j=number/2+1,number
      x = xm + xr*points(j)
      DO nd=1,nbdirs
        sum1_fwv(nd) = sum1_fwv(nd) + weights(j)*xr*2.*xgama_u(j)*(&
&         i0_fwv(nd, k+1, j)+i0_fwv(nd, k, j))/2.
      END DO
      sum1 = sum1 + weights(j)*xr*2.*xgama_u(j)*(i0(k+1, j)+i0(k, j))/2.
    END DO
    DO nd=1,nbdirs
      xq0u_fwv(nd, k) = sum1_fwv(nd)
    END DO
    xq0u(k) = sum1
  END DO
  DO nd=1,nbdirs
    DO ii1=1,21
      xq1_fwv(nd, ii1) = 0.D0
    END DO
  END DO
!
! FIRST ORDER SOURCE
!
  DO k=1,m
    sum2 = 0.
    DO nd=1,nbdirs
      sum2_fwv(nd) = 0.D0
    END DO
    DO j=1,number
      x = xm + xr*points(j)
      DO nd=1,nbdirs
        sum2_fwv(nd) = sum2_fwv(nd) + 2.*xgama_u(j)*xr*weights(j)*(&
&         xi1u_fwv(nd, k+1, j)+xi1u_fwv(nd, k, j))/2.
      END DO
      sum2 = sum2 + 2.*xgama_u(j)*xr*weights(j)*(xi1u(k+1, j)+xi1u(k, j)&
&       )/2.
    END DO
    DO nd=1,nbdirs
      xq1_fwv(nd, k) = sum2_fwv(nd)
    END DO
    xq1(k) = sum2
  END DO
!
  gu = G_ROSS(teta_u)
  mu = COS(teta_u)
  DO nd=1,nbdirs
    DO ii1=1,21
      xim_fwv(nd, ii1) = 0.D0
    END DO
    xim_fwv(nd, m+1) = ximt_fwv(nd) + xi1_fwv(nd)
  END DO
  xim(m+1) = ximt + xi1
  DO k=m,1,-1
    s1 = xsu(k) + xq1(k) + xq0u(k)
    aa = gu/2. - mu/dl
    bb = gu/2. + mu/dl
    DO nd=1,nbdirs
      s1_fwv(nd) = xsu_fwv(nd, k) + xq1_fwv(nd, k) + xq0u_fwv(nd, k)
      aa_fwv(nd) = mu*dl_fwv(nd)/dl**2
      bb_fwv(nd) = -(mu*dl_fwv(nd)/dl**2)
      xim_fwv(nd, k) = ((s1_fwv(nd)-xim_fwv(nd, k+1)*aa-xim(k+1)*aa_fwv(&
&       nd))*bb-(s1-xim(k+1)*aa)*bb_fwv(nd))/bb**2
    END DO
    xim(k) = (s1-xim(k+1)*aa)/bb
  END DO
  x2 = COS(teta_0)
  IF (x2 .GE. 0.) THEN
    abs0 = x2
  ELSE
    abs0 = -x2
  END IF
  DO nd=1,nbdirs
    rho_mult_nad_fwv(nd) = xim_fwv(nd, 1)/(2.*abs0)
  END DO
  rho_mult_nad = xim(1)/(2.*abs0)
  RETURN
END SUBROUTINE RHO_MULT_NAD_FWV0

!  Differentiation of archi in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: c1
!   with respect to varying inputs: h_c x_lai
!**********************************************************
!**********************************************************
!
!       SUBROUTINES
!
!*********************************************************
!*********************************************************
!
!       GEOMETRY OD THE VEGETATION CANOPY AND
!       COMPUTATION OF THE HOT-SPOT PARAMETER   
!
SUBROUTINE ARCHI_FWV(x_lai, x_lai_fwv, teta_s, nbdirs)
  IMPLICIT NONE
  INCLUDE 'DIFFSIZES.inc'
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x_lai, teta_s
  REAL, DIMENSION(nbdirsmax) :: x_lai_fwv
  REAL :: weights, points
  REAL :: tl, rl, lai, rs
  REAL, DIMENSION(nbdirsmax) :: lai_fwv, rs_fwv
  REAL :: ag, bg, cg, dg
  REAL :: teta_0, phi_0
  INTEGER :: number, ild
  REAL :: c1
  REAL, DIMENSION(nbdirsmax) :: c1_fwv
  REAL :: i0, xif, xi1u, xi1, ximt
  REAL, DIMENSION(nbdirsmax) :: i0_fwv(nbdirsmax, 21, 40), xif_fwv(&
& nbdirsmax, 21, 40), xi1u_fwv(nbdirsmax, 21, 40), xi1_fwv, ximt_fwv
  REAL :: x_nf, a_f, h_c, x_ly, r
  REAL, DIMENSION(nbdirsmax) :: h_c_fwv
!     MVO::added type declarations
  REAL, EXTERNAL :: DEEP, SUN_FLECK
  REAL :: df
  INTEGER :: n_c
!     MVO::revised order (alignment-issue after n_c has type integer)
!$$$      common/canopee/df,x_nf,a_f,n_c,h_c,x_ly,r 
  COMMON /canopee/ df, x_nf, a_f, h_c, x_ly, r, n_c
  COMMON /hp/ c1
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /coef/ ag, bg, cg, dg
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  COMMON /angle_sol/ teta_0, phi_0
  INTEGER :: nd
  INTEGER :: nbdirs
  COMMON /limite_fwv/ xi1_fwv, ximt_fwv
  COMMON /multi_fwv/ i0_fwv, xif_fwv, xi1u_fwv
  COMMON /feuille_fwv/ lai_fwv
  COMMON /sol_fwv/ rs_fwv
  COMMON /hp_fwv/ c1_fwv
  COMMON /canopee_fwv/ h_c_fwv
  a_f = (df/2.)**2*pi
  x_nf = x_lai/(a_f*h_c)
  x_ly = DEEP(teta_s)
  r = SUN_FLECK(teta_s)
  DO nd=1,nbdirs
    c1_fwv(nd) = (2.*r*x_lai_fwv(nd)*h_c-2.*r*x_lai*h_c_fwv(nd))/h_c**2
  END DO
  c1 = 2.*r*x_lai/h_c
  RETURN
END SUBROUTINE ARCHI_FWV

!  Differentiation of multiple_dom in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: i0 xif xi1u xi1 ximt
!   with respect to varying inputs: rs lai i0 xif xi1u
!
!*********************************************************
!
!       MULTIPLE SCATTERING INTENSITIES IN THE DIRECTION
!       CORRESPONDING TO THE GAUSS QUADRATURE.
!       
! 
SUBROUTINE MULTIPLE_DOM_FWV(teta_0, nbdirs)
  IMPLICIT NONE
  INCLUDE 'DIFFSIZES.inc'
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: weights, points
  REAL :: tl, rl, lai, rs
  REAL, DIMENSION(nbdirsmax) :: lai_fwv, rs_fwv
  REAL :: ag, bg, cg, dg
  REAL :: teta_0
  INTEGER :: number
  REAL :: i0, xif, xi1u, xi1, ximt
  REAL, DIMENSION(nbdirsmax) :: i0_fwv(nbdirsmax, 21, 40), xif_fwv(&
& nbdirsmax, 21, 40), xi1u_fwv(nbdirsmax, 21, 40), xi1_fwv, ximt_fwv
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, FASE_LEAF
  REAL :: dl, sum, xl, xnn, y
  REAL, DIMENSION(nbdirsmax) :: dl_fwv, sum_fwv, xl_fwv
  INTEGER :: i, j, k, l, m, nt, ild
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /coef/ ag, bg, cg, dg
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  REAL :: xmu0, g0, xm, xr, x
  REAL :: gg(40), s(21, 40)
  REAL :: s_fwv(nbdirsmax, 21, 40)
  REAL :: q0m(21, 40), xi(21, 40)
  REAL :: q0m_fwv(nbdirsmax, 21, 40), xi_fwv(nbdirsmax, 21, 40)
  REAL :: q1(21, 40), xgama_xy(40, 40), xgama_0(40)
  REAL :: q1_fwv(nbdirsmax, 21, 40)
  REAL :: i00
  INTRINSIC COS
  INTRINSIC ABS
  INTRINSIC FLOAT
  INTRINSIC ACOS
  INTRINSIC MIN
  INTRINSIC EXP
  INTEGER :: min1
  REAL :: abs0
  REAL :: abs1
  REAL :: abs2
  REAL :: abs3
  REAL :: abs4
  REAL :: abs5
  REAL :: abs6
  REAL :: abs7
  REAL :: result1
  REAL :: arg1
  REAL, DIMENSION(nbdirsmax) :: arg1_fwv
  REAL :: arg2
  REAL, DIMENSION(nbdirsmax) :: arg2_fwv
  REAL :: result2
  REAL :: arg3
  REAL, DIMENSION(nbdirsmax) :: arg3_fwv
  INTEGER :: nd
  INTEGER :: ii2
  INTEGER :: ii1
  INTEGER :: nbdirs
  REAL :: x1
  COMMON /limite_fwv/ xi1_fwv, ximt_fwv
  COMMON /multi_fwv/ i0_fwv, xif_fwv, xi1u_fwv
  COMMON /feuille_fwv/ lai_fwv
  COMMON /sol_fwv/ rs_fwv
  x1 = COS(teta_0)
  IF (x1 .GE. 0.) THEN
    xmu0 = x1
  ELSE
    xmu0 = -x1
  END IF
  m = 20
  DO nd=1,nbdirs
    dl_fwv(nd) = lai_fwv(nd)/FLOAT(m)
  END DO
  dl = lai/FLOAT(m)
  g0 = G_ROSS(teta_0)
  xm = 0.5*(1.+(-1.))
  xr = 0.5*(1.-(-1.))
!
  i00 = 1.
!
! Computation of the G-function
!
  DO j=1,number
    x = xm + xr*points(j)
    result1 = ACOS(x)
    gg(j) = G_ROSS(result1)
  END DO
  IF (m + 1 .GT. 21) THEN
    min1 = 21
  ELSE
    min1 = m + 1
  END IF
!
! INITIALIZATION OF SOURCES AND INTENSITIES = 0
!
!     MVO/TXK fixed:xIf(m+1,?) will be accessed later and *must*
!     be initialised (21 is the size of first dimension in the declaraion)
  DO k=1,min1
    DO j=1,number
      s(k, j) = 0.
      DO nd=1,nbdirs
        xif_fwv(nd, k, j) = 0.D0
      END DO
      xif(k, j) = 0.
    END DO
  END DO
!
! COMPUTATION OF THE UNCOLLIDED INTENSITIES
!
  DO k=1,m+1
    DO nd=1,nbdirs
      xl_fwv(nd) = FLOAT(k-1)*dl_fwv(nd)
    END DO
    xl = FLOAT(k-1)*dl
    DO i=1,number/2
      x = xm + xr*points(i)
      IF (x .GE. 0.) THEN
        abs0 = x
      ELSE
        abs0 = -x
      END IF
      IF (abs0 .EQ. xmu0) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
        arg1 = -(g0/xmu0*xl)
        DO nd=1,nbdirs
          arg1_fwv(nd) = -(g0*xl_fwv(nd)/xmu0)
          i0_fwv(nd, k, i) = i00*arg1_fwv(nd)*EXP(arg1)
        END DO
        i0(k, i) = i00*EXP(arg1)
      ELSE
        DO nd=1,nbdirs
          i0_fwv(nd, k, i) = 0.D0
        END DO
        i0(k, i) = 0.
      END IF
    END DO
  END DO
!
  DO k=m+1,1,-1
    DO nd=1,nbdirs
      xl_fwv(nd) = FLOAT(k-1)*dl_fwv(nd)
    END DO
    xl = FLOAT(k-1)*dl
    DO i=number/2+1,number
      x = xm + xr*points(i)
      arg1 = -(g0/xmu0*lai)
      arg2 = -(gg(i)/x*(lai-xl))
      DO nd=1,nbdirs
        arg1_fwv(nd) = -(g0*lai_fwv(nd)/xmu0)
        arg2_fwv(nd) = -(gg(i)*(lai_fwv(nd)-xl_fwv(nd))/x)
        i0_fwv(nd, k, i) = 2.*i00*xmu0*((rs_fwv(nd)*EXP(arg1)+rs*&
&         arg1_fwv(nd)*EXP(arg1))*EXP(arg2)+rs*EXP(arg1)*arg2_fwv(nd)*&
&         EXP(arg2))
      END DO
      i0(k, i) = 2.*rs*i00*xmu0*EXP(arg1)*EXP(arg2)
    END DO
  END DO
!       
! TABLE OF 2-D PHASE FUNCTION FOR the GAUSS QUADRATURE ANGLES
!
  DO i=1,number
    y = xm + xr*points(i)
    DO j=1,number
      x = xm + xr*points(j)
      result1 = ACOS(x)
      result2 = ACOS(y)
      xgama_xy(i, j) = FASE_LEAF(result1, result2)
    END DO
  END DO
  DO nd=1,nbdirs
    DO ii1=1,40
      DO ii2=1,21
        q0m_fwv(nd, ii2, ii1) = 0.D0
      END DO
    END DO
  END DO
!
! COMPUTATION OF THE ZERO ORDER SOURCE
!
  DO k=m,1,-1
    DO i=1,number
      y = xm + xr*points(i)
      sum = 0.
      DO nd=1,nbdirs
        sum_fwv(nd) = 0.D0
      END DO
      DO j=number/2+1,number
        x = xm + xr*points(j)
        DO nd=1,nbdirs
          sum_fwv(nd) = sum_fwv(nd) + weights(j)*xr*2.*xgama_xy(i, j)*(&
&           i0_fwv(nd, k+1, j)+i0_fwv(nd, k, j))/2.
        END DO
        sum = sum + weights(j)*xr*2.*xgama_xy(i, j)*(i0(k+1, j)+i0(k, j)&
&         )/2.
      END DO
      DO nd=1,nbdirs
        q0m_fwv(nd, k, i) = sum_fwv(nd)
      END DO
      q0m(k, i) = sum
    END DO
  END DO
!
! TABLE OF 2-D PHASE FUNCTION FOR ILLUMINATION --> QUADRATURE ANGLES
!       
  DO i=1,number
    x = xm + xr*points(i)
    result1 = ACOS(x)
    xgama_0(i) = FASE_LEAF(teta_0, result1)
  END DO
  DO nd=1,nbdirs
    DO ii1=1,40
      DO ii2=1,21
        xi_fwv(nd, ii2, ii1) = 0.D0
      END DO
    END DO
  END DO
!
! COMPUTATIONS OF THE FIRST ORDER INTENSITIES
!
  DO k=1,m+1
    DO nd=1,nbdirs
      xl_fwv(nd) = FLOAT(k-1)*dl_fwv(nd)
    END DO
    xl = FLOAT(k-1)*dl
    DO j=1,number/2
      x = xm + xr*points(j)
      IF (x .GE. 0.) THEN
        abs1 = x
      ELSE
        abs1 = -x
      END IF
      IF (abs1 .NE. xmu0) THEN
! TAPENADE: (TC19) Equality test on reals is not reliable
        IF (x .GE. 0.) THEN
          abs2 = x
        ELSE
          abs2 = -x
        END IF
        IF (x .GE. 0.) THEN
          abs6 = x
        ELSE
          abs6 = -x
        END IF
        arg1 = -(g0/xmu0*xl)
        arg2 = -(gg(j)/abs2*xl)
        DO nd=1,nbdirs
          arg1_fwv(nd) = -(g0*xl_fwv(nd)/xmu0)
          arg2_fwv(nd) = -(gg(j)*xl_fwv(nd)/abs2)
          xi_fwv(nd, k, j) = i00*2.*xgama_0(j)*xmu0*(arg1_fwv(nd)*EXP(&
&           arg1)-arg2_fwv(nd)*EXP(arg2))/(gg(j)*xmu0-g0*abs6)
        END DO
        xi(k, j) = i00*2.*xgama_0(j)*xmu0*(EXP(arg1)-EXP(arg2))/(gg(j)*&
&         xmu0-g0*abs6)
        IF (x .GE. 0.) THEN
          abs3 = x
        ELSE
          abs3 = -x
        END IF
        IF (x .GE. 0.) THEN
          abs7 = x
        ELSE
          abs7 = -x
        END IF
        arg1 = -(g0/xmu0*xl)
        arg2 = -(gg(j)/abs3*xl)
        DO nd=1,nbdirs
          arg1_fwv(nd) = -(g0*xl_fwv(nd)/xmu0)
          arg2_fwv(nd) = -(gg(j)*xl_fwv(nd)/abs3)
          xi1u_fwv(nd, k, j) = i00*2.*xgama_0(j)*xmu0*(arg1_fwv(nd)*EXP(&
&           arg1)-arg2_fwv(nd)*EXP(arg2))/(gg(j)*xmu0-g0*abs7)
        END DO
        xi1u(k, j) = i00*2.*xgama_0(j)*xmu0*(EXP(arg1)-EXP(arg2))/(gg(j)&
&         *xmu0-g0*abs7)
      ELSE
        arg1 = -(g0/xmu0*xl)
        DO nd=1,nbdirs
          arg1_fwv(nd) = -(g0*xl_fwv(nd)/xmu0)
          xi_fwv(nd, k, j) = i00*2.*xgama_0(j)*(xl_fwv(nd)*EXP(arg1)+xl*&
&           arg1_fwv(nd)*EXP(arg1))/xmu0
          arg1_fwv(nd) = -(g0*xl_fwv(nd)/xmu0)
        END DO
        xi(k, j) = i00*xl*2.*xgama_0(j)*EXP(arg1)/xmu0
        arg1 = -(g0/xmu0*xl)
        DO nd=1,nbdirs
          xi1u_fwv(nd, k, j) = i00*2.*xgama_0(j)*(xl_fwv(nd)*EXP(arg1)+&
&           xl*arg1_fwv(nd)*EXP(arg1))/xmu0
        END DO
        xi1u(k, j) = i00*xl*2.*xgama_0(j)*EXP(arg1)/xmu0
      END IF
    END DO
  END DO
!
  xi1 = 0.
  DO nd=1,nbdirs
    xi1_fwv(nd) = 0.D0
  END DO
  DO j=1,number/2
    x = xm + xr*points(j)
    IF (x .GE. 0.) THEN
      abs4 = x
    ELSE
      abs4 = -x
    END IF
    DO nd=1,nbdirs
      xi1_fwv(nd) = xi1_fwv(nd) + weights(j)*xr*abs4*2.*(rs_fwv(nd)*xi(m&
&       +1, j)+rs*xi_fwv(nd, m+1, j))
    END DO
    xi1 = xi1 + weights(j)*xr*abs4*2.*rs*xi(m+1, j)
  END DO
!
  DO k=m+1,1,-1
    DO nd=1,nbdirs
      xl_fwv(nd) = FLOAT(k-1)*dl_fwv(nd)
    END DO
    xl = FLOAT(k-1)*dl
    DO j=number/2+1,number
      x = xm + xr*points(j)
      arg1 = -(g0/xmu0*xl)
      arg2 = -(gg(j)/x*(lai-xl))
      arg3 = -(g0/xmu0*lai)
      DO nd=1,nbdirs
        arg1_fwv(nd) = -(g0*xl_fwv(nd)/xmu0)
        arg2_fwv(nd) = -(gg(j)*(lai_fwv(nd)-xl_fwv(nd))/x)
        arg3_fwv(nd) = -(g0*lai_fwv(nd)/xmu0)
        xi_fwv(nd, k, j) = i00*2.*xgama_0(j)*xmu0*(arg1_fwv(nd)*EXP(arg1&
&         )-arg2_fwv(nd)*EXP(arg2)*EXP(arg3)-EXP(arg2)*arg3_fwv(nd)*EXP(&
&         arg3))/(g0*x+gg(j)*xmu0)
!
        arg1_fwv(nd) = -(g0*xl_fwv(nd)/xmu0)
        arg2_fwv(nd) = -(gg(j)*(lai_fwv(nd)-xl_fwv(nd))/x)
        arg3_fwv(nd) = -(g0*lai_fwv(nd)/xmu0)
      END DO
      xi(k, j) = i00*2.*xgama_0(j)*xmu0*(EXP(arg1)-EXP(arg2)*EXP(arg3))/&
&       (g0*x+gg(j)*xmu0)
      arg1 = -(g0/xmu0*xl)
      arg2 = -(gg(j)/x*(lai-xl))
      arg3 = -(g0/xmu0*lai)
      DO nd=1,nbdirs
        xi1u_fwv(nd, k, j) = i00*2.*xgama_0(j)*xmu0*(arg1_fwv(nd)*EXP(&
&         arg1)-arg2_fwv(nd)*EXP(arg2)*EXP(arg3)-EXP(arg2)*arg3_fwv(nd)*&
&         EXP(arg3))/(g0*x+gg(j)*xmu0)
      END DO
      xi1u(k, j) = i00*2.*xgama_0(j)*xmu0*(EXP(arg1)-EXP(arg2)*EXP(arg3)&
&       )/(g0*x+gg(j)*xmu0)
    END DO
  END DO
  DO j=number/2+1,number
    DO nd=1,nbdirs
      xi_fwv(nd, m+1, j) = 0.D0
      xi1u_fwv(nd, m+1, j) = 0.D0
    END DO
    xi(m+1, j) = 0.
    xi1u(m+1, j) = 0.
  END DO
  DO nd=1,nbdirs
    DO ii1=1,40
      DO ii2=1,21
        q1_fwv(nd, ii2, ii1) = 0.D0
      END DO
    END DO
  END DO
!
  DO k=1,m
    DO i=1,number
      y = xm + xr*points(i)
      sum = 0.
      DO nd=1,nbdirs
        sum_fwv(nd) = 0.D0
      END DO
      DO j=1,number
        x = xm + xr*points(j)
        DO nd=1,nbdirs
          sum_fwv(nd) = sum_fwv(nd) + weights(j)*xr*2.*xgama_xy(i, j)*(&
&           xi_fwv(nd, k+1, j)+xi_fwv(nd, k, j))/2.
        END DO
        sum = sum + weights(j)*xr*2.*xgama_xy(i, j)*(xi(k+1, j)+xi(k, j)&
&         )/2.
      END DO
      DO nd=1,nbdirs
        q1_fwv(nd, k, i) = sum_fwv(nd)
      END DO
      q1(k, i) = sum
    END DO
  END DO
!
! MULTIPLE INTENSITIES
!
  DO k=1,m+1
    DO j=1,number/2
      DO nd=1,nbdirs
        xi_fwv(nd, k, j) = 0.D0
      END DO
      xi(k, j) = 0.
    END DO
  END DO
  l = 0
  DO nd=1,nbdirs
    DO ii1=1,40
      DO ii2=1,21
        s_fwv(nd, ii2, ii1) = 0.D0
      END DO
    END DO
  END DO
 111 l = l + 1
  DO k=1,m
    DO j=1,number/2
      x = xm + xr*points(j)
      DO nd=1,nbdirs
        xi_fwv(nd, k+1, j) = ((s_fwv(nd, k, j)+q0m_fwv(nd, k, j)+q1_fwv(&
&         nd, k, j)-xi_fwv(nd, k, j)*(gg(j)/2.+x/dl)+xi(k, j)*x*dl_fwv(&
&         nd)/dl**2)*(gg(j)/2.-x/dl)-(s(k, j)+q0m(k, j)+q1(k, j)-xi(k, j&
&         )*(gg(j)/2.+x/dl))*x*dl_fwv(nd)/dl**2)/(gg(j)/2.-x/dl)**2
      END DO
      xi(k+1, j) = (s(k, j)+q0m(k, j)+q1(k, j)-xi(k, j)*(gg(j)/2.+x/dl))&
&       /(gg(j)/2.-x/dl)
    END DO
  END DO
  ximt = 0.
  DO nd=1,nbdirs
    ximt_fwv(nd) = 0.D0
  END DO
  DO j=1,number/2
    x = xm + xr*points(j)
    IF (x .GE. 0.) THEN
      abs5 = x
    ELSE
      abs5 = -x
    END IF
    DO nd=1,nbdirs
      ximt_fwv(nd) = ximt_fwv(nd) + weights(j)*xr*2.*abs5*(rs_fwv(nd)*xi&
&       (m+1, j)+rs*xi_fwv(nd, m+1, j))
    END DO
    ximt = ximt + weights(j)*xr*2.*rs*abs5*xi(m+1, j)
  END DO
  DO j=number/2+1,number
    DO nd=1,nbdirs
      xi_fwv(nd, m+1, j) = ximt_fwv(nd) + xi1_fwv(nd)
    END DO
    xi(m+1, j) = ximt + xi1
  END DO
  DO k=m,1,-1
    DO j=number/2+1,number
      x = xm + xr*points(j)
      DO nd=1,nbdirs
        xi_fwv(nd, k, j) = ((s_fwv(nd, k, j)+q0m_fwv(nd, k, j)+q1_fwv(nd&
&         , k, j)-xi_fwv(nd, k+1, j)*(gg(j)/2.-x/dl)-xi(k+1, j)*x*dl_fwv&
&         (nd)/dl**2)*(gg(j)/2.+x/dl)+(s(k, j)+q0m(k, j)+q1(k, j)-xi(k+1&
&         , j)*(gg(j)/2.-x/dl))*x*dl_fwv(nd)/dl**2)/(gg(j)/2.+x/dl)**2
      END DO
      xi(k, j) = (s(k, j)+q0m(k, j)+q1(k, j)-xi(k+1, j)*(gg(j)/2.-x/dl))&
&       /(gg(j)/2.+x/dl)
    END DO
  END DO
!
  nt = 0
  DO k=1,m+1
    DO j=1,number
      IF (xif(k, j) - xi(k, j) .GE. 0.) THEN
        xnn = xif(k, j) - xi(k, j)
      ELSE
        xnn = -(xif(k, j)-xi(k, j))
      END IF
      IF (xnn .LT. 1.e-4) nt = nt + 1
      DO nd=1,nbdirs
        xif_fwv(nd, k, j) = xi_fwv(nd, k, j)
      END DO
      xif(k, j) = xi(k, j)
    END DO
  END DO
!$$$      print*, 'MVMV::debug:l=',l,'nt=',nt,'m=',m,
!$$$     &     '(m+1)*number=',(m+1)*number
!$$$      print*, 'MVMV::goon=',((l.lt.1000).and.(nt.ne.(m+1)*number))
  IF (l .LT. 1000 .AND. nt .NE. (m+1)*number) THEN
!
! MULTIPLE SOURCE 
!
    DO k=1,m
      DO i=1,number
        y = xm + xr*points(i)
        sum = 0.
        DO nd=1,nbdirs
          sum_fwv(nd) = 0.D0
        END DO
        DO j=1,number
          x = xm + xr*points(j)
          DO nd=1,nbdirs
            sum_fwv(nd) = sum_fwv(nd) + weights(j)*xr*2.*xgama_xy(i, j)*&
&             (xi_fwv(nd, k+1, j)+xi_fwv(nd, k, j))/2.
          END DO
          sum = sum + weights(j)*xr*2.*xgama_xy(i, j)*(xi(k+1, j)+xi(k, &
&           j))/2.
        END DO
        DO nd=1,nbdirs
          s_fwv(nd, k, i) = sum_fwv(nd)
        END DO
        s(k, i) = sum
      END DO
    END DO
    GOTO 111
  END IF
  RETURN
END SUBROUTINE MULTIPLE_DOM_FWV

!  Differentiation of convolve in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: convolve
!   with respect to varying inputs: spect1
!***********************************************************
!     convolve
!
!> @brief convolves to spectra
!
!> @details TBD
!
!> @param[in]  nw      length/size of spectra
!> @param[in]  spect1  first spectrum
!> @param[in]  spect2  second spectrum
!
SUBROUTINE CONVOLVE_FWV0(nw, spect1, spect1_fwv, spect2, convolve, &
& convolve_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: nw
  REAL(kind=8), INTENT(IN) :: spect1(nw), spect2(nw)
  REAL(kind=8), INTENT(IN) :: spect1_fwv(nbdirsmax, nw)
! local decls
  REAL(kind=8) :: spect1_dot_spect2, spect2_sum
  REAL(kind=8), DIMENSION(nbdirsmax) :: spect1_dot_spect2_fwv
  INTRINSIC SUM
  REAL(kind=8), DIMENSION(nw) :: arg1
  REAL(kind=8), DIMENSION(nbdirsmax, nw) :: arg1_fwv
  INTEGER :: nd
  REAL(kind=8) :: convolve
  REAL(kind=8) :: convolve_fwv(nbdirsmax)
  INTEGER :: nbdirs
  spect2_sum = SUM(spect2)
  DO nd=1,nbdirs
    arg1_fwv(nd, :) = spect2*spect1_fwv(nd, :)
    spect1_dot_spect2_fwv(nd) = SUM(arg1_fwv(nd, :))
    convolve_fwv(nd) = spect1_dot_spect2_fwv(nd)/spect2_sum
  END DO
  arg1(:) = spect1*spect2
  spect1_dot_spect2 = SUM(arg1(:))
  convolve = spect1_dot_spect2/spect2_sum
END SUBROUTINE CONVOLVE_FWV0

!  Differentiation of sm_to_rsl1 in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: sm_to_rsl1
!   with respect to varying inputs: sm
!***********************************************************
!     sm_to_rsl1
!
!> @brief modulates the weight of first empirical orthogonal function of soil reflectance model (Price 1990) by the soil moisture
!
!> @details TBD
!
!> @param[in]  sm        volumetric soilmoisture (in range [0,1])
!> @param[in]  rsl1      1st spectral vector of soil reflectance (of Price's EOF)
!> @param[in]  sm_coeff  weighting of soil moisture impact, bound between (0,1)
!> \return  weight of first empirical orthogonal function
!
SUBROUTINE SM_TO_RSL1_FWV0(sm, sm_fwv, rsl1, sm_coeff, sm_to_rsl1, &
& sm_to_rsl1_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
  REAL, INTENT(IN) :: sm
  REAL, DIMENSION(nbdirsmax), INTENT(IN) :: sm_fwv
  REAL, INTENT(IN) :: rsl1
  REAL, INTENT(IN) :: sm_coeff
  INTEGER :: nd
  REAL :: sm_to_rsl1_fwv(nbdirsmax)
  REAL :: sm_to_rsl1
  INTEGER :: nbdirs
  DO nd=1,nbdirs
! SM measured volumetric,but not in percent (sm/100))
    sm_to_rsl1_fwv(nd) = -(rsl1*sm_coeff*sm_fwv(nd))
  END DO
  sm_to_rsl1 = rsl1*(1.-sm_coeff*sm)
END SUBROUTINE SM_TO_RSL1_FWV0

!  Differentiation of x2p in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional):
!   variations   of useful results: xp
!   with respect to varying inputs: x
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file mapping.f90
!> \brief mapping of 1D control vector to physical variables
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  April 2018
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE X2P_FWV(n, x, x_fwv, xp, xp_fwv, nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: xp(n)
  REAL(kind=8), INTENT(OUT) :: xp_fwv(nbdirsmax, n)
! local decls
  REAL(kind=8) :: sx(n), pr(n)
  EXTERNAL GETPRIOR
  INTEGER :: nd
  INTEGER :: nbdirs
  CALL GETPRIOR(n, pr, sx)
  DO nd=1,nbdirs
    xp_fwv(nd, :) = sx*x_fwv(nd, :)
  END DO
  xp = x*sx
END SUBROUTINE X2P_FWV

!  Differentiation of control_vector_split in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirec
!tional):
!   variations   of useful results: x_s1 x_s2
!   with respect to varying inputs: x
SUBROUTINE CONTROL_VECTOR_SPLIT_FWV(n, x, x_fwv, n_s1, x_s1, x_s1_fwv, &
& n_s2, x_s2, x_s2_fwv, nbdirs)
  USE MO_SENSIMUL
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, n_s1, n_s2
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: x_s1(n_s1), x_s2(n_s2)
  REAL(kind=8), INTENT(OUT) :: x_s1_fwv(nbdirsmax, n_s1), x_s2_fwv(&
& nbdirsmax, n_s2)
! local decls
  INTEGER :: nexpect
  INTEGER :: i, j, i_s1, i_s2
  INTEGER :: nd
  INTEGER :: nbdirs
!-- dimensional consistency
  nexpect = nparam_s1 + npts*nsc
  IF (n .NE. nexpect) THEN
    WRITE(*, '(a,i4,1x,a,i4)') ' FATAL::control_vector_split:n=', n, &
&   'does not equal expected size=', nexpect
    STOP
  ELSE IF (n_s1 .NE. nparam_s1 + npts_s1*nsc) THEN
    WRITE(*, '(a,i4,1x,a,i4)') ' FATAL::control_vector_split:n_s1=', &
&   n_s1, 'does not equal expected size=', nparam_s1 + npts_s1*nsc
    STOP
  ELSE IF (n_s2 .NE. npts_s2*nsc) THEN
    WRITE(*, '(a,i4,1x,a,i4)') ' FATAL::control_vector_split:n_s2=', &
&   n_s2, 'does not equal expected size=', npts_s2*nsc
    STOP
  ELSE
    DO nd=1,nbdirs
!-- map S1 parameter
      x_s1_fwv(nd, :) = 0.0_8
      x_s1_fwv(nd, 1:nparam_s1) = x_fwv(nd, 1:nparam_s1)
    END DO
    x_s1(1:nparam_s1) = x(1:nparam_s1)
! position in full control vector
    j = nparam_s1 + 1
! position in S1 restricted control vector
    i_s1 = nparam_s1 + 1
! position in S2 restrictred control vector
    i_s2 = 1
    DO nd=1,nbdirs
      x_s2_fwv(nd, :) = 0.0_8
    END DO
    DO i=1,npts
!-- point with S1 simulation
      IF (IDX_IS_S1(i)) THEN
        DO nd=1,nbdirs
          x_s1_fwv(nd, i_s1:i_s1+nsc-1) = x_fwv(nd, j:j+nsc-1)
        END DO
        x_s1(i_s1:i_s1+nsc-1) = x(j:j+nsc-1)
        i_s1 = i_s1 + nsc
      END IF
!-- point with S2 simulation
      IF (IDX_IS_S2(i)) THEN
        DO nd=1,nbdirs
          x_s2_fwv(nd, i_s2:i_s2+nsc-1) = x_fwv(nd, j:j+nsc-1)
        END DO
        x_s2(i_s2:i_s2+nsc-1) = x(j:j+nsc-1)
        i_s2 = i_s2 + nsc
      END IF
!-- increment position in control vector
      j = j + nsc
    END DO
  END IF
END SUBROUTINE CONTROL_VECTOR_SPLIT_FWV

!  Differentiation of residual_prior in forward (tangent) mode (with options messagesInFile noinclude noISIZE r8 multiDirectional
!):
!   variations   of useful results: priordiff
!   with respect to varying inputs: x
SUBROUTINE RESIDUAL_PRIOR_FWV(n, x, x_fwv, priordiff, priordiff_fwv, &
& nbdirs)
  USE DIFFSIZES
!  Hint: nbdirsmax should be the maximum number of differentiation directions
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8), INTENT(IN) :: x_fwv(nbdirsmax, n)
  REAL(kind=8), INTENT(OUT) :: priordiff(n)
  REAL(kind=8), INTENT(OUT) :: priordiff_fwv(nbdirsmax, n)
! local
  REAL(kind=8) :: sx(n), x0(n)
! externals
  EXTERNAL GETPRIOR
  INTEGER :: nd
  INTEGER :: nbdirs
!-- get prior
  CALL GETPRIOR(n, x0, sx)
  DO nd=1,nbdirs
    priordiff_fwv(nd, :) = x_fwv(nd, :)
  END DO
  priordiff = x - x0/sx
END SUBROUTINE RESIDUAL_PRIOR_FWV

