!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6693) -  5 Jan 2018 14:09
!
!  Differentiation of cost in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: f
!   with respect to varying inputs: f x
!   RW status of diff variables: f:in-zero x:out
!***********************************************************
!> \file  cost.f90
!> \brief evaluates total cost function
!> \authors MV/TK, The Inversion Lab
!> \date  January/September 2018
!***********************************************************
!***********************************************************
! SUBROUTINE COST()
!> \brief evaluates total cost function that combines 
!>        terms for observations, model, and prior
!> \authors The Inversion Lab
!> \date  January 2018
SUBROUTINE COST_BW(n, x, x_bw, m, f, f_bw)
  USE MO_RETRIEVAL, ONLY : retr_use_prior_term, retr_use_model_term
  IMPLICIT NONE
! arguments
!< length of control
  INTEGER, INTENT(IN) :: n
!< length of output vector
  INTEGER, INTENT(IN) :: m
!< control vector
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
!< function value
  REAL(kind=8) :: f
  REAL(kind=8) :: f_bw
! local
  REAL(kind=8) :: obsdiff(m), costobs
  REAL(kind=8) :: obsdiff_bw(m), costobs_bw
  REAL(kind=8) :: priordiff(n), costprior
  REAL(kind=8) :: priordiff_bw(n), costprior_bw
  REAL(kind=8) :: modeldiff(n), costmodel
  REAL(kind=8) :: modeldiff_bw(n), costmodel_bw
  LOGICAL :: ldebug
! externals
  EXTERNAL STATE_MODEL, RESIDUAL_PRIOR
  EXTERNAL RESIDUAL_PRIOR_BW
  INTRINSIC SUM
  INTEGER :: branch
!-- set flags
  ldebug = .false.
! TAPENADE: (AD07) Data-Flow recovery (TBR) on this call to misfit needs to save the I-O state
! TAPENADE: (AD14) Checkpointing this call to misfit needs to save an undeclared side-effect variable: /multi/[13440,20160[
! TAPENADE: (AD14) Checkpointing this call to misfit needs to save an undeclared side-effect variable: /multi/[6720,13440[
! TAPENADE: (AD14) Checkpointing this call to misfit needs to save an undeclared side-effect variable: /multi/[0,6720[
! TAPENADE: (AD14) Checkpointing this call to misfit needs to save an undeclared side-effect variable: /ga/[256,512[
! TAPENADE: (AD14) Checkpointing this call to misfit needs to save an undeclared side-effect variable: /ga/[0,256[
!-- compute misfit
  CALL MISFIT(n, x, m, obsdiff)
  costobs = 0.5_8*SUM(obsdiff**2)
  IF (ldebug) WRITE(*, '(a,e25.16)') ' DIAG::cost_bw:cost_obs=  ', costobs
!-- compute state model differences
  IF (retr_use_model_term) THEN
    CALL H_M(n, x, modeldiff)
    costmodel = 0.5_8*SUM(modeldiff**2)
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    costmodel = 0._8
  END IF
  IF (ldebug) WRITE(*, '(a,e25.16)') ' DIAG::cost_bw:cost_model=', &
&             costmodel
!-- compute prior diff
  IF (retr_use_prior_term) THEN
    CALL RESIDUAL_PRIOR(n, x, priordiff)
    costprior = 0.5_8*SUM(priordiff**2)
    CALL PUSHCONTROL1B(0)
  ELSE
    costprior = 0._8
    CALL PUSHCONTROL1B(1)
  END IF
  IF (ldebug) WRITE(*, '(a,e25.16)') ' DIAG::cost_bw:cost_prior=', &
&             costprior
  costobs_bw = f_bw
  costmodel_bw = f_bw
  costprior_bw = f_bw
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    priordiff_bw = 0.0_8
    priordiff_bw = 2*priordiff*0.5_8*costprior_bw
    CALL RESIDUAL_PRIOR_BW(n, x, x_bw, priordiff, priordiff_bw)
  ELSE
    x_bw = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    modeldiff_bw = 0.0_8
    modeldiff_bw = 2*modeldiff*0.5_8*costmodel_bw
    CALL H_M_BW(n, x, x_bw, modeldiff, modeldiff_bw)
  END IF
  obsdiff_bw = 0.0_8
  obsdiff_bw = 2*obsdiff*0.5_8*costobs_bw
  CALL MISFIT_BW(n, x, x_bw, m, obsdiff, obsdiff_bw)
  f_bw = 0.0_8
END SUBROUTINE COST_BW

!  Differentiation of h_m in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: x statediff
!   with respect to varying inputs: x
!***********************************************************
!     H_m
!
!> @brief implements Eq. (1.2) in the prototype tool description, the model 'M'determines overall size of control vector (n) and 
!overall size of
!         simulation vector (m)
!         In addition necessary initialisations to actually run the observational operator(s)
!         are performed.
!
!> @param[in]  n  overall (1D-)length of control vector
!> @param[in]  x  overall (1D) control vector (normlalised)
!> @param[out] statediff differences between control vector and the mapped control vector
!
SUBROUTINE H_M_BW(n, x, x_bw, statediff, statediff_bw)
  USE MO_SENSIMUL, ONLY : get_n, get_ns, get_np
  USE MO_MODEL
  IMPLICIT NONE
!iLab::AD-Problem
! statediff(np+1:np+ns) = (xm(np+1:np+ns)-x(np+1:np+ns))/unc_model(1:ns)
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: statediff(n)
  REAL(kind=8) :: statediff_bw(n)
! local decls
  INTEGER :: nc, ns, np
  REAL(kind=8) :: xm(n), xphys(n)
  REAL(kind=8) :: xm_bw(n), xphys_bw(n)
  INTEGER :: i, j
  REAL(kind=8) :: temp_bw
!-- #control vector
  nc = GET_N()
!-- number of states
  ns = GET_NS()
!-- number of parameter, first element of state-vector starts at np+1
  np = GET_NP()
!-- dimensional consistency
  IF (n .NE. nc) THEN
    STOP
  ELSE
    xphys_bw = 0.0_8
    xm_bw = 0.0_8
    DO i=ns,1,-1
      temp_bw = statediff_bw(np+i)/unc_model(i)
      xm_bw(np+i) = xm_bw(np+i) + temp_bw
      xphys_bw(np+i) = xphys_bw(np+i) - temp_bw
      statediff_bw(np+i) = 0.0_8
    END DO
    DO i=ns,1,-1
      DO j=ns,1,-1
        xphys_bw(np+j) = xphys_bw(np+j) + mat_model(i, j)*xm_bw(np+i)
      END DO
      xm_bw(np+i) = 0.0_8
    END DO
    CALL X2P_BW(n, x, x_bw, xphys, xphys_bw)
  END IF
END SUBROUTINE H_M_BW

!  Differentiation of misfit in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: x obsdiff
!   with respect to varying inputs: x
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file misfit.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: computation of misfit between observations and simulated equivalents
!
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!
!> \date  April 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     misfit
!
!> @brief determines the misfit vector between observations and simulated
!         observation equivalents
!
!> @details TBD
!
!> @param[in]  n       overall (1D) length of control vector
!> @param[in]  x       complete (normalised) control vector
!> @param[in]  m       overall (1D) dimension of misfit vector
!                      (must equal dimension of simulation vector)
!> @param[out] obsdiff misfit vector
!
SUBROUTINE MISFIT_BW(n, x, x_bw, m, obsdiff, obsdiff_bw)
  USE MO_SENSIMUL, ONLY : get_m_s1, get_m_s2, sim_fill_value
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: obsdiff(m)
  REAL(kind=8) :: obsdiff_bw(m)
! local
  REAL(kind=8) :: y(m), yobs(m), syobs(m)
  REAL(kind=8) :: y_bw(m)
  LOGICAL :: succeed
  INTEGER :: nobs_s1, nobs_s2
  INTEGER :: m_s1, m_s2
  INTEGER :: i
! externals
  EXTERNAL SIMULATE_S1S2, GETOBS
  EXTERNAL SIMULATE_S1S2_BW
  INTEGER :: branch
!-- read obs
  CALL GETOBS(m, yobs, syobs, nobs_s1, nobs_s2, succeed)
  IF (.NOT.succeed) THEN
    STOP
  ELSE
! TAPENADE: (AD07) Data-Flow recovery (TBR) on this call to simulate_s1s2 needs to save the I-O state
! TAPENADE: (AD14) Checkpointing this call to simulate_s1s2 needs to save an undeclared side-effect variable: /ga/[256,512[
! TAPENADE: (AD14) Checkpointing this call to simulate_s1s2 needs to save an undeclared side-effect variable: /ga/[0,256[
! TAPENADE: (AD14) Checkpointing this call to simulate_s1s2 needs to save an undeclared side-effect variable: /multi/[13440,20160[
! TAPENADE: (AD14) Checkpointing this call to simulate_s1s2 needs to save an undeclared side-effect variable: /multi/[6720,13440[
! TAPENADE: (AD14) Checkpointing this call to simulate_s1s2 needs to save an undeclared side-effect variable: /multi/[0,6720[
!-- run S1+S2 simulation
    CALL SIMULATE_S1S2(n, x, m, y)
    m_s1 = GET_M_S1()
    m_s2 = GET_M_S2()
    IF (nobs_s1 .GT. 0) THEN
      DO i=1,m_s1
        IF (yobs(i) .NE. sim_fill_value .AND. y(i) .NE. sim_fill_value) &
&       THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nobs_s2 .GT. 0) THEN
      DO i=m_s1+1,m_s1+m_s2
        IF (yobs(i) .NE. sim_fill_value .AND. y(i) .NE. sim_fill_value) &
&       THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      y_bw = 0.0_8
      DO i=m_s1+m_s2,m_s1+1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          y_bw(i) = y_bw(i) + obsdiff_bw(i)/syobs(i)
          obsdiff_bw(i) = 0.0_8
        END IF
      END DO
    ELSE
      y_bw = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO i=m_s1,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          y_bw(i) = y_bw(i) + obsdiff_bw(i)/syobs(i)
          obsdiff_bw(i) = 0.0_8
        END IF
      END DO
    END IF
    CALL SIMULATE_S1S2_BW(n, x, x_bw, m, y, y_bw)
  END IF
END SUBROUTINE MISFIT_BW

!  Differentiation of simulate_s1s2 in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: x y
!   with respect to varying inputs: x
!***********************************************************
!     simulate_s1s2
!
!> @brief Implementation of the combined S1 and S2 observation operator.
!>        Computes backscatter values (VH,VV) and top-of-canopy BRFs in 13 Sentinel2 bands
!>        for the respective states in the control vector.
!
!
!> @param[in]   n  length of control vector for multiple simulations in MW and optical domain
!> @param[in]   x  control vector normalised by prior uncertainty
!                  (expected ordering is: S1 related parameter(s) followed by
!                   by state variables LAI,HC,SM per 'simulation point')
!> @param[in]   m  length of output vector
!> @param[out]  y  simulated backscatter values (VH,VV) and simulated TOC BRFs
!                  (for all 13 S2 wave-bands)
!                  (Ordering is: simulated backscatter values per 'simulation point'
!                                followed by BRF values per 'simulation point')
!
SUBROUTINE SIMULATE_S1S2_BW(n, x, x_bw, m, y, y_bw)
  USE MO_SENSIMUL, ONLY : get_nc_s1, get_nc_s2, get_m_s1, get_m_s2, &
& get_n, get_m
  USE MO_SENSIMUL, ONLY : sim_fill_value
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: y(m)
  REAL(kind=8) :: y_bw(m)
! local decls
  REAL(kind=8) :: xp_s1(GET_NC_S1()), xp_s2(GET_NC_S2())
  REAL(kind=8) :: xp_s1_bw(GET_NC_S1()), xp_s2_bw(GET_NC_S2())
  INTEGER :: n_s1, n_s2, m_s1, m_s2
  REAL(kind=8) :: xphys(n)
  REAL(kind=8) :: xphys_bw(n)
  INTEGER :: res
  INTEGER :: res0
  INTEGER :: res1
  INTEGER :: res2
  INTEGER :: branch
!-- dimension consistency
  res = GET_N()
  IF (n .NE. res) THEN
    STOP
  ELSE
    res1 = GET_M()
    IF (m .NE. res1) THEN
      STOP
    ELSE
!-- initialise output
!-- convert normalised to physical control vector
      CALL X2P(n, x, xphys)
!-- extract specific control vectors
      n_s1 = GET_NC_S1()
      n_s2 = GET_NC_S2()
      m_s1 = GET_M_S1()
      m_s2 = GET_M_S2()
      CALL CONTROL_VECTOR_SPLIT(n, xphys, n_s1, xp_s1, n_s2, xp_s2)
!-- S1 simulation
      IF (n_s1 .GT. 0) THEN
        CALL SIMULATE_S1(n_s1, xp_s1, m_s1, y(1:m_s1))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!-- S2 simulation
      IF (n_s2 .GT. 0) THEN
! TAPENADE: (AD07) Data-Flow recovery (TBR) on this call to simulate_s2 needs to save the I-O state
! TAPENADE: (AD14) Checkpointing this call to simulate_s2 needs to save an undeclared side-effect variable: /multi/[13440,20160[
! TAPENADE: (AD14) Checkpointing this call to simulate_s2 needs to save an undeclared side-effect variable: /multi/[6720,13440[
! TAPENADE: (AD14) Checkpointing this call to simulate_s2 needs to save an undeclared side-effect variable: /multi/[0,6720[
! TAPENADE: (AD14) Checkpointing this call to simulate_s2 needs to save an undeclared side-effect variable: /ga/[256,512[
! TAPENADE: (AD14) Checkpointing this call to simulate_s2 needs to save an undeclared side-effect variable: /ga/[0,256[
        CALL SIMULATE_S2(n_s2, xp_s2, m_s2, y(m_s1+1:m_s1+m_s2))
        CALL SIMULATE_S2_BW(n_s2, xp_s2, xp_s2_bw, m_s2, y(m_s1+1:m_s1+&
&                     m_s2), y_bw(m_s1+1:m_s1+m_s2))
      ELSE
        xp_s2_bw = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL SIMULATE_S1_BW(n_s1, xp_s1, xp_s1_bw, m_s1, y(1:m_s1), y_bw&
&                     (1:m_s1))
        y_bw(1:m_s1) = 0.0_8
      ELSE
        xp_s1_bw = 0.0_8
      END IF
      CALL CONTROL_VECTOR_SPLIT_BW(n, xphys, xphys_bw, n_s1, xp_s1, &
&                            xp_s1_bw, n_s2, xp_s2, xp_s2_bw)
      CALL X2P_BW(n, x, x_bw, xphys, xphys_bw)
    END IF
  END IF
END SUBROUTINE SIMULATE_S1S2_BW

!  Differentiation of simulate_s1 in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: y
!   with respect to varying inputs: x
!***********************************************************
!     simulate_s1
!
!> @brief Implementation of S1 simulation.
!>        Backscatter values in VH and VV polarisation will be computed for the
!>        given control vector.
!
!> @details This routine provides the implementation of the observation operator H_1
!>          as denoted in Figure 1.2 in document D5v1.
!
!> @param[in]   n  length of control-vector for multiple simulations in the MW domain
!> @param[in]   x  S1 relevant part of full control vector in physical units
!                  (expected ordering is: S1 related parameter(s) followed by
!                   by state-variables LAI,HC,SM per state)
!> @param[in]   m  length of output vector
!> @param[out]  y  simulated backscatter values (VH,VV) per state
!
SUBROUTINE SIMULATE_S1_BW(n, x, x_bw, m, y, y_bw)
  USE MO_SENSIMUL, ONLY : nparam_s1, nsc, npts_s1, nparam_s1, get_nc_s1,&
& get_m_s1
  USE MO_SENSIMUL, ONLY : iv_geom, timept_idxs_s1
!VH,VV
  USE MO_SENSIMUL_S1, ONLY : npol
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: y(m)
  REAL(kind=8) :: y_bw(m)
! externals
  EXTERNAL SIMULATE_S1_1GEOM
  EXTERNAL SIMULATE_S1_1GEOM_BW
! local decls
  INTEGER :: ipt, ipt_s1
  INTEGER :: i0, i1, j0, j1
  REAL(kind=8) :: statev(nparam_s1+nsc)
  REAL(kind=8) :: statev_bw(nparam_s1+nsc)
  REAL(kind=8) :: single_ivgeom(4)
  INTEGER :: res
  INTEGER :: res0
  INTEGER :: res1
  INTEGER :: res2
!-- dimension consistency
  res = GET_NC_S1()
  IF (n .NE. res) THEN
    STOP
  ELSE
!-- map S1 *parameter part* into model input vector
!   NOTE: S1 parameter is part of control vector
    statev(1:nparam_s1) = x(1:nparam_s1)
!-- loop over time-points
!-- initial position in 'x' vector
    i0 = nparam_s1 + 1
!-- initial position in 'y' vector
    j0 = 1
simloop:DO ipt=1,npts_s1
      CALL PUSHINTEGER4(i1)
      i1 = i0 + nsc - 1
      CALL PUSHINTEGER4(j1)
      j1 = j0 + npol - 1
      CALL PUSHREAL8ARRAY(statev(nparam_s1+1:nparam_s1+nsc), nsc)
      statev(nparam_s1+1:nparam_s1+nsc) = x(i0:i1)
!-- increment start position
      CALL PUSHINTEGER4(i0)
      i0 = i1 + 1
      CALL PUSHINTEGER4(j0)
      j0 = j1 + 1
    END DO simloop
    x_bw = 0.0_8
    statev_bw = 0.0_8
    DO ipt=npts_s1,1,-1
      CALL POPINTEGER4(j0)
      CALL POPINTEGER4(i0)
      ipt_s1 = timept_idxs_s1(ipt)
      single_ivgeom(1:4) = iv_geom(1:4, ipt_s1)
      CALL SIMULATE_S1_1GEOM_BW(statev, statev_bw, single_ivgeom, y(j0:&
&                         j1), y_bw(j0:j1))
      CALL POPREAL8ARRAY(statev(nparam_s1+1:nparam_s1+nsc), nsc)
      x_bw(i0:i1) = x_bw(i0:i1) + statev_bw(nparam_s1+1:nparam_s1+nsc)
      statev_bw(nparam_s1+1:nparam_s1+nsc) = 0.0_8
      CALL POPINTEGER4(j1)
      CALL POPINTEGER4(i1)
    END DO
    x_bw(1:nparam_s1) = x_bw(1:nparam_s1) + statev_bw(1:nparam_s1)
  END IF
END SUBROUTINE SIMULATE_S1_BW

!  Differentiation of simulate_s1_1geom in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: statev bscat
!   with respect to varying inputs: statev bscat
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file simulate.f90
!> \brief provides implementation of the observation operators in the
!>              optical and microwave domain.mapping of 1D control vector to physical variables
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  April 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     simulate_s1_1geom
!
!> @brief Implementation of the Sentinel Synergy Study observation operator
!>        in the microwave domain (denoted H_1 in document D5) for a single state.
!
!> @details For the given input state (LAI_coeff, LAI,HC, and SM) the observation operator
!>          derives backscatter values in VH and VV polarisation.
!>          The implementation is based on the Fortran port of the SENSE model.
!
!> @param[in]   statev   state components (physical units) required to run S1 simulation
!>                       consisting of LAI conversion coefficient, (optical) LAI, HC, and SM
!> @param[out]  bscat    back-scatter values in VH/VV polarisation
!
SUBROUTINE SIMULATE_S1_1GEOM_BW(statev, statev_bw, iv_geom, bscat, &
& bscat_bw)
  USE MO_SENSIMUL, ONLY : nsc, nparam_s1
!-- viewing zenith-angle for microwave simulation
  USE MO_SENSIMUL_S1, ONLY : theta, pi
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: statev(nparam_s1+nsc)
  REAL(kind=8) :: statev_bw(nparam_s1+nsc)
!sza,saa,vza,vaa
  REAL(kind=8), INTENT(IN) :: iv_geom(4)
!VH,VV
  REAL(kind=8) :: bscat(2)
  REAL(kind=8) :: bscat_bw(2)
! externals
!core SENSE routine
  EXTERNAL SIGMA0_VHVV
  EXTERNAL SIGMA0_VHVV_BW
! local declarations
  REAL(kind=8) :: lai_coeff, lai, hc, sm
  REAL(kind=8) :: lai_coeff_bw, lai_bw, hc_bw, sm_bw
  REAL(kind=8) :: s0vh, s0vv
  REAL(kind=8) :: s0vh_bw, s0vv_bw
!-- S1 viewing zenith angle
  REAL(kind=8) :: vza_deg
!-- map state variables
  lai_coeff = statev(1)
  lai = statev(2)
  hc = statev(3)
  sm = statev(4)
!--
  vza_deg = iv_geom(3)
!-- convert to RAD
  theta = vza_deg*(pi/180._8)
!-- call SENSE core routine
!-- map backscatter values
  s0vv_bw = bscat_bw(2)
  bscat_bw(2) = 0.0_8
  s0vh_bw = bscat_bw(1)
  bscat_bw(1) = 0.0_8
  CALL SIGMA0_VHVV_BW(lai, lai_bw, lai_coeff, lai_coeff_bw, hc, hc_bw, &
&               sm, sm_bw, s0vh, s0vh_bw, s0vv, s0vv_bw)
  statev_bw(4) = statev_bw(4) + sm_bw
  statev_bw(3) = statev_bw(3) + hc_bw
  statev_bw(2) = statev_bw(2) + lai_bw
  statev_bw(1) = statev_bw(1) + lai_coeff_bw
END SUBROUTINE SIMULATE_S1_1GEOM_BW

!  Differentiation of sigma0_vhvv in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: s0vh s0vv
!   with respect to varying inputs: lai lai_coeff canht mv
!***********************************************************
!     sigma0_vhvv
!
!> @brief compute total single-scattering backscattering coefficents for VH and VV polarisations
!
!> @details 
!
!> @param[in]  lai        leaf-area index [m2/m2] as used in optical domain
!> @param[in]  lai_coeff  conversion coefficient for lai optical to microwave
!> @param[in]  canht      canopy height [m]
!> @param[in]  mv         volumetric soilmoisture [m3/m3]
!> @param[out] s0vh       backscattering coefficient, VH polarisation
!> @param[out] s0vv       backscattering coefficient, VV polarisation
!
SUBROUTINE SIGMA0_VHVV_BW(lai, lai_bw, lai_coeff, lai_coeff_bw, canht, &
& canht_bw, mv, mv_bw, s0vh, s0vh_bw, s0vv, s0vv_bw)
  USE MO_SENSIMUL_S1
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: lai, lai_coeff, canht, mv
  REAL(kind=8) :: lai_bw, lai_coeff_bw, canht_bw, mv_bw
  REAL(kind=8) :: s0vh, s0vv
  REAL(kind=8) :: s0vh_bw, s0vv_bw
! externals
  EXTERNAL DOBSON85_EPS
  EXTERNAL DOBSON85_EPS_BW
  EXTERNAL REFLECTIVITY, CALC_RHO
  EXTERNAL REFLECTIVITY_BW, CALC_RHO_BW
  EXTERNAL CANOPY_EXTINCTION_COEFFS, CANOPY_TRANSMISSIVITY
  EXTERNAL CANOPY_EXTINCTION_COEFFS_BW, CANOPY_TRANSMISSIVITY_BW
  EXTERNAL SCATRAYLEIGH_SIGMA_V_BACK, SCATRAYLEIGH_SIGMA_V_BISTATIC
  EXTERNAL SCATRAYLEIGH_SIGMA_V_BACK_BW, &
&     SCATRAYLEIGH_SIGMA_V_BISTATIC_BW
  EXTERNAL OH92_BACKSCATTER
  EXTERNAL OH92_BACKSCATTER_BW
  EXTERNAL CANOPY_SIGMA_C, GROUND_SIGMA, SIGMA_CG, SIGMA_GCG
  EXTERNAL CANOPY_SIGMA_C_BW, GROUND_SIGMA_BW, SIGMA_CG_BW, SIGMA_GCG_BW
! local declarations
  COMPLEX(kind=8) :: eps
  COMPLEX(kind=8) :: eps_bw
  REAL(kind=8) :: v, h, rho_v, rho_h, t_v, t_h, ke_v, ke_h, ks_h, ks_v
  REAL(kind=8) :: v_bw, h_bw, rho_v_bw, rho_h_bw, t_v_bw, t_h_bw, &
& ke_v_bw, ke_h_bw, ks_h_bw, ks_v_bw
  REAL(kind=8) :: lai_mw
  REAL(kind=8) :: lai_mw_bw
!hh,vv,hv
  REAL(kind=8) :: soil_backscatter(3)
  REAL(kind=8) :: soil_backscatter_bw(3)
!hh,vv,hv
  REAL(kind=8) :: sigma_vol_bistatic(3), sigma_vol_back(3)
  REAL(kind=8) :: sigma_vol_bistatic_bw(3), sigma_vol_back_bw(3)
!hh,vv,hv
  REAL(kind=8) :: s0c(3), s0g(3), s0cgt(3), s0gcg(3)
  REAL(kind=8) :: s0c_bw(3), s0g_bw(3), s0cgt_bw(3), s0gcg_bw(3)
  INTEGER :: branch
!-- microwave LAI
  lai_mw = lai*lai_coeff
!-- soil-moisture ==> eps (dielectric permittivity)
  CALL DOBSON85_EPS(mv, bulk, alpha, beta1, beta2, ew, eps)
!-- reflectivity
  CALL REFLECTIVITY(theta, eps, v, h)
!-- coherent p-polarized reflectivity
  CALL CALC_RHO(theta, ks, v, h, rho_v, rho_h)
!-- extinction coefficients
  CALL CANOPY_EXTINCTION_COEFFS(omega, lai_mw, ke_v, ke_h, ks_v, ks_h)
!-- canopy transmissivity
  CALL CANOPY_TRANSMISSIVITY(ke_v, ke_h, canht, theta, t_v, t_h)
!-- canopy contribution
!-- (Ulaby, eq. 11.22)
  CALL SCATRAYLEIGH_SIGMA_V_BACK(ks_v, ks_h, sigma_vol_back)
  CALL CANOPY_SIGMA_C(sigma_vol_back, theta, ke_v, ke_h, t_v, t_h, s0c)
!-- ground contribution
  CALL OH92_BACKSCATTER(eps, ks, theta, soil_backscatter)
  CALL GROUND_SIGMA(soil_backscatter, t_v, t_h, s0g)
!-- total canopy-ground
  CALL SCATRAYLEIGH_SIGMA_V_BISTATIC(ks_v, ks_h, sigma_vol_bistatic)
  CALL SIGMA_CG(sigma_vol_bistatic, canht, coherent, rho_v, rho_h, t_v, &
&         t_h, s0cgt)
!-- ground-canopy-ground
  CALL SIGMA_GCG(sigma_vol_back, theta, rho_v, rho_h, t_v, t_h, ke_v, &
&          ke_h, s0gcg)
!-- sum-up contributions
!-- for S1 we have sender=receiver, thus VH equals HV (reciprocal theorem)
  IF (s0c(3) .NE. sense_fv) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (s0g(3) .NE. sense_fv) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (s0cgt(3) .NE. sense_fv) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (s0gcg(3) .NE. sense_fv) THEN
    s0gcg_bw = 0.0_8
    s0gcg_bw(3) = s0gcg_bw(3) + s0vh_bw
  ELSE
    s0gcg_bw = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    s0cgt_bw = 0.0_8
    s0cgt_bw(3) = s0cgt_bw(3) + s0vh_bw
  ELSE
    s0cgt_bw = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    s0g_bw = 0.0_8
    s0g_bw(3) = s0g_bw(3) + s0vh_bw
  ELSE
    s0g_bw = 0.0_8
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    s0c_bw = 0.0_8
    s0c_bw(3) = s0c_bw(3) + s0vh_bw
  ELSE
    s0c_bw = 0.0_8
  END IF
  s0c_bw(2) = s0c_bw(2) + s0vv_bw
  s0g_bw(2) = s0g_bw(2) + s0vv_bw
  s0cgt_bw(2) = s0cgt_bw(2) + s0vv_bw
  s0gcg_bw(2) = s0gcg_bw(2) + s0vv_bw
  CALL SIGMA_GCG_BW(sigma_vol_back, sigma_vol_back_bw, theta, rho_v, &
&             rho_v_bw, rho_h, rho_h_bw, t_v, t_v_bw, t_h, t_h_bw, ke_v&
&             , ke_v_bw, ke_h, ke_h_bw, s0gcg, s0gcg_bw)
  CALL SIGMA_CG_BW(sigma_vol_bistatic, sigma_vol_bistatic_bw, canht, &
&            canht_bw, coherent, rho_v, rho_v_bw, rho_h, rho_h_bw, t_v, &
&            t_v_bw, t_h, t_h_bw, s0cgt, s0cgt_bw)
  CALL SCATRAYLEIGH_SIGMA_V_BISTATIC_BW(ks_v, ks_v_bw, ks_h, ks_h_bw, &
&                                 sigma_vol_bistatic, &
&                                 sigma_vol_bistatic_bw)
  CALL GROUND_SIGMA_BW(soil_backscatter, soil_backscatter_bw, t_v, &
&                t_v_bw, t_h, t_h_bw, s0g, s0g_bw)
  CALL OH92_BACKSCATTER_BW(eps, eps_bw, ks, theta, soil_backscatter, &
&                    soil_backscatter_bw)
  CALL CANOPY_SIGMA_C_BW(sigma_vol_back, sigma_vol_back_bw, theta, ke_v&
&                  , ke_v_bw, ke_h, ke_h_bw, t_v, t_v_bw, t_h, t_h_bw, &
&                  s0c, s0c_bw)
  CALL SCATRAYLEIGH_SIGMA_V_BACK_BW(ks_v, ks_v_bw, ks_h, ks_h_bw, &
&                             sigma_vol_back, sigma_vol_back_bw)
  CALL CANOPY_TRANSMISSIVITY_BW(ke_v, ke_v_bw, ke_h, ke_h_bw, canht, &
&                         canht_bw, theta, t_v, t_v_bw, t_h, t_h_bw)
  CALL CANOPY_EXTINCTION_COEFFS_BW(omega, lai_mw, lai_mw_bw, ke_v, &
&                            ke_v_bw, ke_h, ke_h_bw, ks_v, ks_v_bw, ks_h&
&                            , ks_h_bw)
  CALL CALC_RHO_BW(theta, ks, v, v_bw, h, h_bw, rho_v, rho_v_bw, rho_h, &
&            rho_h_bw)
  CALL REFLECTIVITY_BW(theta, eps, eps_bw, v, v_bw, h, h_bw)
  CALL DOBSON85_EPS_BW(mv, mv_bw, bulk, alpha, beta1, beta2, ew, eps, &
&                eps_bw)
  lai_bw = lai_coeff*lai_mw_bw
  lai_coeff_bw = lai*lai_mw_bw
END SUBROUTINE SIGMA0_VHVV_BW

!  Differentiation of canopy_extinction_coeffs in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: ks_h ks_v ke_h ke_v
!   with respect to varying inputs: lai_mw
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file canopy.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of canopy class ported from Sentinel Simulator (sense/canopy.py)
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     canopy_extinction_coeffs
!
!> @brief compute extinction coefficients from LAI (microwave) and single-scattering albedo
!
!> @param[in]  omega   single scattering albedo
!> @param[in]  lai_mw  Leaf-Area Index (MW-compliant)
!> @param[out] ke_h
!> @param[out] ke_v
!> @param[out] ks_h
!> @param[out] ks_v
!
! Ref: sense/canopy.py, l21 ff.
!      simulator.py, l100 ff.
!
SUBROUTINE CANOPY_EXTINCTION_COEFFS_BW(omega, lai_mw, lai_mw_bw, ke_v, &
& ke_v_bw, ke_h, ke_h_bw, ks_v, ks_v_bw, ks_h, ks_h_bw)
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: omega, lai_mw
  REAL(kind=8) :: lai_mw_bw
  REAL(kind=8) :: ke_h, ke_v, ks_h, ks_v
  REAL(kind=8) :: ke_h_bw, ke_v_bw, ks_h_bw, ks_v_bw
  lai_mw_bw = omega*ks_h_bw + ke_h_bw + ke_v_bw + omega*ks_v_bw
END SUBROUTINE CANOPY_EXTINCTION_COEFFS_BW

!  Differentiation of canopy_transmissivity in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: d t_h t_v ke_h ke_v
!   with respect to varying inputs: d ke_h ke_v
!***********************************************************
!     canopy_transmissivity
!
!> @brief compute canopy transmissivity
!
!> @param[in] ke_h  volume extinction coefficient (hor. pol) [Np/m]
!> @param[in] ke_v  volume extinction coefficient (ver. pol) [Np/m]
!> @param[in] d     height of canopy layer
!> @param[in] theta incidence angle
!> @param[out] t_h  transmissivity, h-polarised
!> @param[out] t_v  transmissivity, v-polarised
!
! Ref: sense/canopy.py, l299 ff.
!      sense/canopy.py, l356 ff
!
SUBROUTINE CANOPY_TRANSMISSIVITY_BW(ke_v, ke_v_bw, ke_h, ke_h_bw, d, &
& d_bw, theta, t_v, t_v_bw, t_h, t_h_bw)
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: ke_h, ke_v, d, theta
  REAL(kind=8) :: ke_h_bw, ke_v_bw, d_bw
  REAL(kind=8) :: t_h, t_v
  REAL(kind=8) :: t_h_bw, t_v_bw
! local decls
  REAL(kind=8) :: tau_h, tau_v
  REAL(kind=8) :: tau_h_bw, tau_v_bw
  INTRINSIC EXP
  tau_h = TAU_FCT(ke_h)
  tau_v = TAU_FCT(ke_v)
  tau_v_bw = -(EXP(-tau_v)*t_v_bw)
  tau_h_bw = -(EXP(-tau_h)*t_h_bw)
  CALL TAU_FCT_BW0(ke_v, ke_v_bw, tau_v_bw)
  CALL TAU_FCT_BW0(ke_h, ke_h_bw, tau_h_bw)

CONTAINS
!  Differentiation of tau_fct in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: d k tau_fct
!   with respect to varying inputs: d k
!assumption: extinction is isotropic
  SUBROUTINE TAU_FCT_BW0(k, k_bw, tau_fct_bw)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: k
    REAL(kind=8) :: k_bw
    INTRINSIC COS
    REAL(kind=8) :: temp_bw
    REAL(kind=8) :: tau_fct
    REAL(kind=8) :: tau_fct_bw
    temp_bw = tau_fct_bw/COS(theta)
    k_bw = k_bw + d*temp_bw
    d_bw = d_bw + k*temp_bw
  END SUBROUTINE TAU_FCT_BW0
!assumption: extinction is isotropic
  REAL(kind=8) FUNCTION TAU_FCT(k)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: k
    INTRINSIC COS
    tau_fct = k*d/COS(theta)
  END FUNCTION TAU_FCT
END SUBROUTINE CANOPY_TRANSMISSIVITY_BW

!  Differentiation of canopy_sigma_c in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: s0c t_h sigma_vol_back t_v
!                ke_h ke_v
!   with respect to varying inputs: t_h sigma_vol_back t_v ke_h
!                ke_v
!***********************************************************
!     canopy_transmissivity
!
!> @brief calculate canopy volume contribution only (Eq. 11.10 + 11.16 as seen in 11.17, Ulaby (2014))
!
! Ref: sense/model.py, l372 ff.
!
SUBROUTINE CANOPY_SIGMA_C_BW(sigma_vol_back, sigma_vol_back_bw, theta, &
& ke_v, ke_v_bw, ke_h, ke_h_bw, t_v, t_v_bw, t_h, t_h_bw, s0c, s0c_bw)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  IMPLICIT NONE
! arguments
!hh,vv,hv
  REAL(kind=8), INTENT(IN) :: sigma_vol_back(3)
  REAL(kind=8) :: sigma_vol_back_bw(3)
  REAL(kind=8), INTENT(IN) :: theta, ke_v, ke_h, t_v, t_h
  REAL(kind=8) :: ke_v_bw, ke_h_bw, t_v_bw, t_h_bw
  REAL(kind=8) :: s0c(3)
  REAL(kind=8) :: s0c_bw(3)
  INTRINSIC COS
  REAL(kind=8) :: temp
  REAL(kind=8) :: temp0
  REAL(kind=8) :: temp1
  REAL(kind=8) :: temp2
  REAL*8 :: temp_bw
  REAL(kind=8) :: temp_bw0
  REAL*8 :: temp_bw1
  REAL(kind=8) :: temp_bw2
  REAL(kind=8) :: temp3
  REAL*8 :: temp_bw3
  REAL(kind=8) :: temp_bw4
  REAL(kind=8) :: temp_bw5
!-- HH
!-- VV
  IF (sigma_vol_back(3) .EQ. sense_fv) THEN
    s0c_bw(3) = 0.0_8
  ELSE
    temp3 = sigma_vol_back(3)/(ke_h+ke_v)
    temp_bw3 = COS(theta)*s0c_bw(3)
    temp_bw4 = (1._8-t_h*t_v)*temp_bw3/(ke_h+ke_v)
    temp_bw5 = -(temp3*temp_bw4)
    t_h_bw = t_h_bw - temp3*t_v*temp_bw3
    t_v_bw = t_v_bw - temp3*t_h*temp_bw3
    sigma_vol_back_bw(3) = sigma_vol_back_bw(3) + temp_bw4
    ke_h_bw = ke_h_bw + temp_bw5
    ke_v_bw = ke_v_bw + temp_bw5
    s0c_bw(3) = 0.0_8
  END IF
  temp2 = 2*ke_v
  temp1 = sigma_vol_back(2)/temp2
  temp_bw = COS(theta)*s0c_bw(2)
  temp_bw0 = (1._8-t_v**2)*temp_bw/temp2
  t_v_bw = t_v_bw - temp1*2*t_v*temp_bw
  sigma_vol_back_bw(2) = sigma_vol_back_bw(2) + temp_bw0
  ke_v_bw = ke_v_bw - temp1*2*temp_bw0
  s0c_bw(2) = 0.0_8
  temp0 = 2*ke_h
  temp = sigma_vol_back(1)/temp0
  temp_bw1 = COS(theta)*s0c_bw(1)
  temp_bw2 = (1._8-t_h**2)*temp_bw1/temp0
  t_h_bw = t_h_bw - temp*2*t_h*temp_bw1
  sigma_vol_back_bw(1) = sigma_vol_back_bw(1) + temp_bw2
  ke_h_bw = ke_h_bw - temp*2*temp_bw2
END SUBROUTINE CANOPY_SIGMA_C_BW

!  Differentiation of dobson85_eps in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: eps
!   with respect to varying inputs: mv
!***********************************************************
!     dobson85_eps
!
!> @brief calculate dielectric permittivity (Eq. 4.66 (Ulaby et al., 2014))
!
!> @param[in]  mv     volumetric soil moisture [m**3/m**3]
!> @param[in]  bulk   bulk density [g/cm**3]
!> @param[in]  alpha  as computed by dobson85_init
!> @param[in]  beta1  as computed by dobson85_init
!> @param[in]  beta2  as computed by dobson85_init
!> @param[in]  ew     dielectric permittivity of free water
!> @param[out] eps    relative dielectric permittivity
!
SUBROUTINE DOBSON85_EPS_BW(mv, mv_bw, bulk, alpha, beta1, beta2, ew, eps&
& , eps_bw)
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: mv, bulk, alpha, beta1, beta2
  REAL(kind=8) :: mv_bw
  COMPLEX(kind=8), INTENT(IN) :: ew
  COMPLEX(kind=8) :: eps
  COMPLEX(kind=8) :: eps_bw
! local variables
  REAL(kind=8) :: e1, e2
  REAL(kind=8) :: e1_bw, e2_bw
  INTRINSIC REAL
  INTRINSIC AIMAG
  INTRINSIC CMPLX
  REAL :: result1
  REAL*8 :: temp
  REAL(kind=8) :: temp_bw
  e1 = (1._8+0.66_8*bulk+mv**beta1*REAL(ew)**alpha-mv)**(1._8/alpha)
  result1 = AIMAG(ew)
  e2 = result1*mv**beta2
  e1_bw = CMPLX(1.0, 0.0, kind=8)*eps_bw
  e2_bw = CMPLX(0.0, 1.0, kind=8)*eps_bw
  IF (mv .LE. 0.0_8 .AND. (beta2 .EQ. 0.0_8 .OR. beta2 .NE. INT(beta2))&
& ) THEN
    mv_bw = 0.0
  ELSE
    mv_bw = result1*beta2*mv**(beta2-1)*e2_bw
  END IF
  temp = REAL(ew)**alpha
  IF (bulk*0.66_8 + temp*mv**beta1 - mv + 1._8 .LE. 0.0_8 .AND. (1.0/&
&     alpha .EQ. 0.0_8 .OR. 1.0/alpha .NE. INT(1.0/alpha))) THEN
    temp_bw = 0.0
  ELSE
    temp_bw = (bulk*0.66_8+temp*mv**beta1-mv+1._8)**(1.0/alpha-1)*e1_bw/&
&     alpha
  END IF
  IF (mv .LE. 0.0_8 .AND. (beta1 .EQ. 0.0_8 .OR. beta1 .NE. INT(beta1))&
& ) THEN
    mv_bw = mv_bw - temp_bw
  ELSE
    mv_bw = mv_bw + (temp*beta1*mv**(beta1-1)-1.0)*temp_bw
  END IF
END SUBROUTINE DOBSON85_EPS_BW

!  Differentiation of calc_rho in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: rho_h rho_v
!   with respect to varying inputs: h v
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file ground.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of Ground class ported from Sentinel Simulator (sense/model.py)
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     calc_rho
!
!> @brief calculate coherent p-polarized reflectivity  (Ref: Eq. 11.11 (Ulaby, 2014))
!
!---------
! Note that the specular reflectivity is corrected by a roughness term
!         if ks>0.2
!
!         however, a sensitivity analysis showed that even for ks==0.2
!         deviations can be up to 15% for typical incidence angles
!         Only in case that ks << 0.1, the correction can be neglected.
!         We therefore always use the roughness correction factor!
!         TODO: unclear so far how this relates to surface (soil) scattering models
!---------
!
!> @param[in]   theta  incidence angle [rad]
!> @param[in]   ks     (surface) roughness parameter
!> @param[in]   v      reflectivity ver. pol.
!> @param[in]   h      reflectivity hor. pol.
!> @param[out]  rho_v  coherent p-polarized reflectivity ver. pol.
!> @param[out   rho_h  coherent p-polarized reflectivity hor. pol.
!
! Ref: sense/model.py, l177 ff.
!
SUBROUTINE CALC_RHO_BW(theta, ks, v, v_bw, h, h_bw, rho_v, rho_v_bw, &
& rho_h, rho_h_bw)
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: theta
  REAL(kind=8), INTENT(IN) :: ks
  REAL(kind=8), INTENT(IN) :: v, h
  REAL(kind=8) :: v_bw, h_bw
  REAL(kind=8) :: rho_v, rho_h
  REAL(kind=8) :: rho_v_bw, rho_h_bw
  INTRINSIC COS
  INTRINSIC EXP
!--
  h_bw = EXP(-(COS(theta)**2*(ks**2*4._8)))*rho_h_bw
  v_bw = EXP(-(COS(theta)**2*(ks**2*4._8)))*rho_v_bw
END SUBROUTINE CALC_RHO_BW

!  Differentiation of sigma_gcg in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: s0gcg
!   with respect to varying inputs: t_h sigma_vol_back t_v ke_h
!                ke_v rho_h rho_v
!***********************************************************
!     sigma_gcg
!
!> @brief compute ground-canopy-ground interaction
!
!> @param[in]  sigma_vol_back
!> @param[in]  theta
!> @param[in]  rho_v
!> @param[in]  rho_h
!> @param[in]  t_h
!> @param[in]  t_v
!> @param[in]  ke_v
!> @param[in]  ke_h
!> @param[out] s0gcg
!
! Ref: sense/model.py, l205 ff.
!
SUBROUTINE SIGMA_GCG_BW(sigma_vol_back, sigma_vol_back_bw, theta, rho_v&
& , rho_v_bw, rho_h, rho_h_bw, t_v, t_v_bw, t_h, t_h_bw, ke_v, ke_v_bw, &
& ke_h, ke_h_bw, s0gcg, s0gcg_bw)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  IMPLICIT NONE
! arguments
!hh,vv,hv
  REAL(kind=8), INTENT(IN) :: sigma_vol_back(3)
  REAL(kind=8) :: sigma_vol_back_bw(3)
  REAL(kind=8), INTENT(IN) :: theta, rho_v, rho_h, t_v, t_h, ke_v, ke_h
  REAL(kind=8) :: rho_v_bw, rho_h_bw, t_v_bw, t_h_bw, ke_v_bw, ke_h_bw
!hh,vv,hv
  REAL(kind=8) :: s0gcg(3)
  REAL(kind=8) :: s0gcg_bw(3)
  INTRINSIC COS
  REAL(kind=8) :: temp
  REAL(kind=8) :: temp0
  REAL(kind=8) :: temp1
  REAL(kind=8) :: temp2
  REAL(kind=8) :: temp3
  REAL(kind=8) :: temp4
  REAL(kind=8) :: temp_bw
  REAL(kind=8) :: temp_bw0
  REAL(kind=8) :: temp_bw1
  REAL(kind=8) :: temp_bw2
  REAL(kind=8) :: temp_bw3
  REAL(kind=8) :: temp_bw4
  REAL(kind=8) :: temp5
  REAL(kind=8) :: temp_bw5
  REAL(kind=8) :: temp_bw6
  REAL(kind=8) :: temp_bw7
  REAL(kind=8) :: temp_bw8
  REAL(kind=8) :: temp_bw9
!-- HH
!-- VV
!-- HV
  IF (sigma_vol_back(3) .EQ. sense_fv) THEN
    s0gcg_bw(3) = 0.0_8
    t_h_bw = 0.0_8
    sigma_vol_back_bw = 0.0_8
    t_v_bw = 0.0_8
    ke_h_bw = 0.0_8
    ke_v_bw = 0.0_8
    rho_h_bw = 0.0_8
    rho_v_bw = 0.0_8
  ELSE
    sigma_vol_back_bw = 0.0_8
    temp5 = sigma_vol_back(3)/(ke_h+ke_v)
    temp_bw5 = COS(theta)*s0gcg_bw(3)
    temp_bw6 = rho_h*rho_v*temp5*temp_bw5
    temp_bw7 = (t_h*t_v-t_h**2*t_v**2)*temp_bw5
    temp_bw8 = rho_h*rho_v*temp_bw7/(ke_h+ke_v)
    temp_bw9 = -(temp5*temp_bw8)
    t_h_bw = (t_v-t_v**2*2*t_h)*temp_bw6
    t_v_bw = (t_h-t_h**2*2*t_v)*temp_bw6
    rho_h_bw = temp5*rho_v*temp_bw7
    rho_v_bw = temp5*rho_h*temp_bw7
    sigma_vol_back_bw(3) = sigma_vol_back_bw(3) + temp_bw8
    ke_h_bw = temp_bw9
    ke_v_bw = temp_bw9
    s0gcg_bw(3) = 0.0_8
  END IF
  temp4 = 2*ke_v
  temp3 = sigma_vol_back(1)*rho_v**2
  temp2 = temp3/temp4
  temp_bw = COS(theta)*s0gcg_bw(2)
  temp_bw0 = (t_v**2-t_v**4)*temp_bw/temp4
  temp_bw1 = temp2*temp_bw
  sigma_vol_back_bw(1) = sigma_vol_back_bw(1) + rho_v**2*temp_bw0
  rho_v_bw = rho_v_bw + sigma_vol_back(1)*2*rho_v*temp_bw0
  ke_v_bw = ke_v_bw - temp2*2*temp_bw0
  t_v_bw = t_v_bw + (2*t_v-4*t_v**3)*temp_bw1
  s0gcg_bw(2) = 0.0_8
  temp1 = 2*ke_h
  temp0 = sigma_vol_back(2)*rho_h**2
  temp = temp0/temp1
  temp_bw2 = COS(theta)*s0gcg_bw(1)
  temp_bw3 = (t_h**2-t_h**4)*temp_bw2/temp1
  temp_bw4 = temp*temp_bw2
  sigma_vol_back_bw(2) = sigma_vol_back_bw(2) + rho_h**2*temp_bw3
  rho_h_bw = rho_h_bw + sigma_vol_back(2)*2*rho_h*temp_bw3
  ke_h_bw = ke_h_bw - temp*2*temp_bw3
  t_h_bw = t_h_bw + (2*t_h-4*t_h**3)*temp_bw4
END SUBROUTINE SIGMA_GCG_BW

!  Differentiation of sigma_cg in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: t_h t_v s0cg rho_h rho_v
!   with respect to varying inputs: d t_h t_v sigma_vol_bistatic
!                rho_h rho_v
!***********************************************************
!     sigma_cg
!
!> @brief calculate canopy ground scattering coefficient This is based on Eq. 11.17 (last term) in Ulaby (2014) and 11.14 in Ulab
!y (2014)
!  (for co-pol, coherent addition can be made as an option)
!
!> @param[in]  sigma_vol_bistatic
!> @param[in]  d
!> @param[in]  coherent
!> @param[in]  rho_v
!> @param[in]  rho_h
!> @param[in]  t_h
!> @param[in]  t_v
!> @param[out] s0cg
!
! Ref: sense/model.py, l215 ff.
!
SUBROUTINE SIGMA_CG_BW(sigma_vol_bistatic, sigma_vol_bistatic_bw, d, &
& d_bw, coherent, rho_v, rho_v_bw, rho_h, rho_h_bw, t_v, t_v_bw, t_h, &
& t_h_bw, s0cg, s0cg_bw)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  IMPLICIT NONE
! arguments
!hh,vv,hv
  REAL(kind=8), INTENT(IN) :: sigma_vol_bistatic(3)
  REAL(kind=8) :: sigma_vol_bistatic_bw(3)
  REAL(kind=8), INTENT(IN) :: d, rho_v, rho_h, t_v, t_h
  REAL(kind=8) :: d_bw, rho_v_bw, rho_h_bw, t_v_bw, t_h_bw
  LOGICAL, INTENT(IN) :: coherent
!hh,vv,hv
  REAL(kind=8) :: s0cg(3)
  REAL(kind=8) :: s0cg_bw(3)
! local decls
  REAL(kind=8) :: n
  REAL(kind=8) :: temp_bw
  REAL(kind=8) :: temp_bw0
  REAL(kind=8) :: temp_bw1
  REAL(kind=8) :: temp_bw2
  REAL(kind=8) :: temp
  REAL(kind=8) :: temp_bw3
  REAL(kind=8) :: temp_bw4
  IF (coherent) THEN
    n = 2._8
  ELSE
    n = 1._8
  END IF
!-- HH
!-- VV
!-- HV
  IF (sigma_vol_bistatic(3) .EQ. sense_fv) THEN
    s0cg_bw(3) = 0.0_8
    d_bw = 0.0_8
    sigma_vol_bistatic_bw = 0.0_8
  ELSE
    sigma_vol_bistatic_bw = 0.0_8
    temp = d*t_h
    temp_bw3 = n*(rho_v+rho_h)*temp*s0cg_bw(3)
    temp_bw4 = n*sigma_vol_bistatic(3)*t_v*s0cg_bw(3)
    sigma_vol_bistatic_bw(3) = sigma_vol_bistatic_bw(3) + t_v*temp_bw3
    t_v_bw = t_v_bw + sigma_vol_bistatic(3)*temp_bw3
    rho_v_bw = rho_v_bw + temp*temp_bw4
    rho_h_bw = rho_h_bw + temp*temp_bw4
    d_bw = (rho_v+rho_h)*t_h*temp_bw4
    t_h_bw = t_h_bw + (rho_v+rho_h)*d*temp_bw4
    s0cg_bw(3) = 0.0_8
  END IF
  temp_bw = n*2*rho_v*t_v**2*s0cg_bw(2)
  temp_bw0 = n*sigma_vol_bistatic(2)*d*s0cg_bw(2)
  sigma_vol_bistatic_bw(2) = sigma_vol_bistatic_bw(2) + d*temp_bw
  rho_v_bw = rho_v_bw + t_v**2*2*temp_bw0
  t_v_bw = t_v_bw + 2**2*rho_v*t_v*temp_bw0
  s0cg_bw(2) = 0.0_8
  temp_bw1 = n*2*rho_h*t_h**2*s0cg_bw(1)
  d_bw = d_bw + sigma_vol_bistatic(1)*temp_bw1 + sigma_vol_bistatic(2)*&
&   temp_bw
  temp_bw2 = n*sigma_vol_bistatic(1)*d*s0cg_bw(1)
  sigma_vol_bistatic_bw(1) = sigma_vol_bistatic_bw(1) + d*temp_bw1
  rho_h_bw = rho_h_bw + t_h**2*2*temp_bw2
  t_h_bw = t_h_bw + 2**2*rho_h*t_h*temp_bw2
END SUBROUTINE SIGMA_CG_BW

!  Differentiation of ground_sigma in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: t_h gnd_sigma t_v
!   with respect to varying inputs: t_h t_v soil_backscatter
!***********************************************************
!     ground_sigma
!
!> @brief calculate backscattering coefficient (Eq. 11.4, p.463 Ulaby (2014))
!
!> @param[in]  soil_backscatter
!> @param[in]  t_v
!> @param[in]  t_h
!> @param[out] gnd_sigma
!
! Ref: sense/model.py, l243 ff.
!
SUBROUTINE GROUND_SIGMA_BW(soil_backscatter, soil_backscatter_bw, t_v, &
& t_v_bw, t_h, t_h_bw, gnd_sigma, gnd_sigma_bw)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  IMPLICIT NONE
! arguments
!hh,vv,hv
  REAL(kind=8), INTENT(IN) :: soil_backscatter(3)
  REAL(kind=8) :: soil_backscatter_bw(3)
  REAL(kind=8), INTENT(IN) :: t_v, t_h
  REAL(kind=8) :: t_v_bw, t_h_bw
  REAL(kind=8) :: gnd_sigma(3)
  REAL(kind=8) :: gnd_sigma_bw(3)
!-- HH
!-- VV
!-- HV
  IF (soil_backscatter(3) .EQ. sense_fv) THEN
    gnd_sigma_bw(3) = 0.0_8
    soil_backscatter_bw = 0.0_8
  ELSE
    soil_backscatter_bw = 0.0_8
    soil_backscatter_bw(3) = soil_backscatter_bw(3) + t_v*t_h*&
&     gnd_sigma_bw(3)
    t_v_bw = t_v_bw + soil_backscatter(3)*t_h*gnd_sigma_bw(3)
    t_h_bw = t_h_bw + soil_backscatter(3)*t_v*gnd_sigma_bw(3)
    gnd_sigma_bw(3) = 0.0_8
  END IF
  soil_backscatter_bw(2) = soil_backscatter_bw(2) + t_v**2*gnd_sigma_bw(&
&   2)
  t_v_bw = t_v_bw + soil_backscatter(2)*2*t_v*gnd_sigma_bw(2)
  gnd_sigma_bw(2) = 0.0_8
  soil_backscatter_bw(1) = soil_backscatter_bw(1) + t_h**2*gnd_sigma_bw(&
&   1)
  t_h_bw = t_h_bw + soil_backscatter(1)*2*t_h*gnd_sigma_bw(1)
END SUBROUTINE GROUND_SIGMA_BW

!  Differentiation of oh92_backscatter in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: backscatter
!   with respect to varying inputs: eps
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file Oh92.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of ...
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE OH92_BACKSCATTER_BW(eps, eps_bw, ks, theta, backscatter, &
& backscatter_bw)
  USE MO_SENSIMUL_S1, ONLY : pi
  IMPLICIT NONE
! arguments
  COMPLEX(kind=8), INTENT(IN) :: eps
  COMPLEX(kind=8) :: eps_bw
  REAL(kind=8), INTENT(IN) :: ks, theta
!hh,vv,hv
  REAL(kind=8) :: backscatter(3)
  REAL(kind=8) :: backscatter_bw(3)
! local declarations
  REAL(kind=8) :: v, h
  REAL(kind=8) :: v_bw, h_bw
  REAL(kind=8) :: frsn0
  REAL(kind=8) :: frsn0_bw
  REAL(kind=8) :: p, q, vv0
  REAL(kind=8) :: p_bw, q_bw, vv0_bw
  REAL(kind=8), EXTERNAL :: FRESNEL0
  EXTERNAL REFLECTIVITY
  EXTERNAL REFLECTIVITY_BW
!-- Nadir Fresnel reflectivity
  frsn0 = FRESNEL0(eps)
!--
  CALL REFLECTIVITY(theta, eps, v, h)
!
  p = CALC_P()
  q = CALC_Q()
  vv0 = CALC_VV()
  q_bw = vv0*backscatter_bw(3)
  vv0_bw = q*backscatter_bw(3)
  backscatter_bw(3) = 0.0_8
  vv0_bw = vv0_bw + backscatter_bw(2)
  backscatter_bw(2) = 0.0_8
  p_bw = vv0*backscatter_bw(1)
  vv0_bw = vv0_bw + p*backscatter_bw(1)
  CALL CALC_VV_BW0(vv0_bw)
  CALL CALC_Q_BW0(q_bw)
  CALL CALC_P_BW0(p_bw)
  eps_bw = (0.0_4,0.0_4)
  CALL REFLECTIVITY_BW(theta, eps, eps_bw, v, v_bw, h, h_bw)
  CALL FRESNEL0_BW0(eps, eps_bw, frsn0_bw)

CONTAINS
!  Differentiation of calc_p in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: frsn0 calc_p
!   with respect to varying inputs: frsn0
  SUBROUTINE CALC_P_BW0(calc_p_bw)
    IMPLICIT NONE
    REAL(kind=8) :: a
    REAL(kind=8) :: a_bw
    INTRINSIC EXP
    REAL(kind=8) :: temp
    REAL(kind=8) :: temp0
    REAL(kind=8) :: temp1
    REAL(kind=8) :: calc_p
    REAL(kind=8) :: calc_p_bw
    a = 1._8/(3._8*frsn0)
    temp1 = 2._8*theta/pi
    temp0 = temp1**a
    temp = EXP(-ks)
    IF (temp1 .LE. 0.0_8) THEN
      a_bw = 0.0
    ELSE
      a_bw = -(temp*2*(1._8-temp*temp0)*temp0*LOG(temp1)*calc_p_bw)
    END IF
    frsn0_bw = frsn0_bw - a_bw/(3._8*frsn0**2)
  END SUBROUTINE CALC_P_BW0
  REAL(kind=8) FUNCTION CALC_P()
    IMPLICIT NONE
    REAL(kind=8) :: a
    INTRINSIC EXP
    a = 1._8/(3._8*frsn0)
    calc_p = (1._8-(2._8*theta/pi)**a*EXP(-ks))**2
  END FUNCTION CALC_P
!  Differentiation of calc_q in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: calc_q
!   with respect to varying inputs: frsn0
  SUBROUTINE CALC_Q_BW0(calc_q_bw)
    IMPLICIT NONE
    INTRINSIC EXP
    REAL(kind=8) :: calc_q
    REAL(kind=8) :: calc_q_bw
    frsn0_bw = 0.23_8*(1._8-EXP(-ks))*0.5_8*frsn0**(-0.5)*calc_q_bw
  END SUBROUTINE CALC_Q_BW0
  REAL(kind=8) FUNCTION CALC_Q()
    IMPLICIT NONE
    INTRINSIC EXP
    calc_q = 0.23_8*frsn0**0.5_8*(1._8-EXP(-ks))
  END FUNCTION CALC_Q
!  Differentiation of calc_vv in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: p calc_vv
!   with respect to varying inputs: h p v
  SUBROUTINE CALC_VV_BW0(calc_vv_bw)
    IMPLICIT NONE
    REAL(kind=8) :: a, b
    REAL(kind=8) :: b_bw
    INTRINSIC EXP
    INTRINSIC COS
    INTRINSIC SQRT
    REAL(kind=8) :: temp
    REAL(kind=8) :: temp_bw
    REAL(kind=8) :: calc_vv_bw
    REAL(kind=8) :: calc_vv
    a = 0.7_8*(1._8-EXP(-(0.65_8*ks**1.8)))
    b_bw = a*calc_vv_bw
    temp = SQRT(p)
    temp_bw = COS(theta)**3._8*b_bw/temp
    v_bw = temp_bw
    h_bw = temp_bw
    IF (.NOT.p .EQ. 0.0_8) p_bw = p_bw - (v+h)*temp_bw/(temp**2*2.0)
  END SUBROUTINE CALC_VV_BW0
  REAL(kind=8) FUNCTION CALC_VV()
    IMPLICIT NONE
    REAL(kind=8) :: a, b
    INTRINSIC EXP
    INTRINSIC COS
    INTRINSIC SQRT
    a = 0.7_8*(1._8-EXP(-(0.65_8*ks**1.8)))
    b = COS(theta)**3._8*(v+h)/SQRT(p)
    calc_vv = a*b
  END FUNCTION CALC_VV
END SUBROUTINE OH92_BACKSCATTER_BW

!  Differentiation of fresnel0 in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: e fresnel0
!   with respect to varying inputs: e
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file core.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of core routines ported from Sentinel Simulator (sense/core.py)
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     fresnel0
!
!> @brief calculate the Nadir Fresnel reflectivity (e.g. Ulaby (2014), eq. 10.36)
!
!> @param[in]  e  complex relative dielectric permitivity
!
!> \return reflectivity
!
! Ref: sense/core.py, l4 ff.
!
SUBROUTINE FRESNEL0_BW0(e, e_bw, fresnel0_bw)
  IMPLICIT NONE
  COMPLEX(kind=8), INTENT(IN) :: e
  COMPLEX(kind=8) :: e_bw
  COMPLEX(kind=8) :: hlp
  COMPLEX(kind=8) :: hlp_bw
! interfaces
  REAL(kind=8), EXTERNAL :: CSQ2
  INTRINSIC SQRT
  COMPLEX(kind=8) :: temp
  COMPLEX(kind=8) :: temp0
  COMPLEX*8 :: temp_bw
  REAL(kind=8) :: fresnel0
  REAL(kind=8) :: fresnel0_bw
! fresnel0 = abs( (1._8 - sqrt(e))/(1._8+sqrt(e)) )**2
  hlp = (1._8-SQRT(e))/(1._8+SQRT(e))
  CALL CSQ2_BW1(hlp, hlp_bw, fresnel0_bw)
  temp0 = SQRT(e)
  temp_bw = hlp_bw/(temp0+1._8)
  temp = SQRT(e)
  IF (.NOT.e .EQ. 0.0_8) e_bw = e_bw + (-((1._8-temp)/((temp0+1._8)*2.0*&
&     temp0))-1.0/(2.0*temp))*temp_bw
END SUBROUTINE FRESNEL0_BW0

!  Differentiation of reflectivity in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: h v eps
!   with respect to varying inputs: eps
!***********************************************************
!     reflectivity
!
!> @brief calculate reflectivity for H and V polarisation (table 2.5 Ulaby (2014), assumes specular surface)
!
!> @param[in]   theta  incidence angle [rad]
!> @param[in]   eps    relative dielectric permitivity (complex)
!> @param[out]  v      reflectivity ver. pol.
!> @param[out   h      reflectivity hor. pol.
!
! Ref: sense/core.py, l26 ff.
!
SUBROUTINE REFLECTIVITY_BW(theta, eps, eps_bw, v, v_bw, h, h_bw)
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: theta
  COMPLEX(kind=8), INTENT(IN) :: eps
  COMPLEX(kind=8) :: eps_bw
  REAL(kind=8) :: v, h
  REAL(kind=8) :: v_bw, h_bw
! interfaces
  REAL(kind=8), EXTERNAL :: CSQ2
! local vars
  COMPLEX(kind=8) :: rho_v, rho_h
  COMPLEX(kind=8) :: rho_v_bw, rho_h_bw
  CALL CALC_REFLECTION_COEFFICIENTS(theta, eps, rho_v, rho_h)
! v = abs(rho_v)**2
! h = abs(rho_h)**2
! v = real(rho_v)**2 + aimag(rho_v)**2
! h = real(rho_h)**2 + aimag(rho_h)**2
  CALL CSQ2_BW1(rho_h, rho_h_bw, h_bw)
  CALL CSQ2_BW1(rho_v, rho_v_bw, v_bw)
  CALL CALC_REFLECTION_COEFFICIENTS_BW(theta, eps, eps_bw, rho_v, &
&                                rho_v_bw, rho_h, rho_h_bw)
END SUBROUTINE REFLECTIVITY_BW

!  Differentiation of calc_reflection_coefficients in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: eps rho_h rho_v
!   with respect to varying inputs: eps
!***********************************************************
!     calc_reflection_coefficients
!
!> @brief calculate reflection coefficients (Woodhouse, 2006; Eq. 5.54, 5.55)
!
!> @param[in]   theta  incidence angle [rad]
!> @param[in]   eps    relative dielectric permitivity (complex)
!> @param[out]  rho_v  reflection coefficent, vertical pol. (complex)
!> @param[out   rho_h  reflection coefficient, horizontal pol. (complex)
!
! Ref: sense/core.py, l47 ff.
!
SUBROUTINE CALC_REFLECTION_COEFFICIENTS_BW(theta, eps, eps_bw, rho_v, &
& rho_v_bw, rho_h, rho_h_bw)
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: theta
  COMPLEX(kind=8), INTENT(IN) :: eps
  COMPLEX(kind=8) :: eps_bw
  COMPLEX(kind=8) :: rho_v, rho_h
  COMPLEX(kind=8) :: rho_v_bw, rho_h_bw
! local variables
  REAL(kind=8) :: co, si2
  COMPLEX(kind=8) :: hlp
  COMPLEX(kind=8) :: hlp_bw
  INTRINSIC COS
  INTRINSIC SIN
  INTRINSIC SQRT
  COMPLEX(kind=8) :: temp_bw
  COMPLEX(kind=8) :: temp_bw0
  COMPLEX(kind=8) :: temp_bw1
  co = COS(theta)
  si2 = SIN(theta)**2
  hlp = SQRT(eps - si2)
  temp_bw0 = rho_v_bw/(co*eps+hlp)
  temp_bw1 = -((co*eps-hlp)*temp_bw0/(co*eps+hlp))
  temp_bw = rho_h_bw/(co+hlp)
  hlp_bw = temp_bw1 - temp_bw0 + ((-1.0)-(co-hlp)/(co+hlp))*temp_bw
  IF (eps - si2 .EQ. 0.0_8) THEN
    eps_bw = eps_bw + co*temp_bw1 + co*temp_bw0
  ELSE
    eps_bw = eps_bw + hlp_bw/(2.0*SQRT(eps-si2)) + co*temp_bw1 + co*&
&     temp_bw0
  END IF
END SUBROUTINE CALC_REFLECTION_COEFFICIENTS_BW

!  Differentiation of csq2 in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: csq2
!   with respect to varying inputs: z
!***********************************************************
!     csq2
!
!> @brief computes square of absolute value of complex number 
!
!> @param[in]  z  complex number
!> \return     |z|^2
!
SUBROUTINE CSQ2_BW0(z, z_bw, csq2_bw)
  IMPLICIT NONE
  COMPLEX(kind=8), INTENT(IN) :: z
  COMPLEX(kind=8) :: z_bw
  INTRINSIC REAL
  INTRINSIC AIMAG
  EXTERNAL AIMAG_BW
  REAL :: result1
  REAL :: result1_bw
  REAL(kind=8) :: csq2_bw
  REAL(kind=8) :: csq2
!  csq2 = abs(z)**2
  result1 = AIMAG(z)
  z_bw = 2*REAL(z)*csq2_bw
  result1_bw = 2*result1*csq2_bw
  CALL AIMAG_BW(z, z_bw, result1_bw)
END SUBROUTINE CSQ2_BW0

!  Differentiation of scatrayleigh_sigma_v_bistatic in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: backscatter
!   with respect to varying inputs: sigma_s_hh sigma_s_vv
!***********************************************************
!     ScatRayleigh_sigma_v_bistatic
!
!>  @brief compute backscattering coefficient from volume extinction coefficient(s) for Rayleigh scatterer (Ulceby (Eq. 11.22))
!
!> @param[in]  sigma_s_hh   volume extinction coefficient
!> @param[in]  sigma_s_vv   volume extinction coefficient
!> @param[out] backscatter  volume backscattering coefficient
!
! Ref: sense/scatterer.py, l60 ff.
!
SUBROUTINE SCATRAYLEIGH_SIGMA_V_BISTATIC_BW(sigma_s_vv, sigma_s_vv_bw, &
& sigma_s_hh, sigma_s_hh_bw, backscatter, backscatter_bw)
  IMPLICIT NONE
  REAL(kind=8), INTENT(IN) :: sigma_s_vv, sigma_s_hh
  REAL(kind=8) :: sigma_s_vv_bw, sigma_s_hh_bw
!'hh','vv','hv'
  REAL(kind=8) :: backscatter(3)
  REAL(kind=8) :: backscatter_bw(3)
  sigma_s_vv_bw = 0.0_8
  sigma_s_hh_bw = 0.0_8
  CALL SCATRAYLEIGH_SIGMA_V_BACK_BW(sigma_s_vv, sigma_s_vv_bw, &
&                             sigma_s_hh, sigma_s_hh_bw, backscatter, &
&                             backscatter_bw)
END SUBROUTINE SCATRAYLEIGH_SIGMA_V_BISTATIC_BW

!  Differentiation of scatrayleigh_sigma_v_back in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: sigma_s_hh backscatter sigma_s_vv
!   with respect to varying inputs: sigma_s_hh sigma_s_vv
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file scatterer.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: Fortran90 implemenation of scatterer class ported from Sentinel Simulator (sense/scatterer.py)
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     ScatRayleigh_sigma_v_back
!
!> @brief compute backscattering coefficient from volume extinction coefficient(s) for Rayleigh scatterer
!
!> @param[in]  sigma_s_hh   volume extinction coefficient
!> @param[in]  sigma_s_vv   volume extinction coefficient
!> @param[out] backscatter  volume backscattering coefficient
!
! Ref: sense/scatterer.py, l56 ff.
!
SUBROUTINE SCATRAYLEIGH_SIGMA_V_BACK_BW(sigma_s_vv, sigma_s_vv_bw, &
& sigma_s_hh, sigma_s_hh_bw, backscatter, backscatter_bw)
  USE MO_SENSIMUL_S1, ONLY : sense_fv
  IMPLICIT NONE
  REAL(kind=8), INTENT(IN) :: sigma_s_vv, sigma_s_hh
  REAL(kind=8) :: sigma_s_vv_bw, sigma_s_hh_bw
!'hh','vv','hv'
  REAL(kind=8) :: backscatter(3)
  REAL(kind=8) :: backscatter_bw(3)
  backscatter_bw(3) = 0.0_8
  sigma_s_vv_bw = sigma_s_vv_bw + 1.5_8*backscatter_bw(2)
  backscatter_bw(2) = 0.0_8
  sigma_s_hh_bw = sigma_s_hh_bw + 1.5_8*backscatter_bw(1)
END SUBROUTINE SCATRAYLEIGH_SIGMA_V_BACK_BW

!  Differentiation of simulate_s2 in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: y
!   with respect to varying inputs: x y
!***********************************************************
!     simulate_s2
!
!> @brief Implementation of the S2 observation operator.
!>        Computes top-of-canopy BRFs in all 13 Sentinel2 bands for every
!>        state in the control vector.
!
!
!> @param[in]   n  length of control vector for multiple simulations in the optical domain
!> @param[in]   x  S2 relevant part of full control vector in physical units.
!                  (expected ordering is: state variables LAI,HC,SM per state)
!> @param[in]   m  length of output vector
!> @param[out]  y  simulated TOC BRFs (for all 13 S2 wave-bands) and multiple observations
!                  (ordering will be BRF1-BRF12 per state)
!
SUBROUTINE SIMULATE_S2_BW(n, x, x_bw, m, y, y_bw)
  USE MO_SENSIMUL, ONLY : nsc, npts_s2, iv_geom, get_nc_s2, get_m_s2, &
& timept_idxs_s2
  USE MO_SENSIMUL_S2, ONLY : nb_s2
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, m
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: y(m)
  REAL(kind=8) :: y_bw(m)
! external
  EXTERNAL SIMULATE_S2_1GEOM
  EXTERNAL SIMULATE_S2_1GEOM_BW
! local decls
  INTEGER :: ipt, ipt_s2
  INTEGER :: ii0, ii1, j0, j1
  REAL(kind=8) :: statev(nsc)
  REAL(kind=8) :: statev_bw(nsc)
  REAL(kind=8) :: single_ivgeom(4)
  INTEGER :: res
  INTEGER :: res0
  INTEGER :: res1
  INTEGER :: res2
!-- dimension consistency
  res = GET_NC_S2()
  IF (n .NE. res) THEN
    STOP
  ELSE
    res1 = GET_M_S2()
    IF (m .NE. res1) THEN
      res2 = GET_M_S2()
      WRITE(*, '(a,2(a,i3,1x))') &
&     ' FATAL::simulate_s2:inconsistent length of result vector.', &
&     'expected=', res2, 'got=', m
    END IF
!-- loop over all time-points
    ii0 = 1
    j0 = 1
!!! !$AD II-LOOP
simloop:DO ipt=1,npts_s2
      CALL PUSHINTEGER4(ii1)
      ii1 = ii0 + nsc - 1
      CALL PUSHINTEGER4(j1)
      j1 = j0 + nb_s2 - 1
      CALL PUSHREAL8ARRAY(statev, nsc)
      statev(1:nsc) = x(ii0:ii1)
      ipt_s2 = timept_idxs_s2(ipt)
      single_ivgeom(1:4) = iv_geom(1:4, ipt_s2)
! TAPENADE: (AD07) Data-Flow recovery (TBR) on this call to simulate_s2_1geom needs to save the I-O state
! TAPENADE: (AD14) Checkpointing this call to simulate_s2_1geom needs to save an undeclared side-effect variable: /ga/[256,512[
! TAPENADE: (AD14) Checkpointing this call to simulate_s2_1geom needs to save an undeclared side-effect variable: /ga/[0,256[
! TAPENADE: (AD14) Checkpointing this call to simulate_s2_1geom needs to save an undeclared side-effect variable: /multi/[13440,20160[
! TAPENADE: (AD14) Checkpointing this call to simulate_s2_1geom needs to save an undeclared side-effect variable: /multi/[6720,13440[
! TAPENADE: (AD14) Checkpointing this call to simulate_s2_1geom needs to save an undeclared side-effect variable: /multi/[0,6720[
      CALL SIMULATE_S2_1GEOM(statev, single_ivgeom, y(j0:j1))
!-- increment start position
      CALL PUSHINTEGER4(ii0)
      ii0 = ii1 + 1
      CALL PUSHINTEGER4(j0)
      j0 = j1 + 1
    END DO simloop
    x_bw = 0.0_8
    statev_bw = 0.0_8
    DO ipt=npts_s2,1,-1
      CALL POPINTEGER4(j0)
      CALL POPINTEGER4(ii0)
      ipt_s2 = timept_idxs_s2(ipt)
      single_ivgeom(1:4) = iv_geom(1:4, ipt_s2)
      CALL SIMULATE_S2_1GEOM_BW(statev, statev_bw, single_ivgeom, y(j0:&
&                         j1), y_bw(j0:j1))
      CALL POPREAL8ARRAY(statev, nsc)
      x_bw(ii0:ii1) = x_bw(ii0:ii1) + statev_bw
      statev_bw = 0.0_8
      CALL POPINTEGER4(j1)
      CALL POPINTEGER4(ii1)
    END DO
  END IF
END SUBROUTINE SIMULATE_S2_BW

!  Differentiation of simulate_s2_1geom in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: brf statev /multi/[0,6720[
!                /multi/[6720,13440[ /multi/[13440,20160[
!   with respect to varying inputs: brf statev /multi/[0,6720[
!                /multi/[6720,13440[ /multi/[13440,20160[
!***********************************************************
!     simulate_s2_1geom
!
!> @brief Implementation of the Sentinel Synergy Study observation operator
!>        in the optical domain (denoted H_2 in document D5) for a single state.
!         
!
!> @details For the given input state (LAI,HC, and SM) the observation operator
!>          derives TOC BRFs for all 13 S2 wave-bands. The implementation is based
!>          on the coupled SemiDiscrete-PROSPECT-PRICE model.
!>          Running the SemiDiscrete model requires to specify the illumination- and
!>          view geometry.
!
!> @param[in]   statev   state-vector consisting of LAI, HC, and SM
!> @param[in]   iv_geom  illumination-view geomtry in order sza,saa,vza,vaa (in degrees)
!> @param[out]  brf      TOC BRFs for 13 S2 wave-bands
!
SUBROUTINE SIMULATE_S2_1GEOM_BW(statev, statev_bw, iv_geom, brf, brf_bw)
  USE MO_SENSIMUL, ONLY : nsc
  USE MO_SENSIMUL_S2
  IMPLICIT NONE
! arguments
  REAL(kind=8), INTENT(IN) :: statev(nsc)
  REAL(kind=8) :: statev_bw(nsc)
!sza,saa,vza,vaa
  REAL(kind=8), INTENT(IN) :: iv_geom(4)
  REAL(kind=8) :: brf(nb_s2)
  REAL(kind=8) :: brf_bw(nb_s2)
! local decls
  REAL :: lai, hc, sm
  REAL :: lai_bw, hc_bw, sm_bw
  REAL :: rsl1
  REAL :: rsl1_bw
  REAL :: theta_i, phi_i, theta_v, phi_v
!'nadim_prospect_price_fast_1geom' does not expect kind=8 !
  REAL :: brf_(nb_s2)
  REAL :: brf__bw(nb_s2)
! externals
  REAL, EXTERNAL :: SM_TO_RSL1
  EXTERNAL NADIM_PROSPECT_PRICE_FAST_1GEOM
  EXTERNAL NADIM_PROSPECT_PRICE_FAST_1GEOM_BW
  INTRINSIC REAL
!-- map state variables
!   (potential cast from r8 to r4)
  lai = statev(1)
  hc = statev(2)
  sm = statev(3)
!-- 1st spectral vector of soil reflectance (of Price's EOF)
!   is modulated by the soil moisture state
  rsl1 = SM_TO_RSL1(sm, rsl1_default, sm_coeff)
!-- geometry
  theta_i = iv_geom(1)
  phi_i = iv_geom(2)
  theta_v = iv_geom(3)
  phi_v = iv_geom(4)
! TAPENADE: (AD07) Data-Flow recovery (TBR) on this call to nadim_prospect_price_fast_1geom needs to save the I-O state
! TAPENADE: (AD14) Checkpointing this call to nadim_prospect_price_fast_1geom needs to save an undeclared side-effect variable: /multi/[13440,20160[
! TAPENADE: (AD14) Checkpointing this call to nadim_prospect_price_fast_1geom needs to save an undeclared side-effect variable: /multi/[6720,13440[
! TAPENADE: (AD14) Checkpointing this call to nadim_prospect_price_fast_1geom needs to save an undeclared side-effect variable: /multi/[0,6720[
! TAPENADE: (AD14) Checkpointing this call to nadim_prospect_price_fast_1geom needs to save an undeclared side-effect variable: /ga/[256,512[
! TAPENADE: (AD14) Checkpointing this call to nadim_prospect_price_fast_1geom needs to save an undeclared side-effect variable: /ga/[0,256[
!-- call coupled optical model
  CALL NADIM_PROSPECT_PRICE_FAST_1GEOM(nb_s2, nw1nm, s2_response_mat, &
&                                theta_i, phi_i, theta_v, phi_v, lad, &
&                                rpl, lai, hc, vai, cab, cw, cp, cc, &
&                                rsl1, rsl2, rsl3, rsl4, brf_)
!-- re-cast buffer
  brf__bw = 0.0_8
  brf__bw = brf__bw + brf_bw
  brf_bw = 0.0_8
  CALL NADIM_PROSPECT_PRICE_FAST_1GEOM_BW(nb_s2, nw1nm, s2_response_mat&
&                                   , theta_i, phi_i, theta_v, phi_v, &
&                                   lad, rpl, lai, lai_bw, hc, hc_bw, &
&                                   vai, cab, cw, cp, cc, rsl1, rsl1_bw&
&                                   , rsl2, rsl3, rsl4, brf_, brf__bw)
  CALL SM_TO_RSL1_BW0(sm, sm_bw, rsl1_default, sm_coeff, rsl1_bw)
  statev_bw(3) = statev_bw(3) + sm_bw
  statev_bw(2) = statev_bw(2) + hc_bw
  statev_bw(1) = statev_bw(1) + lai_bw
END SUBROUTINE SIMULATE_S2_1GEOM_BW

!  Differentiation of nadim_prospect_price_fast_1geom in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8
!):
!   gradient     of useful results: brf /multi/[0,6720[ /multi/[6720,13440[
!                /multi/[13440,20160[
!   with respect to varying inputs: lai hc rsl1 /multi/[0,6720[
!                /multi/[6720,13440[ /multi/[13440,20160[
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!> \file semiD_ftn.f90
!
!> PROJECT : Sentinel Synergy Study
!
!> DESCRIPTION: main routine of the coupled Semidiscrite-Prospect-Price model provided by
!               Tristan Quaife and implemented as mixed Fortran/C code being ported
!               to pure Fortran implementation.
!               This aims for smooth application of an AD tool and may also yield small performance
!               gain.
!
!> \authors The Inversion Lab (Michael Vossbeck) 
!
!> \date  February/April/August 2018
!                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!***********************************************************
!     nadim_prospect_price_fast_1geom
!
!> @brief runs coupled NADIM-PROSPECT-PRICE model and computes  BRFs for 'nb' (broad) bands and a single illumination/view geomet
!ry
!
!> @details TBD
!
!> @param[in]  nb           number of wave-bands
!> @param[in]  nw1nm        number of 1nm wavelengths in range [400nm,2500nm]
!> @param[in]  resp_mat     responses for every wavelength in [400nm,2500nm] and all 'nb' bands
!> @param[in]  theta_i      illumination zenith angle [deg]
!> @param[in]  phi_i        illumination azimuth angle [deg]
!> @param[in]  theta_v      viewing zenith angle [deg]
!> @param[in]  phi_v        viewing azimuth angle [deg]
!> @param[in]  lad          Leaf angle distribution (1:Planophile, 2:Erectophile, 3:Plagiophile, 4:Extremophile, 5:Uniforme
!> @param[in]  rpl          radius of single leaf
!> @param[in]  lai          leaf area index [m^2/m^2]
!> @param[in]  hc           canopy height [m]
!> @param[in]  vai          leaf structure (PROSPECT)
!> @param[in]  cab          leaf chlorophyll (PROSPECT)
!> @param[in]  cw           leaf water equivelent thickness (PROSPECT)
!> @param[in]  cp           protein concentration (PROSPECT)
!> @param[in]  cc           cellulose and lignin (PROSPECT)
!> @param[in]  rsl1         weight of first spectral vector of the soil reflectance (PRICE)
!> @param[in]  rsl2         weight of second spectral vector of the soil reflectance (PRICE)
!> @param[in]  rsl3         weight of third spectral vector of the soil reflectance (PRICE)
!> @param[in]  rsl4         weight of fourth spectral vector of the soil reflectance (PRICE)
!> @param[out] brf          Bidirectional reflectance factor
!
SUBROUTINE NADIM_PROSPECT_PRICE_FAST_1GEOM_BW(nb, nw1nm, resp_mat, &
& theta_i, phi_i, theta_v, phi_v, lad, rpl, lai, lai_bw, hc, hc_bw, vai&
& , cab, cw, cp, cc, rsl1, rsl1_bw, rsl2, rsl3, rsl4, brf, brf_bw)
  IMPLICIT NONE
! constants
!number of view--illumination geometries
  INTEGER, PARAMETER :: niv=1
! arguments
  INTEGER, INTENT(IN) :: nb, nw1nm
  REAL, INTENT(IN) :: theta_i, phi_i, theta_v, phi_v
  INTEGER, INTENT(IN) :: lad
  REAL, INTENT(IN) :: rpl, lai, hc
  REAL :: lai_bw, hc_bw
  REAL(kind=8), INTENT(IN) :: vai, cab, cw, cp, cc
  REAL, INTENT(IN) :: rsl1, rsl2, rsl3, rsl4
  REAL :: rsl1_bw
  REAL(kind=8), INTENT(IN) :: resp_mat(nw1nm, nb)
  REAL :: brf(nb)
  REAL :: brf_bw(nb)
! externals
  EXTERNAL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN
  EXTERNAL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_BW
  EXTERNAL PROSPECT_FULLSPECTRUM_INTERP1NM_FTN
  REAL(kind=8), EXTERNAL :: CONVOLVE
! local variables
  INTEGER :: ib
! leaf reflectance/transmittance
  REAL(kind=8) :: p_rl(nw1nm), p_tl(nw1nm)
! soil reflectance
  REAL(kind=8) :: p_rs(nw1nm)
  REAL(kind=8) :: p_rs_bw(nw1nm)
! values for individual S2 bands
  REAL(kind=8) :: rl_8(nb), tl_8(nb), rs_8(nb)
  REAL(kind=8) :: rs_8_bw(nb)
! ...as normal 'real'
  REAL :: rl(nb), tl(nb), rs(nb)
  REAL :: rs_bw(nb)
  REAL :: theta_v_asarr(niv), phi_v_asarr(niv)
  REAL :: brf_nadim(1)
  REAL :: brf_nadim_bw(1)
! ! D E B U G
! integer, save :: cnt = 0
! character(len=1) :: cbuf
! character(len=2) :: ccbuf
! cnt = cnt + 1
! write(cbuf, '(i1)') cnt
!-- scalar to 1D array
  theta_v_asarr(1) = theta_v
  phi_v_asarr(1) = phi_v
!-- get leaf optical properties: [400nm,2500nm] at 1nm resolution
  CALL PROSPECT_FULLSPECTRUM_INTERP1NM_FTN(vai, cab, cw, cp, cc, p_rl, &
&                                    p_tl)
! get soil reflectance: [400nm,2500nm] at 1nm resolution
  CALL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN(rsl1, rsl2, rsl3, rsl4, &
&                                      p_rs)
!-- loop over S2 bands
!!! !$AD II-LOOP
bndloop:DO ib=1,nb
    rs_8(ib) = CONVOLVE(nw1nm, p_rs, resp_mat(1:nw1nm, ib))
    rl_8(ib) = CONVOLVE(nw1nm, p_rl, resp_mat(1:nw1nm, ib))
    tl_8(ib) = CONVOLVE(nw1nm, p_tl, resp_mat(1:nw1nm, ib))
    rs(ib) = rs_8(ib)
    rl(ib) = rl_8(ib)
    tl(ib) = tl_8(ib)
! TAPENADE: (AD14) Checkpointing this call to nadimbrf needs to save an undeclared side-effect variable: /ga/[256,512[
! TAPENADE: (AD14) Checkpointing this call to nadimbrf needs to save an undeclared side-effect variable: /ga/[0,256[
! TAPENADE: (AD14) Checkpointing this call to nadimbrf needs to save an undeclared side-effect variable: /multi/[13440,20160[
! TAPENADE: (AD14) Checkpointing this call to nadimbrf needs to save an undeclared side-effect variable: /multi/[6720,13440[
! TAPENADE: (AD14) Checkpointing this call to nadimbrf needs to save an undeclared side-effect variable: /multi/[0,6720[
!-- BRF computation by NADIM
    CALL NADIMBRF(theta_i, phi_i, niv, theta_v_asarr, phi_v_asarr, lad, &
&           rs(ib), hc, lai, rpl, rl(ib), tl(ib), brf_nadim)
!-- save NADIM BRF
  END DO bndloop
  lai_bw = 0.0_8
  hc_bw = 0.0_8
  brf_nadim_bw = 0.0_8
  p_rs_bw = 0.0_8
  rs_bw = 0.0_8
  rs_8_bw = 0.0_8
  DO ib=nb,1,-1
    brf_nadim_bw(1) = brf_nadim_bw(1) + brf_bw(ib)
    brf_bw(ib) = 0.0_8
    CALL NADIMBRF_BW(theta_i, phi_i, niv, theta_v_asarr, phi_v_asarr, &
&              lad, rs(ib), rs_bw(ib), hc, hc_bw, lai, lai_bw, rpl, rl(&
&              ib), tl(ib), brf_nadim, brf_nadim_bw)
    rs_8_bw(ib) = rs_8_bw(ib) + rs_bw(ib)
    rs_bw(ib) = 0.0_8
    CALL CONVOLVE_BW0(nw1nm, p_rs, p_rs_bw, resp_mat(1:nw1nm, ib), &
&               rs_8_bw(ib))
    rs_8_bw(ib) = 0.0_8
  END DO
  CALL PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_BW(rsl1, rsl1_bw, rsl2, &
&                                         rsl3, rsl4, p_rs, p_rs_bw)
END SUBROUTINE NADIM_PROSPECT_PRICE_FAST_1GEOM_BW

!  Differentiation of price_soil_fullspectrum_interp1nm_ftn in reverse (adjoint) mode (with options messagesInFile noinclude noIS
!IZE r8):
!   gradient     of useful results: refl
!   with respect to varying inputs: w1
SUBROUTINE PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_BW(w1, w1_bw, w2, w3, &
& w4, refl, refl_bw)
  USE MO_SOIL
  IMPLICIT NONE
! arguments
  REAL, INTENT(IN) :: w1, w2, w3, w4
  REAL :: w1_bw
  REAL(kind=8) :: refl(nw)
  REAL(kind=8) :: refl_bw(nw)
! local variables
  INTEGER :: upper, lower
  REAL :: fraction, rs_lower, rs_upper
  REAL :: rs_lower_bw, rs_upper_bw
  INTEGER :: w
  INTRINSIC INT
  INTRINSIC REAL
  INTEGER :: branch
  DO w=1,nw
!-- NOTE: 'w-1' since v1,...,v4 use 0-indexing
    CALL PUSHINTEGER4(lower)
    lower = INT((w-1)/5.0)
    IF (lower .EQ. nws - 1) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHREAL8(fraction)
      fraction = REAL(w-1)/5.0 - REAL(lower)
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  w1_bw = 0.0_8
  DO w=nw,1,-1
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      rs_lower_bw = (1.-fraction)*refl_bw(w)
      rs_upper_bw = fraction*refl_bw(w)
      refl_bw(w) = 0.0_8
      upper = lower + 1
      w1_bw = w1_bw + v1(upper)*rs_upper_bw
      CALL POPREAL8(fraction)
    ELSE
      rs_lower_bw = refl_bw(w)
      refl_bw(w) = 0.0_8
    END IF
    w1_bw = w1_bw + v1(lower)*rs_lower_bw
    CALL POPINTEGER4(lower)
  END DO
END SUBROUTINE PRICE_SOIL_FULLSPECTRUM_INTERP1NM_FTN_BW

!  Differentiation of nadimbrf in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: i0 xif xi1u brf xlai xhc xrs
!   with respect to varying inputs: i0 xif xi1u brf xlai xhc xrs
!**************************************************************
!  Name : nadimbrf.f
!***************************************************************
SUBROUTINE NADIMBRF_BW(theta_i, phi_i, nv, theta_v, phi_v, lad, xrs, &
& xrs_bw, xhc, xhc_bw, xlai, xlai_bw, rpl, xrl, xtl, brf, brf_bw)
  IMPLICIT NONE
  INTEGER :: lad, nv
  REAL :: brf(nv)
  REAL :: brf_bw(nv)
  REAL :: theta_v(nv), phi_v(nv), theta_i, phi_i
  REAL :: xlai, xhc, rpl, xrl, xtl, xrs
  REAL :: xlai_bw, xhc_bw, xrs_bw
!***********************************************
!
!     Subroutine NADIMBRDF.f
!
!**********************************************
!
!  Output variable : BRF   = Bidirectional Reflectance Factor 
!
! 
!  Input variables :
!                       NV      = NUMBER OF VIEWING ANGLES
!                       THETA_I = SOLAR ZENITH ANGLE (IN DEGREES)
!                       PHI_I   = SOLAR AZIMUTH ANGLE (IN DEGREES)
!                       THETA_V = VIEWING ZENITH ANGLE (IN RADIANS)
!                       PHI_V   = VIEWING AZIMUTH ANGLE (IN RADIANS)
!
!                       LAD     = Leaf Angle Distribution
!                       = 1   <---> Planophile
!                       = 2   <---> Erectophile
!                       = 3   <---> Plagiophile
!                       = 4   <---> Extremophile
!                       = 5   <---> Uniforme
!
!                       XRS     = SOIL ALBEDO
!                       XHC     = HEIGHT OF THE CANOPY
!                       XLAI    = Leaf Area Index
!                       RPL     = radius of a single leaf
!                       XRL     = leaf reflectance
!                       XTL     = leaf transmittance
!
!************************************************************ 
!
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x_lambda_i, r1, r2, r3, xmeas
  REAL :: r1_bw, r2_bw, r3_bw, xmeas_bw
!     MVO::n_c type changed
!$$$      real df,x_nf,a_f,n_c,h_c,x_ly,r 
  REAL :: df, x_nf, a_f, h_c, x_ly, r
  REAL :: h_c_bw
  INTEGER :: n_c
  REAL :: c1
  REAL :: c1_bw
  REAL :: weights, points
  REAL :: rs
  REAL :: rs_bw
  REAL :: tl, rl, lai
  REAL :: lai_bw
  REAL :: ag, bg, cg, dg
  INTEGER :: number, ild
  REAL :: teta(nv), phi(nv)
  REAL :: teta_0, phi_0
!
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, RHO_0_NAD, RHO_1_NAD, RHO_MULT_NAD
  INTEGER :: i, na
  REAL :: i0, xif, xi1u, xi1, ximt
  REAL :: i0_bw(21, 40), xif_bw(21, 40), xi1u_bw(21, 40), xi1_bw, &
& ximt_bw
!
!       COMMON DATAS
!
!     MVO::revised order (alignment-issue after n_c has type integer)
!$$$      common/canopee/df,x_nf,a_f,n_c,h_c,x_ly,r 
  COMMON /canopee/ df, x_nf, a_f, h_c, x_ly, r, n_c
  COMMON /hp/ c1
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /coef/ ag, bg, cg, dg
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  COMMON /angle_sol/ teta_0, phi_0
  INTRINSIC COS
  INTRINSIC ABS
  REAL :: abs0
  REAL :: abs1
  REAL :: result1
  REAL :: result2
  REAL :: x2
  REAL :: x1
  COMMON /limite_bw/ xi1_bw, ximt_bw
  COMMON /multi_bw/ i0_bw, xif_bw, xi1u_bw
  COMMON /feuille_bw/ lai_bw
  COMMON /sol_bw/ rs_bw
  COMMON /hp_bw/ c1_bw
  COMMON /canopee_bw/ h_c_bw
!
!
!--------------------------------------------------
!
!       INPUT PARAMETERS
!
!       teta_0,phi_0            solar angles
!       ild                     leaf distribution
!       R_s                     soil albedo
!       h_c                     height of canopee (m)
!       df                      diameter of a single leaf (m)
!       lai                     leaf area index
!       rl                      leaf reflectance
!       tl                      leaf transmittance
!       na                      number of viewing angle
!       teta(i),phi(i)          viewing angles
!---------------------------------------------------------
!
!       INPUT PARAMETERS <------ ROUTINE
!
  lai = xlai
  h_c = xhc
  df = rpl*2.
  ild = lad
  rl = xrl
  tl = xtl
  rs = xrs
  na = nv
!**************************************************
!
!       DEGREES ---> RADIANS
!
  teta_0 = (180.-theta_i)*pi/180.
  phi_0 = phi_i*pi/180.
  DO i=1,na
    teta(i) = theta_v(i)*pi/180.
    phi(i) = phi_v(i)*pi/180.
  END DO
!
!****************************************************
!
!       CALL SUBROUTINES WRITTING IN NADIMTOOLS.f
!
!***************************************************
!
!       16 GAUSS POINTS and WEIGHTS
!       to compute numerical integrals
!       and discrete ordinates methods
!
!
  number = 16
  CALL GAULEG(-1., 1., points, weights, number)
!---------------------------------------------  
!
!      COEFFICIENTS FUNCTIONS OF DISTRIBUTION BUNNIK
!
!       (leaf angle distribution functions)
!
  CALL BUNNIK(ild)
!
!---------------------------------------------
!
!       GEOMETRIE CANOPY
!
  CALL ARCHI(lai, teta_0)
!---------------------------------------------  
!
!       MULTIPLE INTENSITIES FOR ANGULAR POINTS GAUSS
!
!
  CALL PUSHREAL8ARRAY(xif, 21*40)
  CALL PUSHREAL8ARRAY(i0, 21*40)
  CALL MULTIPLE_DOM(teta_0)
!
!-----------------------------------------------
  DO i=1,na
    x1 = COS(teta_0)
    IF (x1 .GE. 0.) THEN
      abs0 = x1
    ELSE
      abs0 = -x1
    END IF
    x2 = COS(teta(i))
    IF (x2 .GE. 0.) THEN
      abs1 = x2
    ELSE
      abs1 = -x2
    END IF
    result1 = G_ROSS(teta_0)
    result2 = G_ROSS(teta(i))
    CALL PUSHREAL8(x_lambda_i)
    x_lambda_i = 0.01*abs0/result1*abs1/result2
!
!   the three orders brdf   
!
!
! so the sum ..to have the brdf total.
!
  END DO
  c1_bw = 0.D0
  rs_bw = 0.D0
  lai_bw = 0.D0
  xi1_bw = 0.D0
  ximt_bw = 0.D0
  DO i=na,1,-1
    xmeas_bw = brf_bw(i)
    brf_bw(i) = 0.D0
    r3_bw = xmeas_bw
    r1_bw = xmeas_bw
    r2_bw = xmeas_bw
    CALL RHO_MULT_NAD_BW0(teta(i), r3_bw)
    CALL RHO_1_NAD_BW0(teta(i), phi(i), x_lambda_i, r2_bw)
    CALL RHO_0_NAD_BW0(teta(i), phi(i), x_lambda_i, r1_bw)
    CALL POPREAL8(x_lambda_i)
  END DO
  CALL POPREAL8ARRAY(i0, 21*40)
  CALL POPREAL8ARRAY(xif, 21*40)
  CALL MULTIPLE_DOM_BW(teta_0)
  CALL ARCHI_BW(lai, lai_bw, teta_0)
  xrs_bw = xrs_bw + rs_bw
  xhc_bw = xhc_bw + h_c_bw
  xlai_bw = xlai_bw + lai_bw
END SUBROUTINE NADIMBRF_BW
!
!
!

!  Differentiation of rho_0_nad in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: c1 rs lai rho_0_nad
!   with respect to varying inputs: c1 rs lai
!**********************************************************
! nadimtools.f
!***********************************************************
!                                                          *
! This file (nadimtools.f) contains all routines and       * 
! functions used in the nadimbrf.f                         *    
!                                                          *    
!***********************************************************
!
! This function computes the "zero order" of scattering by the soil: 
! The downward radiation scattered once by the soil only.
!
SUBROUTINE RHO_0_NAD_BW0(teta_e, phi_e, x_lambda_i, rho_0_nad_bw)
  IMPLICIT NONE
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x_lambda_i
  REAL :: teta_e, phi_e
  REAL :: ki, ke, xs1, xs2, rs_d
  REAL :: xs2_bw
  REAL :: xh_p, xli
  REAL :: xh_p_bw, xli_bw
  REAL :: c1
  REAL :: c1_bw
  REAL :: rs
  REAL :: rs_bw
  REAL :: tl, rl, lai
  REAL :: lai_bw
  INTEGER :: number, ild
  REAL :: teta_0, phi_0
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, GEO, HOT_SPOT
  INTEGER :: i, n_c
  REAL :: xg1, xg2
!
  COMMON /hp/ c1
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /i/ number, ild
  COMMON /angle_sol/ teta_0, phi_0
  INTRINSIC INT
  INTRINSIC COS
  INTRINSIC ABS
  REAL :: abs0
  REAL :: result1
  REAL :: rho_0_nad
  REAL :: rho_0_nad_bw
  REAL :: x1
  COMMON /feuille_bw/ lai_bw
  COMMON /sol_bw/ rs_bw
  COMMON /hp_bw/ c1_bw
!
  n_c = INT(lai/x_lambda_i)
  xg1 = G_ROSS(teta_0)
  xg2 = G_ROSS(teta_e)
  x1 = COS(teta_0)
  IF (x1 .GE. 0.) THEN
    abs0 = x1
  ELSE
    abs0 = -x1
  END IF
  ki = xg1/abs0
  ke = xg2/COS(teta_e)
  xs1 = (1.-x_lambda_i*ki)**n_c
  xs2 = 1.
  result1 = GEO(teta_e, teta_0, phi_e, phi_0)
  xli = c1/result1
!
!  actual optical path to account for the hot-spot effect
!
  xh_p = HOT_SPOT(lai, xli)
!
  DO i=1,n_c
    CALL PUSHREAL8(xs2)
    xs2 = xs2*(1.-x_lambda_i*ke*xh_p)
  END DO
  rs_bw = rs_bw + xs1*xs2*rho_0_nad_bw
  xs2_bw = xs1*rs*rho_0_nad_bw
  xh_p_bw = 0.D0
  DO i=n_c,1,-1
    CALL POPREAL8(xs2)
    xh_p_bw = xh_p_bw - xs2*x_lambda_i*ke*xs2_bw
    xs2_bw = (1.-x_lambda_i*ke*xh_p)*xs2_bw
  END DO
  xli_bw = 0.D0
  CALL HOT_SPOT_BW0(lai, lai_bw, xli, xli_bw, xh_p_bw)
  c1_bw = c1_bw + xli_bw/result1
END SUBROUTINE RHO_0_NAD_BW0

!  Differentiation of rho_1_nad in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: c1 rho_1_nad
!   with respect to varying inputs: c1
!*****************************************************
!
! This function computes the "one order" of scattering by the leaves only
!
! 
! 
SUBROUTINE RHO_1_NAD_BW0(teta_e, phi_e, x_lambda_i, rho_1_nad_bw)
  IMPLICIT NONE
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x_lambda_i
  REAL :: teta_e, phi_e
  REAL :: xli
  REAL :: xli_bw
  REAL :: ki, ke, xga, xc1, rc_d
  REAL :: xg1, xg2, sum, x_hp, xl
  REAL :: sum_bw, x_hp_bw, xl_bw
  REAL :: c1
  REAL :: c1_bw
  REAL :: tl, rl, lai
  REAL :: lai_bw
  INTEGER :: number, ild
  REAL :: teta_0, phi_0
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, GEO, HOT_SPOT, GAMMA_LEAF
  INTEGER :: k, n_c
!
  COMMON /hp/ c1
  COMMON /feuille/ tl, rl, lai
  COMMON /i/ number, ild
  COMMON /angle_sol/ teta_0, phi_0
  INTRINSIC INT
  INTRINSIC COS
  INTRINSIC ABS
  REAL :: abs0
  REAL :: abs1
  REAL :: result1
  REAL :: rho_1_nad_bw
  REAL :: rho_1_nad
  REAL :: x2
  REAL :: x1
  COMMON /feuille_bw/ lai_bw
  COMMON /hp_bw/ c1_bw
!
  n_c = INT(lai/x_lambda_i)
  xg1 = G_ROSS(teta_0)
  xg2 = G_ROSS(teta_e)
  x1 = COS(teta_0)
  IF (x1 .GE. 0.) THEN
    abs0 = x1
  ELSE
    abs0 = -x1
  END IF
  ki = xg1/abs0
  ke = xg2/COS(teta_e)
!
!  3D phase function
!
  xga = GAMMA_LEAF(teta_0, phi_0, teta_e, phi_e)
  xc1 = 1. - x_lambda_i*ki
  result1 = GEO(teta_e, teta_0, phi_e, phi_0)
  xli = c1/result1
  DO k=1,n_c
    xl = x_lambda_i*k
    CALL PUSHREAL8(x_hp)
    x_hp = HOT_SPOT(xl, xli)
  END DO
  x2 = COS(teta_0)
  IF (x2 .GE. 0.) THEN
    abs1 = x2
  ELSE
    abs1 = -x2
  END IF
  sum_bw = xga*rho_1_nad_bw/(COS(teta_e)*abs1)
  xli_bw = 0.D0
  DO k=n_c,1,-1
    IF (1. - x_lambda_i*ke*x_hp .LE. 0.D0 .AND. (k .EQ. 0.D0 .OR. k .NE.&
&       INT(k))) THEN
      x_hp_bw = 0.0
    ELSE
      x_hp_bw = -(k*(1.-x_lambda_i*ke*x_hp)**(k-1)*xc1**k*x_lambda_i**2*&
&       ke*sum_bw)
    END IF
    xl = x_lambda_i*k
    CALL POPREAL8(x_hp)
    xl_bw = 0.D0
    CALL HOT_SPOT_BW0(xl, xl_bw, xli, xli_bw, x_hp_bw)
  END DO
  c1_bw = c1_bw + xli_bw/result1
END SUBROUTINE RHO_1_NAD_BW0

!  Differentiation of hot_spot in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: x hot_spot xli
!   with respect to varying inputs: x xli
!
!********************************************************
!
! HOT_SPOT FUNCTION (after Verstraete et al)
!
SUBROUTINE HOT_SPOT_BW0(x, x_bw, xli, xli_bw, hot_spot_bw)
  IMPLICIT NONE
!     MVO-ADDED-TYPE-DECLARATION
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x, xli
  REAL :: x_bw, xli_bw
  REAL :: temp_bw
  REAL :: temp
  REAL :: temp_bw0
  REAL :: hot_spot_bw
  REAL :: hot_spot
  IF (x .LT. xli) THEN
    temp_bw = (1.-4./(3.*pi))*hot_spot_bw/xli
    x_bw = x_bw + temp_bw
    xli_bw = xli_bw - x*temp_bw/xli
  ELSE
    temp = 3.*pi*x
    temp_bw0 = -(4.*hot_spot_bw/temp)
    xli_bw = xli_bw + temp_bw0
    x_bw = x_bw - xli*3.*pi*temp_bw0/temp
  END IF
END SUBROUTINE HOT_SPOT_BW0

!  Differentiation of rho_mult_nad in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: lai i0 xif xi1u xi1 ximt rho_mult_nad
!   with respect to varying inputs: lai i0 xif xi1u xi1 ximt
!***************************************************
!
! This function computes the multiple scattering term 
! averaged in azimuth. 
!       
SUBROUTINE RHO_MULT_NAD_BW0(teta_u, rho_mult_nad_bw)
  IMPLICIT NONE
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
!     MVO::turn m into integer
!$$$      real xmu0,xm,xr,mu,Gu,xIm(21),m,dL
  REAL :: xmu0, xm, xr, mu, gu, xim(21), dl
  REAL :: xim_bw(21), dl_bw
  INTEGER :: m
  REAL :: g0, teta_u, sum, sum1, sum2, x
  REAL :: sum_bw, sum1_bw, sum2_bw
  REAL :: xsu(21), xq0u(21), xq1(21), xgama_u(40)
  REAL :: xsu_bw(21), xq0u_bw(21), xq1_bw(21)
  REAL :: fpar_tur, alb_tur, tr_tur, tr_dir, tran
  REAL :: weights, points
  REAL :: rs
  REAL :: rs_bw
  REAL :: tl, rl, lai
  REAL :: lai_bw
  INTEGER :: number, ild
  REAL :: i0, xif, xi1u
  REAL, DIMENSION(21, 40) :: i0_bw, xif_bw, xi1u_bw
  REAL :: xi1, ximt
  REAL :: xi1_bw, ximt_bw
  REAL :: teta_0, phi_0
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, FASE_LEAF
  INTEGER :: i, j, k
  REAL :: aa, bb, s1
  REAL :: aa_bw, bb_bw, s1_bw
!
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  COMMON /angle_sol/ teta_0, phi_0
  INTRINSIC COS
  INTRINSIC ABS
  INTRINSIC ACOS
  REAL :: abs0
  REAL :: arg1
  REAL :: temp_bw
  REAL :: temp_bw0
  REAL :: temp_bw1
  REAL :: temp_bw2
  INTEGER :: ii1
  REAL :: rho_mult_nad
  REAL :: rho_mult_nad_bw
  REAL :: x2
  REAL :: x1
  COMMON /limite_bw/ xi1_bw, ximt_bw
  COMMON /multi_bw/ i0_bw, xif_bw, xi1u_bw
  COMMON /feuille_bw/ lai_bw
  COMMON /sol_bw/ rs_bw
  m = 20
  dl = lai/m
  xm = 0.5*(1.-1.)
  xr = 0.5*(1.+1.)
!
!       GAMMA (TETA(J) --> TETA_U)
!
  DO j=1,number
    x = xm + xr*points(j)
    arg1 = ACOS(x)
    xgama_u(j) = FASE_LEAF(arg1, teta_u)
  END DO
!
!
!       MULTIPLE SOURCE S(K) FOR VIEWING ANGLE = TETA_U
!           
!
  DO k=1,m
    sum = 0.
    DO j=1,number
      sum = sum + 2.*xgama_u(j)*xr*weights(j)*(xif(k+1, j)+xif(k, j))/2.
    END DO
    xsu(k) = sum
  END DO
!
!
!       ZERO ORDER SOURCE
!
!
  DO k=m,1,-1
    sum1 = 0.
    DO j=number/2+1,number
      sum1 = sum1 + weights(j)*xr*2.*xgama_u(j)*(i0(k+1, j)+i0(k, j))/2.
    END DO
    xq0u(k) = sum1
  END DO
!
! FIRST ORDER SOURCE
!
  DO k=1,m
    sum2 = 0.
    DO j=1,number
      sum2 = sum2 + 2.*xgama_u(j)*xr*weights(j)*(xi1u(k+1, j)+xi1u(k, j)&
&       )/2.
    END DO
    xq1(k) = sum2
  END DO
!
  gu = G_ROSS(teta_u)
  mu = COS(teta_u)
  xim(m+1) = ximt + xi1
  DO k=m,1,-1
    s1 = xsu(k) + xq1(k) + xq0u(k)
    aa = gu/2. - mu/dl
    bb = gu/2. + mu/dl
    CALL PUSHREAL8(xim(k))
    xim(k) = (s1-xim(k+1)*aa)/bb
  END DO
  x2 = COS(teta_0)
  IF (x2 .GE. 0.) THEN
    abs0 = x2
  ELSE
    abs0 = -x2
  END IF
  DO ii1=1,21
    xim_bw(ii1) = 0.D0
  END DO
  xim_bw(1) = xim_bw(1) + rho_mult_nad_bw/(2.*abs0)
  DO ii1=1,21
    xsu_bw(ii1) = 0.D0
  END DO
  dl_bw = 0.D0
  DO ii1=1,21
    xq0u_bw(ii1) = 0.D0
  END DO
  DO ii1=1,21
    xq1_bw(ii1) = 0.D0
  END DO
  DO k=1,m,1
    aa = gu/2. - mu/dl
    s1 = xsu(k) + xq1(k) + xq0u(k)
    bb = gu/2. + mu/dl
    CALL POPREAL8(xim(k))
    temp_bw2 = xim_bw(k)/bb
    s1_bw = temp_bw2
    xim_bw(k+1) = xim_bw(k+1) - aa*temp_bw2
    aa_bw = -(xim(k+1)*temp_bw2)
    bb_bw = -((s1-xim(k+1)*aa)*temp_bw2/bb)
    xim_bw(k) = 0.D0
    dl_bw = dl_bw + mu*aa_bw/dl**2 - mu*bb_bw/dl**2
    xsu_bw(k) = xsu_bw(k) + s1_bw
    xq1_bw(k) = xq1_bw(k) + s1_bw
    xq0u_bw(k) = xq0u_bw(k) + s1_bw
  END DO
  ximt_bw = ximt_bw + xim_bw(m+1)
  xi1_bw = xi1_bw + xim_bw(m+1)
  DO k=m,1,-1
    sum2_bw = xq1_bw(k)
    xq1_bw(k) = 0.D0
    DO j=number,1,-1
      temp_bw1 = xr*xgama_u(j)*weights(j)*sum2_bw
      xi1u_bw(k+1, j) = xi1u_bw(k+1, j) + temp_bw1
      xi1u_bw(k, j) = xi1u_bw(k, j) + temp_bw1
    END DO
  END DO
  DO k=1,m,1
    sum1_bw = xq0u_bw(k)
    xq0u_bw(k) = 0.D0
    DO j=number,number/2+1,-1
      temp_bw0 = xr*weights(j)*xgama_u(j)*sum1_bw
      i0_bw(k+1, j) = i0_bw(k+1, j) + temp_bw0
      i0_bw(k, j) = i0_bw(k, j) + temp_bw0
    END DO
  END DO
  DO k=m,1,-1
    sum_bw = xsu_bw(k)
    xsu_bw(k) = 0.D0
    DO j=number,1,-1
      temp_bw = xr*xgama_u(j)*weights(j)*sum_bw
      xif_bw(k+1, j) = xif_bw(k+1, j) + temp_bw
      xif_bw(k, j) = xif_bw(k, j) + temp_bw
    END DO
  END DO
  lai_bw = lai_bw + dl_bw/m
END SUBROUTINE RHO_MULT_NAD_BW0

!  Differentiation of archi in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: c1 x_lai
!   with respect to varying inputs: h_c x_lai
!**********************************************************
!**********************************************************
!
!       SUBROUTINES
!
!*********************************************************
!*********************************************************
!
!       GEOMETRY OD THE VEGETATION CANOPY AND
!       COMPUTATION OF THE HOT-SPOT PARAMETER   
!
SUBROUTINE ARCHI_BW(x_lai, x_lai_bw, teta_s)
  IMPLICIT NONE
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: x_lai, teta_s
  REAL :: x_lai_bw
  REAL :: weights, points
  REAL :: tl, rl, lai, rs
  REAL :: lai_bw, rs_bw
  REAL :: ag, bg, cg, dg
  REAL :: teta_0, phi_0
  INTEGER :: number, ild
  REAL :: c1
  REAL :: c1_bw
  REAL :: i0, xif, xi1u, xi1, ximt
  REAL :: i0_bw(21, 40), xif_bw(21, 40), xi1u_bw(21, 40), xi1_bw, &
& ximt_bw
  REAL :: x_nf, a_f, h_c, x_ly, r
  REAL :: h_c_bw
!     MVO::added type declarations
  REAL, EXTERNAL :: DEEP, SUN_FLECK
  REAL :: df
  INTEGER :: n_c
!     MVO::revised order (alignment-issue after n_c has type integer)
!$$$      common/canopee/df,x_nf,a_f,n_c,h_c,x_ly,r 
  COMMON /canopee/ df, x_nf, a_f, h_c, x_ly, r, n_c
  COMMON /hp/ c1
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /coef/ ag, bg, cg, dg
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  COMMON /angle_sol/ teta_0, phi_0
  REAL :: temp_bw
  COMMON /limite_bw/ xi1_bw, ximt_bw
  COMMON /multi_bw/ i0_bw, xif_bw, xi1u_bw
  COMMON /feuille_bw/ lai_bw
  COMMON /sol_bw/ rs_bw
  COMMON /hp_bw/ c1_bw
  COMMON /canopee_bw/ h_c_bw
  a_f = (df/2.)**2*pi
  x_ly = DEEP(teta_s)
  r = SUN_FLECK(teta_s)
  temp_bw = r*2.*c1_bw/h_c
  x_lai_bw = x_lai_bw + temp_bw
  h_c_bw = -(x_lai*temp_bw/h_c)
END SUBROUTINE ARCHI_BW

!  Differentiation of multiple_dom in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: rs lai i0 xif xi1u xi1 ximt
!   with respect to varying inputs: rs lai i0 xif xi1u
!
!*********************************************************
!
!       MULTIPLE SCATTERING INTENSITIES IN THE DIRECTION
!       CORRESPONDING TO THE GAUSS QUADRATURE.
!       
! 
SUBROUTINE MULTIPLE_DOM_BW(teta_0)
  IMPLICIT NONE
  REAL :: pi
  PARAMETER (pi=3.141592653589793)
  REAL :: weights, points
  REAL :: tl, rl, lai, rs
  REAL :: lai_bw, rs_bw
  REAL :: ag, bg, cg, dg
  REAL :: teta_0
  INTEGER :: number
  REAL :: i0, xif, xi1u, xi1, ximt
  REAL :: i0_bw(21, 40), xif_bw(21, 40), xi1u_bw(21, 40), xi1_bw, &
& ximt_bw
!     MVO::added type declarations
  REAL, EXTERNAL :: G_ROSS, FASE_LEAF
  REAL :: dl, sum, xl, xnn, y
  REAL :: dl_bw, sum_bw, xl_bw
  INTEGER :: i, j, k, l, m, nt, ild
  COMMON /ga/ weights(32), points(32)
  COMMON /sol/ rs
  COMMON /feuille/ tl, rl, lai
  COMMON /coef/ ag, bg, cg, dg
  COMMON /i/ number, ild
  COMMON /multi/ i0(21, 40), xif(21, 40), xi1u(21, 40)
  COMMON /limite/ xi1, ximt
  REAL :: xmu0, g0, xm, xr, x
  REAL :: gg(40), s(21, 40)
  REAL :: s_bw(21, 40)
  REAL :: q0m(21, 40), xi(21, 40)
  REAL :: q0m_bw(21, 40), xi_bw(21, 40)
  REAL :: q1(21, 40), xgama_xy(40, 40), xgama_0(40)
  REAL :: q1_bw(21, 40)
  REAL :: i00
  INTRINSIC COS
  INTRINSIC ABS
  INTRINSIC FLOAT
  INTRINSIC ACOS
  INTRINSIC MIN
  INTRINSIC EXP
  INTEGER :: min1
  REAL :: abs0
  REAL :: abs1
  REAL :: abs2
  REAL :: abs3
  REAL :: abs4
  REAL :: abs5
  REAL :: abs6
  REAL :: abs7
  REAL :: arg1
  REAL :: arg2
  REAL :: temp
  REAL :: temp0
  REAL :: temp1
  REAL :: temp_bw
  REAL :: temp_bw0
  REAL :: temp_bw1
  REAL :: temp_bw2
  REAL :: temp_bw3
  REAL :: temp_bw4
  REAL :: temp2
  REAL :: temp3
  REAL :: temp_bw5
  REAL :: temp_bw6
  REAL :: temp_bw7
  REAL :: temp4
  REAL :: temp5
  REAL :: temp6
  REAL :: temp7
  REAL :: temp_bw8
  REAL :: temp_bw9
  REAL :: temp_bw10
  REAL :: temp_bw11
  REAL :: temp_bw12
  REAL :: temp8
  REAL :: temp9
  REAL :: temp_bw13
  REAL :: temp_bw14
  REAL :: temp10
  REAL :: temp11
  REAL :: temp_bw15
  REAL :: temp_bw16
  INTEGER :: branch
  INTEGER :: ad_count
  INTEGER :: i1
  INTEGER :: ii2
  INTEGER :: ii1
  REAL :: x1
  COMMON /limite_bw/ xi1_bw, ximt_bw
  COMMON /multi_bw/ i0_bw, xif_bw, xi1u_bw
  COMMON /feuille_bw/ lai_bw
  COMMON /sol_bw/ rs_bw
  x1 = COS(teta_0)
  IF (x1 .GE. 0.) THEN
    xmu0 = x1
  ELSE
    xmu0 = -x1
  END IF
  m = 20
  dl = lai/FLOAT(m)
  g0 = G_ROSS(teta_0)
  xm = 0.5*(1.+(-1.))
  xr = 0.5*(1.-(-1.))
!
  i00 = 1.
!
! Computation of the G-function
!
  DO j=1,number
    x = xm + xr*points(j)
    arg1 = ACOS(x)
    gg(j) = G_ROSS(arg1)
  END DO
  IF (m + 1 .GT. 21) THEN
    min1 = 21
  ELSE
    min1 = m + 1
  END IF
!
! INITIALIZATION OF SOURCES AND INTENSITIES = 0
!
!     MVO/TXK fixed:xIf(m+1,?) will be accessed later and *must*
!     be initialised (21 is the size of first dimension in the declaraion)
  DO k=1,min1
    DO j=1,number
      s(k, j) = 0.
      xif(k, j) = 0.
    END DO
  END DO
!
! COMPUTATION OF THE UNCOLLIDED INTENSITIES
!
  DO k=1,m+1
    CALL PUSHREAL8(xl)
    xl = FLOAT(k-1)*dl
    DO i=1,number/2
      x = xm + xr*points(i)
      IF (x .GE. 0.) THEN
        abs0 = x
      ELSE
        abs0 = -x
      END IF
      IF (abs0 .EQ. xmu0) THEN
        i0(k, i) = i00*EXP(-(g0/xmu0*xl))
        CALL PUSHCONTROL1B(1)
      ELSE
        i0(k, i) = 0.
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
  END DO
!
  DO k=m+1,1,-1
    CALL PUSHREAL8(xl)
    xl = FLOAT(k-1)*dl
    DO i=number/2+1,number
      x = xm + xr*points(i)
      i0(k, i) = 2.*rs*i00*xmu0*EXP(-(g0/xmu0*lai))*EXP(-(gg(i)/x*(lai-&
&       xl)))
    END DO
  END DO
!       
! TABLE OF 2-D PHASE FUNCTION FOR the GAUSS QUADRATURE ANGLES
!
  DO i=1,number
    y = xm + xr*points(i)
    DO j=1,number
      x = xm + xr*points(j)
      arg1 = ACOS(x)
      arg2 = ACOS(y)
      xgama_xy(i, j) = FASE_LEAF(arg1, arg2)
    END DO
  END DO
!
! COMPUTATION OF THE ZERO ORDER SOURCE
!
  DO k=m,1,-1
    DO i=1,number
      sum = 0.
      DO j=number/2+1,number
        sum = sum + weights(j)*xr*2.*xgama_xy(i, j)*(i0(k+1, j)+i0(k, j)&
&         )/2.
      END DO
      q0m(k, i) = sum
    END DO
  END DO
!
! TABLE OF 2-D PHASE FUNCTION FOR ILLUMINATION --> QUADRATURE ANGLES
!       
  DO i=1,number
    x = xm + xr*points(i)
    arg1 = ACOS(x)
    xgama_0(i) = FASE_LEAF(teta_0, arg1)
  END DO
!
! COMPUTATIONS OF THE FIRST ORDER INTENSITIES
!
  DO k=1,m+1
    CALL PUSHREAL8(xl)
    xl = FLOAT(k-1)*dl
    DO j=1,number/2
      x = xm + xr*points(j)
      IF (x .GE. 0.) THEN
        abs1 = x
      ELSE
        abs1 = -x
      END IF
      IF (abs1 .NE. xmu0) THEN
        IF (x .GE. 0.) THEN
          CALL PUSHREAL8(abs2)
          abs2 = x
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHREAL8(abs2)
          abs2 = -x
          CALL PUSHCONTROL1B(0)
        END IF
        IF (x .GE. 0.) THEN
          CALL PUSHREAL8(abs6)
          abs6 = x
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(abs6)
          abs6 = -x
          CALL PUSHCONTROL1B(1)
        END IF
        xi(k, j) = i00*2.*xgama_0(j)*xmu0*(EXP(-(g0/xmu0*xl))-EXP(-(gg(j&
&         )/abs2*xl)))/(gg(j)*xmu0-g0*abs6)
        IF (x .GE. 0.) THEN
          CALL PUSHREAL8(abs3)
          abs3 = x
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHREAL8(abs3)
          abs3 = -x
          CALL PUSHCONTROL1B(0)
        END IF
        IF (x .GE. 0.) THEN
          CALL PUSHREAL8(abs7)
          abs7 = x
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(abs7)
          abs7 = -x
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHCONTROL1B(1)
      ELSE
        xi(k, j) = i00*xl*2.*xgama_0(j)*EXP(-(g0/xmu0*xl))/xmu0
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
  END DO
!
  xi1 = 0.
  DO j=1,number/2
    x = xm + xr*points(j)
    IF (x .GE. 0.) THEN
      CALL PUSHREAL8(abs4)
      abs4 = x
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(abs4)
      abs4 = -x
      CALL PUSHCONTROL1B(1)
    END IF
    xi1 = xi1 + weights(j)*xr*abs4*2.*rs*xi(m+1, j)
  END DO
!
  DO k=m+1,1,-1
    CALL PUSHREAL8(xl)
    xl = FLOAT(k-1)*dl
    DO j=number/2+1,number
      x = xm + xr*points(j)
      CALL PUSHREAL8(xi(k, j))
      xi(k, j) = i00*2.*xgama_0(j)*xmu0*(EXP(-(g0/xmu0*xl))-EXP(-(gg(j)/&
&       x*(lai-xl)))*EXP(-(g0/xmu0*lai)))/(g0*x+gg(j)*xmu0)
!
    END DO
  END DO
  DO j=number/2+1,number
    CALL PUSHREAL8(xi(m+1, j))
    xi(m+1, j) = 0.
  END DO
!
  DO k=1,m
    DO i=1,number
      sum = 0.
      DO j=1,number
        sum = sum + weights(j)*xr*2.*xgama_xy(i, j)*(xi(k+1, j)+xi(k, j)&
&         )/2.
      END DO
      q1(k, i) = sum
    END DO
  END DO
!
! MULTIPLE INTENSITIES
!
  DO k=1,m+1
    DO j=1,number/2
      CALL PUSHREAL8(xi(k, j))
      xi(k, j) = 0.
    END DO
  END DO
  l = 0
  ad_count = 1
 111 l = l + 1
  DO k=1,m
    DO j=1,number/2
      x = xm + xr*points(j)
      CALL PUSHREAL8(xi(k+1, j))
      xi(k+1, j) = (s(k, j)+q0m(k, j)+q1(k, j)-xi(k, j)*(gg(j)/2.+x/dl))&
&       /(gg(j)/2.-x/dl)
    END DO
  END DO
  ximt = 0.
  DO j=1,number/2
    x = xm + xr*points(j)
    IF (x .GE. 0.) THEN
      CALL PUSHREAL8(abs5)
      abs5 = x
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(abs5)
      abs5 = -x
      CALL PUSHCONTROL1B(1)
    END IF
    ximt = ximt + weights(j)*xr*2.*rs*abs5*xi(m+1, j)
  END DO
  DO j=number/2+1,number
    CALL PUSHREAL8(xi(m+1, j))
    xi(m+1, j) = ximt + xi1
  END DO
  DO k=m,1,-1
    DO j=number/2+1,number
      x = xm + xr*points(j)
      CALL PUSHREAL8(xi(k, j))
      xi(k, j) = (s(k, j)+q0m(k, j)+q1(k, j)-xi(k+1, j)*(gg(j)/2.-x/dl))&
&       /(gg(j)/2.+x/dl)
    END DO
  END DO
!
  nt = 0
  DO k=1,m+1
    DO j=1,number
      IF (xif(k, j) - xi(k, j) .GE. 0.) THEN
        xnn = xif(k, j) - xi(k, j)
      ELSE
        xnn = -(xif(k, j)-xi(k, j))
      END IF
      IF (xnn .LT. 1.e-4) nt = nt + 1
      xif(k, j) = xi(k, j)
    END DO
  END DO
!$$$      print*, 'MVMV::debug:l=',l,'nt=',nt,'m=',m,
!$$$     &     '(m+1)*number=',(m+1)*number
!$$$      print*, 'MVMV::goon=',((l.lt.1000).and.(nt.ne.(m+1)*number))
  IF (l .LT. 1000 .AND. nt .NE. (m+1)*number) THEN
!
! MULTIPLE SOURCE 
!
    DO k=1,m
      DO i=1,number
        sum = 0.
        DO j=1,number
          sum = sum + weights(j)*xr*2.*xgama_xy(i, j)*(xi(k+1, j)+xi(k, &
&           j))/2.
        END DO
        CALL PUSHREAL8(s(k, i))
        s(k, i) = sum
      END DO
    END DO
    ad_count = ad_count + 1
    GOTO 111
  END IF
  CALL PUSHINTEGER4(ad_count)
  CALL POPINTEGER4(ad_count)
  DO i1=1,ad_count
    IF (i1 .EQ. 1) THEN
      dl_bw = 0.D0
      DO ii1=1,40
        DO ii2=1,21
          s_bw(ii2, ii1) = 0.D0
        END DO
      END DO
      DO ii1=1,40
        DO ii2=1,21
          xi_bw(ii2, ii1) = 0.D0
        END DO
      END DO
      DO ii1=1,40
        DO ii2=1,21
          q1_bw(ii2, ii1) = 0.D0
        END DO
      END DO
      DO ii1=1,40
        DO ii2=1,21
          q0m_bw(ii2, ii1) = 0.D0
        END DO
      END DO
    ELSE
      DO k=m,1,-1
        DO i=number,1,-1
          CALL POPREAL8(s(k, i))
          sum_bw = s_bw(k, i)
          s_bw(k, i) = 0.D0
          DO j=number,1,-1
            temp_bw16 = weights(j)*xr*xgama_xy(i, j)*sum_bw
            xi_bw(k+1, j) = xi_bw(k+1, j) + temp_bw16
            xi_bw(k, j) = xi_bw(k, j) + temp_bw16
          END DO
        END DO
      END DO
      ximt_bw = 0.D0
    END IF
    DO k=m+1,1,-1
      DO j=number,1,-1
        xi_bw(k, j) = xi_bw(k, j) + xif_bw(k, j)
        xif_bw(k, j) = 0.D0
      END DO
    END DO
    DO k=1,m,1
      DO j=number,number/2+1,-1
        x = xm + xr*points(j)
        CALL POPREAL8(xi(k, j))
        temp11 = gg(j)/2. + x/dl
        temp_bw15 = xi_bw(k, j)/temp11
        temp10 = gg(j)/2. - x/dl
        s_bw(k, j) = s_bw(k, j) + temp_bw15
        q0m_bw(k, j) = q0m_bw(k, j) + temp_bw15
        q1_bw(k, j) = q1_bw(k, j) + temp_bw15
        xi_bw(k+1, j) = xi_bw(k+1, j) - temp10*temp_bw15
        dl_bw = dl_bw + ((s(k, j)+q0m(k, j)+q1(k, j)-xi(k+1, j)*temp10)*&
&         x/(dl**2*temp11)-xi(k+1, j)*x/dl**2)*temp_bw15
        xi_bw(k, j) = 0.D0
      END DO
    END DO
    DO j=number,number/2+1,-1
      CALL POPREAL8(xi(m+1, j))
      ximt_bw = ximt_bw + xi_bw(m+1, j)
      xi1_bw = xi1_bw + xi_bw(m+1, j)
      xi_bw(m+1, j) = 0.D0
    END DO
    DO j=number/2,1,-1
      temp_bw14 = weights(j)*abs5*xr*2.*ximt_bw
      rs_bw = rs_bw + xi(m+1, j)*temp_bw14
      xi_bw(m+1, j) = xi_bw(m+1, j) + rs*temp_bw14
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(abs5)
      ELSE
        CALL POPREAL8(abs5)
      END IF
    END DO
    DO k=m,1,-1
      DO j=number/2,1,-1
        x = xm + xr*points(j)
        CALL POPREAL8(xi(k+1, j))
        temp9 = gg(j)/2. - x/dl
        temp_bw13 = xi_bw(k+1, j)/temp9
        temp8 = gg(j)/2. + x/dl
        s_bw(k, j) = s_bw(k, j) + temp_bw13
        q0m_bw(k, j) = q0m_bw(k, j) + temp_bw13
        q1_bw(k, j) = q1_bw(k, j) + temp_bw13
        xi_bw(k, j) = xi_bw(k, j) - temp8*temp_bw13
        dl_bw = dl_bw + (xi(k, j)*x/dl**2-(s(k, j)+q0m(k, j)+q1(k, j)-xi&
&         (k, j)*temp8)*x/(dl**2*temp9))*temp_bw13
        xi_bw(k+1, j) = 0.D0
      END DO
    END DO
  END DO
  DO k=m+1,1,-1
    DO j=number/2,1,-1
      CALL POPREAL8(xi(k, j))
      xi_bw(k, j) = 0.D0
    END DO
  END DO
  DO k=m,1,-1
    DO i=number,1,-1
      sum_bw = q1_bw(k, i)
      q1_bw(k, i) = 0.D0
      DO j=number,1,-1
        temp_bw12 = weights(j)*xr*xgama_xy(i, j)*sum_bw
        xi_bw(k+1, j) = xi_bw(k+1, j) + temp_bw12
        xi_bw(k, j) = xi_bw(k, j) + temp_bw12
      END DO
    END DO
  END DO
  DO j=number,number/2+1,-1
    xi1u_bw(m+1, j) = 0.D0
    CALL POPREAL8(xi(m+1, j))
    xi_bw(m+1, j) = 0.D0
  END DO
  DO k=1,m+1,1
    xl_bw = 0.D0
    DO j=number,number/2+1,-1
      x = xm + xr*points(j)
      temp7 = -(g0*lai/xmu0)
      temp6 = -(gg(j)*(lai-xl)/x)
      temp_bw8 = i00*2.*xgama_0(j)*xmu0*xi1u_bw(k, j)/(g0*x+gg(j)*xmu0)
      temp_bw9 = gg(j)*EXP(temp6)*EXP(temp7)*temp_bw8/x
      xi1u_bw(k, j) = 0.D0
      CALL POPREAL8(xi(k, j))
      temp5 = -(g0*lai/xmu0)
      temp4 = -(gg(j)*(lai-xl)/x)
      temp_bw10 = i00*2.*xgama_0(j)*xmu0*xi_bw(k, j)/(g0*x+gg(j)*xmu0)
      temp_bw11 = gg(j)*EXP(temp4)*EXP(temp5)*temp_bw10/x
      xl_bw = xl_bw - g0*EXP(-(g0*(xl/xmu0)))*temp_bw10/xmu0 - temp_bw11&
&       - temp_bw9 - g0*EXP(-(g0*(xl/xmu0)))*temp_bw8/xmu0
      lai_bw = lai_bw + temp_bw11 + g0*EXP(temp5)*EXP(temp4)*temp_bw10/&
&       xmu0 + g0*EXP(temp7)*EXP(temp6)*temp_bw8/xmu0 + temp_bw9
      xi_bw(k, j) = 0.D0
    END DO
    CALL POPREAL8(xl)
    dl_bw = dl_bw + FLOAT(k-1)*xl_bw
  END DO
  DO j=number/2,1,-1
    temp_bw7 = weights(j)*abs4*xr*2.*xi1_bw
    rs_bw = rs_bw + xi(m+1, j)*temp_bw7
    xi_bw(m+1, j) = xi_bw(m+1, j) + rs*temp_bw7
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(abs4)
    ELSE
      CALL POPREAL8(abs4)
    END IF
  END DO
  DO k=m+1,1,-1
    xl_bw = 0.D0
    DO j=number/2,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp_bw6 = i00*2.*xgama_0(j)*xi_bw(k, j)
        temp2 = -(g0*xl/xmu0)
        temp3 = -(g0*xl/xmu0)
        temp_bw5 = i00*2.*xgama_0(j)*xi1u_bw(k, j)
        xl_bw = xl_bw + (EXP(temp2)/xmu0-g0*EXP(temp2)*xl/xmu0**2)*&
&         temp_bw6 + (EXP(temp3)/xmu0-g0*EXP(temp3)*xl/xmu0**2)*temp_bw5
        xi1u_bw(k, j) = 0.D0
        xi_bw(k, j) = 0.D0
      ELSE
        temp_bw4 = i00*2.*xgama_0(j)*xmu0*xi1u_bw(k, j)/(gg(j)*xmu0-g0*&
&         abs7)
        xl_bw = xl_bw + (gg(j)*EXP(-(gg(j)*(xl/abs3)))/abs3-g0*EXP(-(g0*&
&         (xl/xmu0)))/xmu0)*temp_bw4
        xi1u_bw(k, j) = 0.D0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(abs7)
        ELSE
          CALL POPREAL8(abs7)
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(abs3)
        ELSE
          CALL POPREAL8(abs3)
        END IF
        temp_bw3 = i00*2.*xgama_0(j)*xmu0*xi_bw(k, j)/(gg(j)*xmu0-g0*&
&         abs6)
        xl_bw = xl_bw + (gg(j)*EXP(-(gg(j)*(xl/abs2)))/abs2-g0*EXP(-(g0*&
&         (xl/xmu0)))/xmu0)*temp_bw3
        xi_bw(k, j) = 0.D0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(abs6)
        ELSE
          CALL POPREAL8(abs6)
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(abs2)
        ELSE
          CALL POPREAL8(abs2)
        END IF
      END IF
    END DO
    CALL POPREAL8(xl)
    dl_bw = dl_bw + FLOAT(k-1)*xl_bw
  END DO
  DO k=1,m,1
    DO i=number,1,-1
      sum_bw = q0m_bw(k, i)
      q0m_bw(k, i) = 0.D0
      DO j=number,number/2+1,-1
        temp_bw2 = weights(j)*xr*xgama_xy(i, j)*sum_bw
        i0_bw(k+1, j) = i0_bw(k+1, j) + temp_bw2
        i0_bw(k, j) = i0_bw(k, j) + temp_bw2
      END DO
    END DO
  END DO
  DO k=1,m+1,1
    xl_bw = 0.D0
    DO i=number,number/2+1,-1
      x = xm + xr*points(i)
      temp1 = -(gg(i)*(lai-xl)/x)
      temp0 = -(g0*lai/xmu0)
      temp = EXP(temp0)
      temp_bw = i00*2.*xmu0*i0_bw(k, i)
      temp_bw0 = EXP(temp1)*temp_bw
      temp_bw1 = -(gg(i)*EXP(temp1)*rs*temp*temp_bw/x)
      rs_bw = rs_bw + temp*temp_bw0
      lai_bw = lai_bw + temp_bw1 - g0*EXP(temp0)*rs*temp_bw0/xmu0
      xl_bw = xl_bw - temp_bw1
      i0_bw(k, i) = 0.D0
    END DO
    CALL POPREAL8(xl)
    dl_bw = dl_bw + FLOAT(k-1)*xl_bw
  END DO
  DO k=m+1,1,-1
    xl_bw = 0.D0
    DO i=number/2,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        i0_bw(k, i) = 0.D0
      ELSE
        xl_bw = xl_bw - g0*EXP(-(g0*(xl/xmu0)))*i00*i0_bw(k, i)/xmu0
        i0_bw(k, i) = 0.D0
      END IF
    END DO
    CALL POPREAL8(xl)
    dl_bw = dl_bw + FLOAT(k-1)*xl_bw
  END DO
  DO k=min1,1,-1
    DO j=number,1,-1
      xif_bw(k, j) = 0.D0
    END DO
  END DO
  lai_bw = lai_bw + dl_bw/FLOAT(m)
END SUBROUTINE MULTIPLE_DOM_BW

!  Differentiation of convolve in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: convolve spect1
!   with respect to varying inputs: spect1
!***********************************************************
!     convolve
!
!> @brief convolves to spectra
!
!> @details TBD
!
!> @param[in]  nw      length/size of spectra
!> @param[in]  spect1  first spectrum
!> @param[in]  spect2  second spectrum
!
SUBROUTINE CONVOLVE_BW0(nw, spect1, spect1_bw, spect2, convolve_bw)
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: nw
  REAL(kind=8), INTENT(IN) :: spect1(nw), spect2(nw)
  REAL(kind=8) :: spect1_bw(nw)
! local decls
  REAL(kind=8) :: spect1_dot_spect2, spect2_sum
  REAL(kind=8) :: spect1_dot_spect2_bw
  INTRINSIC SUM
  REAL(kind=8) :: convolve_bw
  REAL(kind=8) :: convolve
  spect2_sum = SUM(spect2)
  spect1_dot_spect2_bw = convolve_bw/spect2_sum
  spect1_bw = spect1_bw + spect2*spect1_dot_spect2_bw
END SUBROUTINE CONVOLVE_BW0

!  Differentiation of sm_to_rsl1 in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: sm_to_rsl1
!   with respect to varying inputs: sm
!***********************************************************
!     sm_to_rsl1
!
!> @brief modulates the weight of first empirical orthogonal function of soil reflectance model (Price 1990) by the soil moisture
!
!> @details TBD
!
!> @param[in]  sm        volumetric soilmoisture (in range [0,1])
!> @param[in]  rsl1      1st spectral vector of soil reflectance (of Price's EOF)
!> @param[in]  sm_coeff  weighting of soil moisture impact, bound between (0,1)
!> \return  weight of first empirical orthogonal function
!
SUBROUTINE SM_TO_RSL1_BW0(sm, sm_bw, rsl1, sm_coeff, sm_to_rsl1_bw)
  IMPLICIT NONE
  REAL, INTENT(IN) :: sm
  REAL :: sm_bw
  REAL, INTENT(IN) :: rsl1
  REAL, INTENT(IN) :: sm_coeff
! SM measured volumetric,but not in percent (sm/100))
  REAL :: sm_to_rsl1_bw
  REAL :: sm_to_rsl1
  sm_bw = -(rsl1*sm_coeff*sm_to_rsl1_bw)
END SUBROUTINE SM_TO_RSL1_BW0

!  Differentiation of x2p in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: x xp
!   with respect to varying inputs: x
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!> \file mapping.f90
!> \brief mapping of 1D control vector to physical variables
!> \authors The Inversion Lab (Michael Vossbeck, Thomas Kaminski) 
!> \date  April 2018
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE X2P_BW(n, x, x_bw, xp, xp_bw)
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: xp(n)
  REAL(kind=8) :: xp_bw(n)
! local decls
  REAL(kind=8) :: sx(n), pr(n)
  EXTERNAL GETPRIOR
  CALL GETPRIOR(n, pr, sx)
  x_bw = x_bw + sx*xp_bw
END SUBROUTINE X2P_BW

!  Differentiation of control_vector_split in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: x_s1 x_s2
!   with respect to varying inputs: x
SUBROUTINE CONTROL_VECTOR_SPLIT_BW(n, x, x_bw, n_s1, x_s1, x_s1_bw, n_s2&
& , x_s2, x_s2_bw)
  USE MO_SENSIMUL
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n, n_s1, n_s2
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: x_s1(n_s1), x_s2(n_s2)
  REAL(kind=8) :: x_s1_bw(n_s1), x_s2_bw(n_s2)
! local decls
  INTEGER :: nexpect
  INTEGER :: i, j, i_s1, i_s2
  LOGICAL :: res
  LOGICAL :: res0
  INTEGER :: branch
!-- dimensional consistency
  nexpect = nparam_s1 + npts*nsc
  IF (n .NE. nexpect) THEN
    STOP
  ELSE IF (n_s1 .NE. nparam_s1 + npts_s1*nsc) THEN
    STOP
  ELSE IF (n_s2 .NE. npts_s2*nsc) THEN
    STOP
  ELSE
!-- map S1 parameter
! position in full control vector
    j = nparam_s1 + 1
! position in S1 restricted control vector
    i_s1 = nparam_s1 + 1
! position in S2 restrictred control vector
    i_s2 = 1
    DO i=1,npts
!-- point with S1 simulation
      res = IDX_IS_S1(i)
      IF (res) THEN
        CALL PUSHINTEGER4(i_s1)
        i_s1 = i_s1 + nsc
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!-- point with S2 simulation
      res0 = IDX_IS_S2(i)
      IF (res0) THEN
        CALL PUSHINTEGER4(i_s2)
        i_s2 = i_s2 + nsc
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!-- increment position in control vector
      CALL PUSHINTEGER4(j)
      j = j + nsc
    END DO
    x_bw = 0.0_8
    DO i=npts,1,-1
      CALL POPINTEGER4(j)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPINTEGER4(i_s2)
        x_bw(j:j+nsc-1) = x_bw(j:j+nsc-1) + x_s2_bw(i_s2:i_s2+nsc-1)
        x_s2_bw(i_s2:i_s2+nsc-1) = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPINTEGER4(i_s1)
        x_bw(j:j+nsc-1) = x_bw(j:j+nsc-1) + x_s1_bw(i_s1:i_s1+nsc-1)
        x_s1_bw(i_s1:i_s1+nsc-1) = 0.0_8
      END IF
    END DO
    x_bw(1:nparam_s1) = x_bw(1:nparam_s1) + x_s1_bw(1:nparam_s1)
  END IF
END SUBROUTINE CONTROL_VECTOR_SPLIT_BW

!  Differentiation of residual_prior in reverse (adjoint) mode (with options messagesInFile noinclude noISIZE r8):
!   gradient     of useful results: priordiff
!   with respect to varying inputs: x
SUBROUTINE RESIDUAL_PRIOR_BW(n, x, x_bw, priordiff, priordiff_bw)
  IMPLICIT NONE
! arguments
  INTEGER, INTENT(IN) :: n
  REAL(kind=8), INTENT(IN) :: x(n)
  REAL(kind=8) :: x_bw(n)
  REAL(kind=8) :: priordiff(n)
  REAL(kind=8) :: priordiff_bw(n)
! local
  REAL(kind=8) :: sx(n), x0(n)
! externals
  EXTERNAL GETPRIOR
!-- get prior
  x_bw = 0.0_8
  x_bw = priordiff_bw
END SUBROUTINE RESIDUAL_PRIOR_BW

